# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class EventActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Event]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Event.prisma().query_raw(
            'SELECT * FROM Event WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Event
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Event.prisma().query_first(
            'SELECT * FROM Event WHERE ticker = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EventCreateInput,
        include: Optional[types.EventInclude] = None
    ) -> _PrismaModelT:
        """Create a new Event record.

        Parameters
        ----------
        data
            Event record data
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The created Event record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Event record from just the required fields
        event = await Event.prisma().create(
            data={
                # data to create a Event record
                'id': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EventCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Event records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Event record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Event.prisma().create_many(
            data=[
                {
                    # data to create a Event record
                    'id': 'bbehjachib',
                },
                {
                    # data to create a Event record
                    'id': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Event record.

        Parameters
        ----------
        where
            Event filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The deleted Event record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Event record.

        Parameters
        ----------
        where
            Event filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The found Event record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Event record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Event filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The found Event record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Event records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Event records returned
        skip
            Ignore the first N results
        where
            Event filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Event]
            The list of all Event records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Event records
        events = await Event.prisma().find_many(take=10)

        # find the first 5 Event records ordered by the slug field
        events = await Event.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Event record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Event filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Event
            The first Event record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Event record ordered by the title field
        event = await Event.prisma().find_first(
            skip=1,
            order={
                'title': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
        include: Optional[types.EventInclude] = None,
        order: Optional[Union[types.EventOrderByInput, List[types.EventOrderByInput]]] = None,
        distinct: Optional[List[types.EventScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Event record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Event filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Event model
        order
            Order the returned Event records by any field
        distinct
            Filter Event records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Event
            The first Event record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Event record ordered by the description field
        event = await Event.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EventUpdateInput,
        where: types.EventWhereUniqueInput,
        include: Optional[types.EventInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Event record.

        Parameters
        ----------
        data
            Event record data specifying what to update
        where
            Event filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The updated Event record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        event = await Event.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the Event record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EventWhereUniqueInput,
        data: types.EventUpsertInput,
        include: Optional[types.EventInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Event filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Event model

        Returns
        -------
        prisma.models.Event
            The created or updated Event record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        event = await Event.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EventUpdateManyMutationInput,
        where: types.EventWhereInput,
    ) -> int:
        """Update multiple Event records

        Parameters
        ----------
        data
            Event data to update the selected Event records to
        where
            Filter to select the Event records to update

        Returns
        -------
        int
            The total number of Event records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Event records
        total = await Event.prisma().update_many(
            data={
                'resolutionSource': 'biabhbdai'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Event records present in the database

        Parameters
        ----------
        select
            Select the Event fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Event filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Event.prisma().count()

        # results: prisma.types.EventCountAggregateOutput
        results = await Event.prisma().count(
            select={
                '_all': True,
                'startDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EventCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> types.EventCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EventCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EventWhereInput] = None,
        cursor: Optional[types.EventWhereUniqueInput] = None,
    ) -> Union[int, types.EventCountAggregateOutput]:
        """Count the number of Event records present in the database

        Parameters
        ----------
        select
            Select the Event fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Event filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EventCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Event.prisma().count()

        # results: prisma.types.EventCountAggregateOutput
        results = await Event.prisma().count(
            select={
                '_all': True,
                'creationDate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EventCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EventWhereInput] = None
    ) -> int:
        """Delete multiple Event records.

        Parameters
        ----------
        where
            Optional Event filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Event records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Event records
        total = await Event.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EventScalarFieldKeys'],
        *,
        where: Optional['types.EventWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EventAvgAggregateInput'] = None,
        sum: Optional['types.EventSumAggregateInput'] = None,
        min: Optional['types.EventMinAggregateInput'] = None,
        max: Optional['types.EventMaxAggregateInput'] = None,
        having: Optional['types.EventScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EventCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EventScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EventScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EventGroupByOutput']:
        """Group Event records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Event fields to group records by
        where
            Event filter to select records
        take
            Limit the maximum number of Event records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EventGroupByOutput]
            A list of dictionaries representing the Event record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Event records by endDate values
        # and count how many records are in each group
        results = await Event.prisma().group_by(
            ['endDate'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MarketActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Market]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Market.prisma().query_raw(
            'SELECT * FROM Market WHERE id = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Market
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Market.prisma().query_first(
            'SELECT * FROM Market WHERE conditionId = $1',
            'fjfddhigg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MarketCreateInput,
        include: Optional[types.MarketInclude] = None
    ) -> _PrismaModelT:
        """Create a new Market record.

        Parameters
        ----------
        data
            Market record data
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The created Market record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Market record from just the required fields
        market = await Market.prisma().create(
            data={
                # data to create a Market record
                'id': 'hjaecfifb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MarketCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Market records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Market record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Market.prisma().create_many(
            data=[
                {
                    # data to create a Market record
                    'id': 'cbbbjbfcii',
                },
                {
                    # data to create a Market record
                    'id': 'bbejhfidcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MarketWhereUniqueInput,
        include: Optional[types.MarketInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Market record.

        Parameters
        ----------
        where
            Market filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The deleted Market record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        market = await Market.prisma().delete(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MarketWhereUniqueInput,
        include: Optional[types.MarketInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Market record.

        Parameters
        ----------
        where
            Market filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The found Market record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        market = await Market.prisma().find_unique(
            where={
                'id': 'bdiicjafbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MarketWhereUniqueInput,
        include: Optional[types.MarketInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Market record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Market filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The found Market record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        market = await Market.prisma().find_unique_or_raise(
            where={
                'id': 'bgehebiafc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
        include: Optional[types.MarketInclude] = None,
        order: Optional[Union[types.MarketOrderByInput, List[types.MarketOrderByInput]]] = None,
        distinct: Optional[List[types.MarketScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Market records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Market records returned
        skip
            Ignore the first N results
        where
            Market filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Market model
        order
            Order the returned Market records by any field
        distinct
            Filter Market records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Market]
            The list of all Market records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Market records
        markets = await Market.prisma().find_many(take=10)

        # find the first 5 Market records ordered by the questionID field
        markets = await Market.prisma().find_many(
            take=5,
            order={
                'questionID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
        include: Optional[types.MarketInclude] = None,
        order: Optional[Union[types.MarketOrderByInput, List[types.MarketOrderByInput]]] = None,
        distinct: Optional[List[types.MarketScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Market record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Market filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Market model
        order
            Order the returned Market records by any field
        distinct
            Filter Market records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Market
            The first Market record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Market record ordered by the slug field
        market = await Market.prisma().find_first(
            skip=1,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
        include: Optional[types.MarketInclude] = None,
        order: Optional[Union[types.MarketOrderByInput, List[types.MarketOrderByInput]]] = None,
        distinct: Optional[List[types.MarketScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Market record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Market filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Market model
        order
            Order the returned Market records by any field
        distinct
            Filter Market records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Market
            The first Market record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Market record ordered by the question field
        market = await Market.prisma().find_first_or_raise(
            skip=1,
            order={
                'question': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MarketUpdateInput,
        where: types.MarketWhereUniqueInput,
        include: Optional[types.MarketInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Market record.

        Parameters
        ----------
        data
            Market record data specifying what to update
        where
            Market filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The updated Market record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        market = await Market.prisma().update(
            where={
                'id': 'bghffegacj',
            },
            data={
                # data to update the Market record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MarketWhereUniqueInput,
        data: types.MarketUpsertInput,
        include: Optional[types.MarketInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Market filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Market model

        Returns
        -------
        prisma.models.Market
            The created or updated Market record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        market = await Market.prisma().upsert(
            where={
                'id': 'bhghchehcc',
            },
            data={
                'create': {
                    'id': 'bhghchehcc',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MarketUpdateManyMutationInput,
        where: types.MarketWhereInput,
    ) -> int:
        """Update multiple Market records

        Parameters
        ----------
        data
            Market data to update the selected Market records to
        where
            Filter to select the Market records to update

        Returns
        -------
        int
            The total number of Market records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Market records
        total = await Market.prisma().update_many(
            data={
                'description': 'dcgchcbbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Market records present in the database

        Parameters
        ----------
        select
            Select the Market fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Market filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MarketCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Market.prisma().count()

        # results: prisma.types.MarketCountAggregateOutput
        results = await Market.prisma().count(
            select={
                '_all': True,
                'category': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MarketCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
    ) -> types.MarketCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MarketCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketWhereInput] = None,
        cursor: Optional[types.MarketWhereUniqueInput] = None,
    ) -> Union[int, types.MarketCountAggregateOutput]:
        """Count the number of Market records present in the database

        Parameters
        ----------
        select
            Select the Market fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Market filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MarketCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Market.prisma().count()

        # results: prisma.types.MarketCountAggregateOutput
        results = await Market.prisma().count(
            select={
                '_all': True,
                'image': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MarketCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MarketWhereInput] = None
    ) -> int:
        """Delete multiple Market records.

        Parameters
        ----------
        where
            Optional Market filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Market records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Market records
        total = await Market.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MarketScalarFieldKeys'],
        *,
        where: Optional['types.MarketWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MarketAvgAggregateInput'] = None,
        sum: Optional['types.MarketSumAggregateInput'] = None,
        min: Optional['types.MarketMinAggregateInput'] = None,
        max: Optional['types.MarketMaxAggregateInput'] = None,
        having: Optional['types.MarketScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MarketCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MarketScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MarketScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MarketGroupByOutput']:
        """Group Market records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Market fields to group records by
        where
            Market filter to select records
        take
            Limit the maximum number of Market records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MarketGroupByOutput]
            A list of dictionaries representing the Market record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Market records by icon values
        # and count how many records are in each group
        results = await Market.prisma().group_by(
            ['icon'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MarketOutcomeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.MarketOutcome]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await MarketOutcome.prisma().query_raw(
            'SELECT * FROM MarketOutcome WHERE id = $1',
            1343201072,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.MarketOutcome
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await MarketOutcome.prisma().query_first(
            'SELECT * FROM MarketOutcome WHERE clobTokenId = $1',
            'ghfhiafcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MarketOutcomeCreateInput,
        include: Optional[types.MarketOutcomeInclude] = None
    ) -> _PrismaModelT:
        """Create a new MarketOutcome record.

        Parameters
        ----------
        data
            MarketOutcome record data
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The created MarketOutcome record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a MarketOutcome record from just the required fields
        marketoutcome = await MarketOutcome.prisma().create(
            data={
                # data to create a MarketOutcome record
                'clobTokenId': 'heejgedji',
                'marketId': 'bjgjgibgbf',
                'outcomeText': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MarketOutcomeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple MarketOutcome records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of MarketOutcome record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await MarketOutcome.prisma().create_many(
            data=[
                {
                    # data to create a MarketOutcome record
                    'clobTokenId': 'igbehcbab',
                    'marketId': 'bdadaadhag',
                    'outcomeText': 'bgiggdidbf',
                },
                {
                    # data to create a MarketOutcome record
                    'clobTokenId': 'caaaedabfc',
                    'marketId': 'bigibebcib',
                    'outcomeText': 'bigaiehgcc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MarketOutcomeWhereUniqueInput,
        include: Optional[types.MarketOutcomeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single MarketOutcome record.

        Parameters
        ----------
        where
            MarketOutcome filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The deleted MarketOutcome record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        marketoutcome = await MarketOutcome.prisma().delete(
            where={
                'id': 1448521415,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MarketOutcomeWhereUniqueInput,
        include: Optional[types.MarketOutcomeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique MarketOutcome record.

        Parameters
        ----------
        where
            MarketOutcome filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The found MarketOutcome record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        marketoutcome = await MarketOutcome.prisma().find_unique(
            where={
                'id': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MarketOutcomeWhereUniqueInput,
        include: Optional[types.MarketOutcomeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique MarketOutcome record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            MarketOutcome filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The found MarketOutcome record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        marketoutcome = await MarketOutcome.prisma().find_unique_or_raise(
            where={
                'id': 1249606685,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
        include: Optional[types.MarketOutcomeInclude] = None,
        order: Optional[Union[types.MarketOutcomeOrderByInput, List[types.MarketOutcomeOrderByInput]]] = None,
        distinct: Optional[List[types.MarketOutcomeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple MarketOutcome records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of MarketOutcome records returned
        skip
            Ignore the first N results
        where
            MarketOutcome filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MarketOutcome model
        order
            Order the returned MarketOutcome records by any field
        distinct
            Filter MarketOutcome records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.MarketOutcome]
            The list of all MarketOutcome records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 MarketOutcome records
        marketoutcomes = await MarketOutcome.prisma().find_many(take=10)

        # find the first 5 MarketOutcome records ordered by the marketId field
        marketoutcomes = await MarketOutcome.prisma().find_many(
            take=5,
            order={
                'marketId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
        include: Optional[types.MarketOutcomeInclude] = None,
        order: Optional[Union[types.MarketOutcomeOrderByInput, List[types.MarketOutcomeOrderByInput]]] = None,
        distinct: Optional[List[types.MarketOutcomeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single MarketOutcome record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MarketOutcome filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MarketOutcome model
        order
            Order the returned MarketOutcome records by any field
        distinct
            Filter MarketOutcome records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MarketOutcome
            The first MarketOutcome record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MarketOutcome record ordered by the outcomeText field
        marketoutcome = await MarketOutcome.prisma().find_first(
            skip=1,
            order={
                'outcomeText': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
        include: Optional[types.MarketOutcomeInclude] = None,
        order: Optional[Union[types.MarketOutcomeOrderByInput, List[types.MarketOutcomeOrderByInput]]] = None,
        distinct: Optional[List[types.MarketOutcomeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single MarketOutcome record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            MarketOutcome filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned MarketOutcome model
        order
            Order the returned MarketOutcome records by any field
        distinct
            Filter MarketOutcome records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.MarketOutcome
            The first MarketOutcome record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second MarketOutcome record ordered by the pricesScrapedAt field
        marketoutcome = await MarketOutcome.prisma().find_first_or_raise(
            skip=1,
            order={
                'pricesScrapedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MarketOutcomeUpdateInput,
        where: types.MarketOutcomeWhereUniqueInput,
        include: Optional[types.MarketOutcomeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single MarketOutcome record.

        Parameters
        ----------
        data
            MarketOutcome record data specifying what to update
        where
            MarketOutcome filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The updated MarketOutcome record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        marketoutcome = await MarketOutcome.prisma().update(
            where={
                'id': 835903122,
            },
            data={
                # data to update the MarketOutcome record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MarketOutcomeWhereUniqueInput,
        data: types.MarketOutcomeUpsertInput,
        include: Optional[types.MarketOutcomeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            MarketOutcome filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned MarketOutcome model

        Returns
        -------
        prisma.models.MarketOutcome
            The created or updated MarketOutcome record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        marketoutcome = await MarketOutcome.prisma().upsert(
            where={
                'id': 763719779,
            },
            data={
                'create': {
                    'id': 763719779,
                    'clobTokenId': 'caaaedabfc',
                    'marketId': 'bigibebcib',
                    'outcomeText': 'bigaiehgcc',
                },
                'update': {
                    'clobTokenId': 'caaaedabfc',
                    'marketId': 'bigibebcib',
                    'outcomeText': 'bigaiehgcc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MarketOutcomeUpdateManyMutationInput,
        where: types.MarketOutcomeWhereInput,
    ) -> int:
        """Update multiple MarketOutcome records

        Parameters
        ----------
        data
            MarketOutcome data to update the selected MarketOutcome records to
        where
            Filter to select the MarketOutcome records to update

        Returns
        -------
        int
            The total number of MarketOutcome records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all MarketOutcome records
        total = await MarketOutcome.prisma().update_many(
            data={
                'pricesCount': 429995104
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of MarketOutcome records present in the database

        Parameters
        ----------
        select
            Select the MarketOutcome fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MarketOutcome filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MarketOutcomeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MarketOutcome.prisma().count()

        # results: prisma.types.MarketOutcomeCountAggregateOutput
        results = await MarketOutcome.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MarketOutcomeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
    ) -> types.MarketOutcomeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MarketOutcomeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MarketOutcomeWhereInput] = None,
        cursor: Optional[types.MarketOutcomeWhereUniqueInput] = None,
    ) -> Union[int, types.MarketOutcomeCountAggregateOutput]:
        """Count the number of MarketOutcome records present in the database

        Parameters
        ----------
        select
            Select the MarketOutcome fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            MarketOutcome filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MarketOutcomeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await MarketOutcome.prisma().count()

        # results: prisma.types.MarketOutcomeCountAggregateOutput
        results = await MarketOutcome.prisma().count(
            select={
                '_all': True,
                'clobTokenId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MarketOutcomeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MarketOutcomeWhereInput] = None
    ) -> int:
        """Delete multiple MarketOutcome records.

        Parameters
        ----------
        where
            Optional MarketOutcome filter to find the records to be deleted

        Returns
        -------
        int
            The total number of MarketOutcome records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all MarketOutcome records
        total = await MarketOutcome.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MarketOutcomeScalarFieldKeys'],
        *,
        where: Optional['types.MarketOutcomeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MarketOutcomeAvgAggregateInput'] = None,
        sum: Optional['types.MarketOutcomeSumAggregateInput'] = None,
        min: Optional['types.MarketOutcomeMinAggregateInput'] = None,
        max: Optional['types.MarketOutcomeMaxAggregateInput'] = None,
        having: Optional['types.MarketOutcomeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MarketOutcomeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MarketOutcomeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MarketOutcomeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MarketOutcomeGroupByOutput']:
        """Group MarketOutcome records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar MarketOutcome fields to group records by
        where
            MarketOutcome filter to select records
        take
            Limit the maximum number of MarketOutcome records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MarketOutcomeGroupByOutput]
            A list of dictionaries representing the MarketOutcome record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group MarketOutcome records by marketId values
        # and count how many records are in each group
        results = await MarketOutcome.prisma().group_by(
            ['marketId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tag.prisma().query_raw(
            'SELECT * FROM Tag WHERE id = $1',
            'bhhfibbigf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tag.prisma().query_first(
            'SELECT * FROM Tag WHERE label = $1',
            'ijdbeffgg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TagCreateInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tag record.

        Parameters
        ----------
        data
            Tag record data
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created Tag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tag record from just the required fields
        tag = await Tag.prisma().create(
            data={
                # data to create a Tag record
                'id': 'jjfeafhfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tag.prisma().create_many(
            data=[
                {
                    # data to create a Tag record
                    'id': 'cbachdgfce',
                },
                {
                    # data to create a Tag record
                    'id': 'chbfcacbd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tag record.

        Parameters
        ----------
        where
            Tag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The deleted Tag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().delete(
            where={
                'id': 'efggddide',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tag record.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique(
            where={
                'id': 'caficfigfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique_or_raise(
            where={
                'id': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N results
        where
            Tag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tag]
            The list of all Tag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tag records
        tags = await Tag.prisma().find_many(take=10)

        # find the first 5 Tag records ordered by the slug field
        tags = await Tag.prisma().find_many(
            take=5,
            order={
                'slug': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the forceShow field
        tag = await Tag.prisma().find_first(
            skip=1,
            order={
                'forceShow': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the forceHide field
        tag = await Tag.prisma().find_first_or_raise(
            skip=1,
            order={
                'forceHide': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TagUpdateInput,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tag record.

        Parameters
        ----------
        data
            Tag record data specifying what to update
        where
            Tag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The updated Tag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tag = await Tag.prisma().update(
            where={
                'id': 'ihieecagf',
            },
            data={
                # data to update the Tag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TagWhereUniqueInput,
        data: types.TagUpsertInput,
        include: Optional[types.TagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created or updated Tag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().upsert(
            where={
                'id': 'bghfciaafe',
            },
            data={
                'create': {
                    'id': 'bghfciaafe',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TagUpdateManyMutationInput,
        where: types.TagWhereInput,
    ) -> int:
        """Update multiple Tag records

        Parameters
        ----------
        data
            Tag data to update the selected Tag records to
        where
            Filter to select the Tag records to update

        Returns
        -------
        int
            The total number of Tag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tag records
        total = await Tag.prisma().update_many(
            data={
                'isCarousel': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'publishedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> types.TagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> Union[int, types.TagCountAggregateOutput]:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'createdBy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TagWhereInput] = None
    ) -> int:
        """Delete multiple Tag records.

        Parameters
        ----------
        where
            Optional Tag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tag records
        total = await Tag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TagScalarFieldKeys'],
        *,
        where: Optional['types.TagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TagAvgAggregateInput'] = None,
        sum: Optional['types.TagSumAggregateInput'] = None,
        min: Optional['types.TagMinAggregateInput'] = None,
        max: Optional['types.TagMaxAggregateInput'] = None,
        having: Optional['types.TagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TagGroupByOutput']:
        """Group Tag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tag fields to group records by
        where
            Tag filter to select records
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TagGroupByOutput]
            A list of dictionaries representing the Tag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tag records by updatedBy values
        # and count how many records are in each group
        results = await Tag.prisma().group_by(
            ['updatedBy'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Comment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Comment.prisma().query_raw(
            'SELECT * FROM Comment WHERE id = $1',
            'cafeiaccbc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Comment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Comment.prisma().query_first(
            'SELECT * FROM Comment WHERE body = $1',
            'gaddfhfh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CommentCreateInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Comment record.

        Parameters
        ----------
        data
            Comment record data
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created Comment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Comment record from just the required fields
        comment = await Comment.prisma().create(
            data={
                # data to create a Comment record
                'id': 'gieegcbeg',
                'body': 'bgcffadich',
                'userAddress': 'fcbichhci',
                'parentEntityType': 'bcggadccgf',
                'parentEntityID': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Comment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Comment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Comment.prisma().create_many(
            data=[
                {
                    # data to create a Comment record
                    'id': 'cafdaehjid',
                    'body': 'gifdddbia',
                    'userAddress': 'bchehecef',
                    'parentEntityType': 'jeijcbhfe',
                    'parentEntityID': 'bjgejjabff',
                },
                {
                    # data to create a Comment record
                    'id': 'bcciijbibg',
                    'body': 'cffcachfd',
                    'userAddress': 'bccdfhdigc',
                    'parentEntityType': 'febcgjbfj',
                    'parentEntityID': 'bageiegghg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Comment record.

        Parameters
        ----------
        where
            Comment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The deleted Comment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().delete(
            where={
                'id': 'faidicegb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Comment record.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Comment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique_or_raise(
            where={
                'id': 'ihcahiead',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Comment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N results
        where
            Comment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Comment]
            The list of all Comment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Comment records
        comments = await Comment.prisma().find_many(take=10)

        # find the first 5 Comment records ordered by the userAddress field
        comments = await Comment.prisma().find_many(
            take=5,
            order={
                'userAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Comment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the replyAddress field
        comment = await Comment.prisma().find_first(
            skip=1,
            order={
                'replyAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Comment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the parentEntityType field
        comment = await Comment.prisma().find_first_or_raise(
            skip=1,
            order={
                'parentEntityType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommentUpdateInput,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Comment record.

        Parameters
        ----------
        data
            Comment record data specifying what to update
        where
            Comment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The updated Comment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comment = await Comment.prisma().update(
            where={
                'id': 'biheheiajg',
            },
            data={
                # data to update the Comment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommentWhereUniqueInput,
        data: types.CommentUpsertInput,
        include: Optional[types.CommentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Comment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created or updated Comment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().upsert(
            where={
                'id': 'jbgijghgb',
            },
            data={
                'create': {
                    'id': 'jbgijghgb',
                    'body': 'cffcachfd',
                    'userAddress': 'bccdfhdigc',
                    'parentEntityType': 'febcgjbfj',
                    'parentEntityID': 'bageiegghg',
                },
                'update': {
                    'body': 'cffcachfd',
                    'userAddress': 'bccdfhdigc',
                    'parentEntityType': 'febcgjbfj',
                    'parentEntityID': 'bageiegghg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommentUpdateManyMutationInput,
        where: types.CommentWhereInput,
    ) -> int:
        """Update multiple Comment records

        Parameters
        ----------
        data
            Comment data to update the selected Comment records to
        where
            Filter to select the Comment records to update

        Returns
        -------
        int
            The total number of Comment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Comment records
        total = await Comment.prisma().update_many(
            data={
                'parentEntityID': 'hgjcghfbi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'reactionCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> types.CommentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> Union[int, types.CommentCountAggregateOutput]:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'reportCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommentWhereInput] = None
    ) -> int:
        """Delete multiple Comment records.

        Parameters
        ----------
        where
            Optional Comment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Comment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Comment records
        total = await Comment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommentScalarFieldKeys'],
        *,
        where: Optional['types.CommentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommentAvgAggregateInput'] = None,
        sum: Optional['types.CommentSumAggregateInput'] = None,
        min: Optional['types.CommentMinAggregateInput'] = None,
        max: Optional['types.CommentMaxAggregateInput'] = None,
        having: Optional['types.CommentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommentGroupByOutput']:
        """Group Comment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Comment fields to group records by
        where
            Comment filter to select records
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommentGroupByOutput]
            A list of dictionaries representing the Comment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Comment records by createdAt values
        # and count how many records are in each group
        results = await Comment.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommentReactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CommentReaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CommentReaction.prisma().query_raw(
            'SELECT * FROM CommentReaction WHERE id = $1',
            'icadbcehj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CommentReaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CommentReaction.prisma().query_first(
            'SELECT * FROM CommentReaction WHERE reactionType = $1',
            'jchciaee',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CommentReactionCreateInput,
        include: Optional[types.CommentReactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new CommentReaction record.

        Parameters
        ----------
        data
            CommentReaction record data
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The created CommentReaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CommentReaction record from just the required fields
        commentreaction = await CommentReaction.prisma().create(
            data={
                # data to create a CommentReaction record
                'id': 'deeificjd',
                'reactionType': 'bbcbhebbda',
                'userAddress': 'bejfijgcfb',
                'commentID': 'caifcbgii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommentReactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CommentReaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CommentReaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CommentReaction.prisma().create_many(
            data=[
                {
                    # data to create a CommentReaction record
                    'id': 'igaibbfgj',
                    'reactionType': 'bggajdcbbi',
                    'userAddress': 'fcfhgbjed',
                    'commentID': 'hdgcajhjg',
                },
                {
                    # data to create a CommentReaction record
                    'id': 'ejdjahicb',
                    'reactionType': 'gdjgigfgc',
                    'userAddress': 'gfeaahdeh',
                    'commentID': 'bjafcgbffc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommentReactionWhereUniqueInput,
        include: Optional[types.CommentReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CommentReaction record.

        Parameters
        ----------
        where
            CommentReaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The deleted CommentReaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentreaction = await CommentReaction.prisma().delete(
            where={
                'id': 'hihegjif',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommentReactionWhereUniqueInput,
        include: Optional[types.CommentReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CommentReaction record.

        Parameters
        ----------
        where
            CommentReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The found CommentReaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentreaction = await CommentReaction.prisma().find_unique(
            where={
                'id': 'bdjidcidac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommentReactionWhereUniqueInput,
        include: Optional[types.CommentReactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CommentReaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CommentReaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The found CommentReaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentreaction = await CommentReaction.prisma().find_unique_or_raise(
            where={
                'id': 'ifgaaagff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
        include: Optional[types.CommentReactionInclude] = None,
        order: Optional[Union[types.CommentReactionOrderByInput, List[types.CommentReactionOrderByInput]]] = None,
        distinct: Optional[List[types.CommentReactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CommentReaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CommentReaction records returned
        skip
            Ignore the first N results
        where
            CommentReaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentReaction model
        order
            Order the returned CommentReaction records by any field
        distinct
            Filter CommentReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CommentReaction]
            The list of all CommentReaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CommentReaction records
        commentreactions = await CommentReaction.prisma().find_many(take=10)

        # find the first 5 CommentReaction records ordered by the userAddress field
        commentreactions = await CommentReaction.prisma().find_many(
            take=5,
            order={
                'userAddress': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
        include: Optional[types.CommentReactionInclude] = None,
        order: Optional[Union[types.CommentReactionOrderByInput, List[types.CommentReactionOrderByInput]]] = None,
        distinct: Optional[List[types.CommentReactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CommentReaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommentReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentReaction model
        order
            Order the returned CommentReaction records by any field
        distinct
            Filter CommentReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommentReaction
            The first CommentReaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommentReaction record ordered by the commentID field
        commentreaction = await CommentReaction.prisma().find_first(
            skip=1,
            order={
                'commentID': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
        include: Optional[types.CommentReactionInclude] = None,
        order: Optional[Union[types.CommentReactionOrderByInput, List[types.CommentReactionOrderByInput]]] = None,
        distinct: Optional[List[types.CommentReactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CommentReaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommentReaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentReaction model
        order
            Order the returned CommentReaction records by any field
        distinct
            Filter CommentReaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommentReaction
            The first CommentReaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommentReaction record ordered by the id field
        commentreaction = await CommentReaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommentReactionUpdateInput,
        where: types.CommentReactionWhereUniqueInput,
        include: Optional[types.CommentReactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CommentReaction record.

        Parameters
        ----------
        data
            CommentReaction record data specifying what to update
        where
            CommentReaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The updated CommentReaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        commentreaction = await CommentReaction.prisma().update(
            where={
                'id': 'befcddgjce',
            },
            data={
                # data to update the CommentReaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommentReactionWhereUniqueInput,
        data: types.CommentReactionUpsertInput,
        include: Optional[types.CommentReactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CommentReaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CommentReaction model

        Returns
        -------
        prisma.models.CommentReaction
            The created or updated CommentReaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentreaction = await CommentReaction.prisma().upsert(
            where={
                'id': 'bfhdbjjgfd',
            },
            data={
                'create': {
                    'id': 'bfhdbjjgfd',
                    'reactionType': 'gdjgigfgc',
                    'userAddress': 'gfeaahdeh',
                    'commentID': 'bjafcgbffc',
                },
                'update': {
                    'reactionType': 'gdjgigfgc',
                    'userAddress': 'gfeaahdeh',
                    'commentID': 'bjafcgbffc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommentReactionUpdateManyMutationInput,
        where: types.CommentReactionWhereInput,
    ) -> int:
        """Update multiple CommentReaction records

        Parameters
        ----------
        data
            CommentReaction data to update the selected CommentReaction records to
        where
            Filter to select the CommentReaction records to update

        Returns
        -------
        int
            The total number of CommentReaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CommentReaction records
        total = await CommentReaction.prisma().update_many(
            data={
                'reactionType': 'cabdjadaji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CommentReaction records present in the database

        Parameters
        ----------
        select
            Select the CommentReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommentReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommentReaction.prisma().count()

        # results: prisma.types.CommentReactionCountAggregateOutput
        results = await CommentReaction.prisma().count(
            select={
                '_all': True,
                'userAddress': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommentReactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
    ) -> types.CommentReactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommentReactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentReactionWhereInput] = None,
        cursor: Optional[types.CommentReactionWhereUniqueInput] = None,
    ) -> Union[int, types.CommentReactionCountAggregateOutput]:
        """Count the number of CommentReaction records present in the database

        Parameters
        ----------
        select
            Select the CommentReaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommentReaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentReactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommentReaction.prisma().count()

        # results: prisma.types.CommentReactionCountAggregateOutput
        results = await CommentReaction.prisma().count(
            select={
                '_all': True,
                'commentID': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommentReactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommentReactionWhereInput] = None
    ) -> int:
        """Delete multiple CommentReaction records.

        Parameters
        ----------
        where
            Optional CommentReaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CommentReaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CommentReaction records
        total = await CommentReaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommentReactionScalarFieldKeys'],
        *,
        where: Optional['types.CommentReactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommentReactionAvgAggregateInput'] = None,
        sum: Optional['types.CommentReactionSumAggregateInput'] = None,
        min: Optional['types.CommentReactionMinAggregateInput'] = None,
        max: Optional['types.CommentReactionMaxAggregateInput'] = None,
        having: Optional['types.CommentReactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommentReactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommentReactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommentReactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommentReactionGroupByOutput']:
        """Group CommentReaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CommentReaction fields to group records by
        where
            CommentReaction filter to select records
        take
            Limit the maximum number of CommentReaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommentReactionGroupByOutput]
            A list of dictionaries representing the CommentReaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CommentReaction records by id values
        # and count how many records are in each group
        results = await CommentReaction.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserProfile.prisma().query_raw(
            'SELECT * FROM UserProfile WHERE address = $1',
            'faajgfadf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserProfile.prisma().query_first(
            'SELECT * FROM UserProfile WHERE name = $1',
            'biaagcedjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserProfileCreateInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created UserProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserProfile record from just the required fields
        userprofile = await UserProfile.prisma().create(
            data={
                # data to create a UserProfile record
                'address': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserProfile.prisma().create_many(
            data=[
                {
                    # data to create a UserProfile record
                    'address': 'bghcbbcidi',
                },
                {
                    # data to create a UserProfile record
                    'address': 'jcgghhgdj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The deleted UserProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().delete(
            where={
                'address': 'beehgcebbg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique(
            where={
                'address': 'bhdiaidiaf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique_or_raise(
            where={
                'address': 'deajegcfi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N results
        where
            UserProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserProfile]
            The list of all UserProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserProfile records
        userprofiles = await UserProfile.prisma().find_many(take=10)

        # find the first 5 UserProfile records ordered by the pseudonym field
        userprofiles = await UserProfile.prisma().find_many(
            take=5,
            order={
                'pseudonym': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the displayUsernamePublic field
        userprofile = await UserProfile.prisma().find_first(
            skip=1,
            order={
                'displayUsernamePublic': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the bio field
        userprofile = await UserProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'bio': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserProfileUpdateInput,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data specifying what to update
        where
            UserProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The updated UserProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().update(
            where={
                'address': 'gabahhhjf',
            },
            data={
                # data to update the UserProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserProfileWhereUniqueInput,
        data: types.UserProfileUpsertInput,
        include: Optional[types.UserProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created or updated UserProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().upsert(
            where={
                'address': 'cjagadcjg',
            },
            data={
                'create': {
                    'address': 'cjagadcjg',
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserProfileUpdateManyMutationInput,
        where: types.UserProfileWhereInput,
    ) -> int:
        """Update multiple UserProfile records

        Parameters
        ----------
        data
            UserProfile data to update the selected UserProfile records to
        where
            Filter to select the UserProfile records to update

        Returns
        -------
        int
            The total number of UserProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserProfile records
        total = await UserProfile.prisma().update_many(
            data={
                'isMod': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'isCreator': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> types.UserProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> Union[int, types.UserProfileCountAggregateOutput]:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'proxyWallet': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserProfileWhereInput] = None
    ) -> int:
        """Delete multiple UserProfile records.

        Parameters
        ----------
        where
            Optional UserProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserProfile records
        total = await UserProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserProfileScalarFieldKeys'],
        *,
        where: Optional['types.UserProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserProfileAvgAggregateInput'] = None,
        sum: Optional['types.UserProfileSumAggregateInput'] = None,
        min: Optional['types.UserProfileMinAggregateInput'] = None,
        max: Optional['types.UserProfileMaxAggregateInput'] = None,
        having: Optional['types.UserProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserProfileGroupByOutput']:
        """Group UserProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserProfile fields to group records by
        where
            UserProfile filter to select records
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserProfileGroupByOutput]
            A list of dictionaries representing the UserProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserProfile records by baseAddress values
        # and count how many records are in each group
        results = await UserProfile.prisma().group_by(
            ['baseAddress'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommentCheckpointActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CommentCheckpoint]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CommentCheckpoint.prisma().query_raw(
            'SELECT * FROM CommentCheckpoint WHERE id = $1',
            1611009182,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CommentCheckpoint
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CommentCheckpoint.prisma().query_first(
            'SELECT * FROM CommentCheckpoint WHERE eventId = $1',
            'eegghdhjb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CommentCheckpointCreateInput,
        include: Optional[types.CommentCheckpointInclude] = None
    ) -> _PrismaModelT:
        """Create a new CommentCheckpoint record.

        Parameters
        ----------
        data
            CommentCheckpoint record data
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The created CommentCheckpoint record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CommentCheckpoint record from just the required fields
        commentcheckpoint = await CommentCheckpoint.prisma().create(
            data={
                # data to create a CommentCheckpoint record
                'eventId': 'daafgidjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommentCheckpointCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CommentCheckpoint records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CommentCheckpoint record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CommentCheckpoint.prisma().create_many(
            data=[
                {
                    # data to create a CommentCheckpoint record
                    'eventId': 'gdcgcgagj',
                },
                {
                    # data to create a CommentCheckpoint record
                    'eventId': 'bhceabbgja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommentCheckpointWhereUniqueInput,
        include: Optional[types.CommentCheckpointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CommentCheckpoint record.

        Parameters
        ----------
        where
            CommentCheckpoint filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The deleted CommentCheckpoint record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentcheckpoint = await CommentCheckpoint.prisma().delete(
            where={
                'id': 470157467,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommentCheckpointWhereUniqueInput,
        include: Optional[types.CommentCheckpointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CommentCheckpoint record.

        Parameters
        ----------
        where
            CommentCheckpoint filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The found CommentCheckpoint record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentcheckpoint = await CommentCheckpoint.prisma().find_unique(
            where={
                'id': 1209209912,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommentCheckpointWhereUniqueInput,
        include: Optional[types.CommentCheckpointInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CommentCheckpoint record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CommentCheckpoint filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The found CommentCheckpoint record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentcheckpoint = await CommentCheckpoint.prisma().find_unique_or_raise(
            where={
                'id': 1536744465,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
        include: Optional[types.CommentCheckpointInclude] = None,
        order: Optional[Union[types.CommentCheckpointOrderByInput, List[types.CommentCheckpointOrderByInput]]] = None,
        distinct: Optional[List[types.CommentCheckpointScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CommentCheckpoint records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CommentCheckpoint records returned
        skip
            Ignore the first N results
        where
            CommentCheckpoint filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model
        order
            Order the returned CommentCheckpoint records by any field
        distinct
            Filter CommentCheckpoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CommentCheckpoint]
            The list of all CommentCheckpoint records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CommentCheckpoint records
        commentcheckpoints = await CommentCheckpoint.prisma().find_many(take=10)

        # find the first 5 CommentCheckpoint records ordered by the lastOffset field
        commentcheckpoints = await CommentCheckpoint.prisma().find_many(
            take=5,
            order={
                'lastOffset': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
        include: Optional[types.CommentCheckpointInclude] = None,
        order: Optional[Union[types.CommentCheckpointOrderByInput, List[types.CommentCheckpointOrderByInput]]] = None,
        distinct: Optional[List[types.CommentCheckpointScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CommentCheckpoint record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommentCheckpoint filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model
        order
            Order the returned CommentCheckpoint records by any field
        distinct
            Filter CommentCheckpoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommentCheckpoint
            The first CommentCheckpoint record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommentCheckpoint record ordered by the totalFetched field
        commentcheckpoint = await CommentCheckpoint.prisma().find_first(
            skip=1,
            order={
                'totalFetched': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
        include: Optional[types.CommentCheckpointInclude] = None,
        order: Optional[Union[types.CommentCheckpointOrderByInput, List[types.CommentCheckpointOrderByInput]]] = None,
        distinct: Optional[List[types.CommentCheckpointScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CommentCheckpoint record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CommentCheckpoint filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model
        order
            Order the returned CommentCheckpoint records by any field
        distinct
            Filter CommentCheckpoint records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CommentCheckpoint
            The first CommentCheckpoint record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CommentCheckpoint record ordered by the lastScrapedAt field
        commentcheckpoint = await CommentCheckpoint.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastScrapedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommentCheckpointUpdateInput,
        where: types.CommentCheckpointWhereUniqueInput,
        include: Optional[types.CommentCheckpointInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CommentCheckpoint record.

        Parameters
        ----------
        data
            CommentCheckpoint record data specifying what to update
        where
            CommentCheckpoint filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The updated CommentCheckpoint record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        commentcheckpoint = await CommentCheckpoint.prisma().update(
            where={
                'id': 424218998,
            },
            data={
                # data to update the CommentCheckpoint record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommentCheckpointWhereUniqueInput,
        data: types.CommentCheckpointUpsertInput,
        include: Optional[types.CommentCheckpointInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CommentCheckpoint filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CommentCheckpoint model

        Returns
        -------
        prisma.models.CommentCheckpoint
            The created or updated CommentCheckpoint record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        commentcheckpoint = await CommentCheckpoint.prisma().upsert(
            where={
                'id': 2125632375,
            },
            data={
                'create': {
                    'id': 2125632375,
                    'eventId': 'bhceabbgja',
                },
                'update': {
                    'eventId': 'bhceabbgja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommentCheckpointUpdateManyMutationInput,
        where: types.CommentCheckpointWhereInput,
    ) -> int:
        """Update multiple CommentCheckpoint records

        Parameters
        ----------
        data
            CommentCheckpoint data to update the selected CommentCheckpoint records to
        where
            Filter to select the CommentCheckpoint records to update

        Returns
        -------
        int
            The total number of CommentCheckpoint records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CommentCheckpoint records
        total = await CommentCheckpoint.prisma().update_many(
            data={
                'id': 536951780
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CommentCheckpoint records present in the database

        Parameters
        ----------
        select
            Select the CommentCheckpoint fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommentCheckpoint filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCheckpointCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommentCheckpoint.prisma().count()

        # results: prisma.types.CommentCheckpointCountAggregateOutput
        results = await CommentCheckpoint.prisma().count(
            select={
                '_all': True,
                'eventId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommentCheckpointCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
    ) -> types.CommentCheckpointCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommentCheckpointCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentCheckpointWhereInput] = None,
        cursor: Optional[types.CommentCheckpointWhereUniqueInput] = None,
    ) -> Union[int, types.CommentCheckpointCountAggregateOutput]:
        """Count the number of CommentCheckpoint records present in the database

        Parameters
        ----------
        select
            Select the CommentCheckpoint fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CommentCheckpoint filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCheckpointCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CommentCheckpoint.prisma().count()

        # results: prisma.types.CommentCheckpointCountAggregateOutput
        results = await CommentCheckpoint.prisma().count(
            select={
                '_all': True,
                'lastOffset': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommentCheckpointCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommentCheckpointWhereInput] = None
    ) -> int:
        """Delete multiple CommentCheckpoint records.

        Parameters
        ----------
        where
            Optional CommentCheckpoint filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CommentCheckpoint records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CommentCheckpoint records
        total = await CommentCheckpoint.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommentCheckpointScalarFieldKeys'],
        *,
        where: Optional['types.CommentCheckpointWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommentCheckpointAvgAggregateInput'] = None,
        sum: Optional['types.CommentCheckpointSumAggregateInput'] = None,
        min: Optional['types.CommentCheckpointMinAggregateInput'] = None,
        max: Optional['types.CommentCheckpointMaxAggregateInput'] = None,
        having: Optional['types.CommentCheckpointScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommentCheckpointCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommentCheckpointScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommentCheckpointScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommentCheckpointGroupByOutput']:
        """Group CommentCheckpoint records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CommentCheckpoint fields to group records by
        where
            CommentCheckpoint filter to select records
        take
            Limit the maximum number of CommentCheckpoint records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommentCheckpointGroupByOutput]
            A list of dictionaries representing the CommentCheckpoint record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CommentCheckpoint records by totalFetched values
        # and count how many records are in each group
        results = await CommentCheckpoint.prisma().group_by(
            ['totalFetched'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TokenPriceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TokenPrice]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TokenPrice.prisma().query_raw(
            'SELECT * FROM TokenPrice WHERE id = $1',
            924723277,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TokenPrice
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TokenPrice.prisma().query_first(
            'SELECT * FROM TokenPrice WHERE marketOutcomeId = $1',
            1621937922,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TokenPriceCreateInput,
        include: Optional[types.TokenPriceInclude] = None
    ) -> _PrismaModelT:
        """Create a new TokenPrice record.

        Parameters
        ----------
        data
            TokenPrice record data
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The created TokenPrice record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TokenPrice record from just the required fields
        tokenprice = await TokenPrice.prisma().create(
            data={
                # data to create a TokenPrice record
                'marketOutcomeId': 1848832019,
                'timestamp': datetime.datetime.utcnow(),
                'price': 1921528400.210042,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TokenPriceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TokenPrice records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TokenPrice record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TokenPrice.prisma().create_many(
            data=[
                {
                    # data to create a TokenPrice record
                    'marketOutcomeId': 849140046,
                    'timestamp': datetime.datetime.utcnow(),
                    'price': 928152175.27303,
                },
                {
                    # data to create a TokenPrice record
                    'marketOutcomeId': 982848517,
                    'timestamp': datetime.datetime.utcnow(),
                    'price': 510737498.211748,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TokenPriceWhereUniqueInput,
        include: Optional[types.TokenPriceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TokenPrice record.

        Parameters
        ----------
        where
            TokenPrice filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The deleted TokenPrice record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokenprice = await TokenPrice.prisma().delete(
            where={
                'id': 1401944936,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TokenPriceWhereUniqueInput,
        include: Optional[types.TokenPriceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TokenPrice record.

        Parameters
        ----------
        where
            TokenPrice filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The found TokenPrice record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokenprice = await TokenPrice.prisma().find_unique(
            where={
                'id': 1297607553,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TokenPriceWhereUniqueInput,
        include: Optional[types.TokenPriceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TokenPrice record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TokenPrice filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The found TokenPrice record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokenprice = await TokenPrice.prisma().find_unique_or_raise(
            where={
                'id': 519488550,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
        include: Optional[types.TokenPriceInclude] = None,
        order: Optional[Union[types.TokenPriceOrderByInput, List[types.TokenPriceOrderByInput]]] = None,
        distinct: Optional[List[types.TokenPriceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TokenPrice records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TokenPrice records returned
        skip
            Ignore the first N results
        where
            TokenPrice filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TokenPrice model
        order
            Order the returned TokenPrice records by any field
        distinct
            Filter TokenPrice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TokenPrice]
            The list of all TokenPrice records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TokenPrice records
        tokenprices = await TokenPrice.prisma().find_many(take=10)

        # find the first 5 TokenPrice records ordered by the timestamp field
        tokenprices = await TokenPrice.prisma().find_many(
            take=5,
            order={
                'timestamp': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
        include: Optional[types.TokenPriceInclude] = None,
        order: Optional[Union[types.TokenPriceOrderByInput, List[types.TokenPriceOrderByInput]]] = None,
        distinct: Optional[List[types.TokenPriceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TokenPrice record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TokenPrice filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TokenPrice model
        order
            Order the returned TokenPrice records by any field
        distinct
            Filter TokenPrice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TokenPrice
            The first TokenPrice record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TokenPrice record ordered by the price field
        tokenprice = await TokenPrice.prisma().find_first(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
        include: Optional[types.TokenPriceInclude] = None,
        order: Optional[Union[types.TokenPriceOrderByInput, List[types.TokenPriceOrderByInput]]] = None,
        distinct: Optional[List[types.TokenPriceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TokenPrice record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TokenPrice filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TokenPrice model
        order
            Order the returned TokenPrice records by any field
        distinct
            Filter TokenPrice records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TokenPrice
            The first TokenPrice record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TokenPrice record ordered by the id field
        tokenprice = await TokenPrice.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TokenPriceUpdateInput,
        where: types.TokenPriceWhereUniqueInput,
        include: Optional[types.TokenPriceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TokenPrice record.

        Parameters
        ----------
        data
            TokenPrice record data specifying what to update
        where
            TokenPrice filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The updated TokenPrice record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tokenprice = await TokenPrice.prisma().update(
            where={
                'id': 976832615,
            },
            data={
                # data to update the TokenPrice record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TokenPriceWhereUniqueInput,
        data: types.TokenPriceUpsertInput,
        include: Optional[types.TokenPriceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TokenPrice filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TokenPrice model

        Returns
        -------
        prisma.models.TokenPrice
            The created or updated TokenPrice record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tokenprice = await TokenPrice.prisma().upsert(
            where={
                'id': 1696425492,
            },
            data={
                'create': {
                    'id': 1696425492,
                    'marketOutcomeId': 982848517,
                    'timestamp': datetime.datetime.utcnow(),
                    'price': 510737498.211748,
                },
                'update': {
                    'marketOutcomeId': 982848517,
                    'timestamp': datetime.datetime.utcnow(),
                    'price': 510737498.211748,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TokenPriceUpdateManyMutationInput,
        where: types.TokenPriceWhereInput,
    ) -> int:
        """Update multiple TokenPrice records

        Parameters
        ----------
        data
            TokenPrice data to update the selected TokenPrice records to
        where
            Filter to select the TokenPrice records to update

        Returns
        -------
        int
            The total number of TokenPrice records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TokenPrice records
        total = await TokenPrice.prisma().update_many(
            data={
                'marketOutcomeId': 169262781
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TokenPrice records present in the database

        Parameters
        ----------
        select
            Select the TokenPrice fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TokenPrice filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TokenPriceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TokenPrice.prisma().count()

        # results: prisma.types.TokenPriceCountAggregateOutput
        results = await TokenPrice.prisma().count(
            select={
                '_all': True,
                'timestamp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TokenPriceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
    ) -> types.TokenPriceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TokenPriceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TokenPriceWhereInput] = None,
        cursor: Optional[types.TokenPriceWhereUniqueInput] = None,
    ) -> Union[int, types.TokenPriceCountAggregateOutput]:
        """Count the number of TokenPrice records present in the database

        Parameters
        ----------
        select
            Select the TokenPrice fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TokenPrice filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TokenPriceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TokenPrice.prisma().count()

        # results: prisma.types.TokenPriceCountAggregateOutput
        results = await TokenPrice.prisma().count(
            select={
                '_all': True,
                'price': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TokenPriceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TokenPriceWhereInput] = None
    ) -> int:
        """Delete multiple TokenPrice records.

        Parameters
        ----------
        where
            Optional TokenPrice filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TokenPrice records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TokenPrice records
        total = await TokenPrice.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TokenPriceScalarFieldKeys'],
        *,
        where: Optional['types.TokenPriceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TokenPriceAvgAggregateInput'] = None,
        sum: Optional['types.TokenPriceSumAggregateInput'] = None,
        min: Optional['types.TokenPriceMinAggregateInput'] = None,
        max: Optional['types.TokenPriceMaxAggregateInput'] = None,
        having: Optional['types.TokenPriceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TokenPriceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TokenPriceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TokenPriceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TokenPriceGroupByOutput']:
        """Group TokenPrice records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TokenPrice fields to group records by
        where
            TokenPrice filter to select records
        take
            Limit the maximum number of TokenPrice records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TokenPriceGroupByOutput]
            A list of dictionaries representing the TokenPrice record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TokenPrice records by id values
        # and count how many records are in each group
        results = await TokenPrice.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ScraperRunActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ScraperRun]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ScraperRun.prisma().query_raw(
            'SELECT * FROM ScraperRun WHERE id = $1',
            1023081650,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ScraperRun
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ScraperRun.prisma().query_first(
            'SELECT * FROM ScraperRun WHERE runType = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ScraperRunCreateInput,
        include: Optional[types.ScraperRunInclude] = None
    ) -> _PrismaModelT:
        """Create a new ScraperRun record.

        Parameters
        ----------
        data
            ScraperRun record data
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The created ScraperRun record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ScraperRun record from just the required fields
        scraperrun = await ScraperRun.prisma().create(
            data={
                # data to create a ScraperRun record
                'runType': 'fchheijjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ScraperRunCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ScraperRun records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ScraperRun record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ScraperRun.prisma().create_many(
            data=[
                {
                    # data to create a ScraperRun record
                    'runType': 'cacjdfhejh',
                },
                {
                    # data to create a ScraperRun record
                    'runType': 'bdbifjhbbi',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ScraperRunWhereUniqueInput,
        include: Optional[types.ScraperRunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ScraperRun record.

        Parameters
        ----------
        where
            ScraperRun filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The deleted ScraperRun record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scraperrun = await ScraperRun.prisma().delete(
            where={
                'id': 2122112351,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ScraperRunWhereUniqueInput,
        include: Optional[types.ScraperRunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ScraperRun record.

        Parameters
        ----------
        where
            ScraperRun filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The found ScraperRun record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scraperrun = await ScraperRun.prisma().find_unique(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ScraperRunWhereUniqueInput,
        include: Optional[types.ScraperRunInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ScraperRun record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ScraperRun filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The found ScraperRun record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scraperrun = await ScraperRun.prisma().find_unique_or_raise(
            where={
                'id': 1717307509,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
        include: Optional[types.ScraperRunInclude] = None,
        order: Optional[Union[types.ScraperRunOrderByInput, List[types.ScraperRunOrderByInput]]] = None,
        distinct: Optional[List[types.ScraperRunScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ScraperRun records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ScraperRun records returned
        skip
            Ignore the first N results
        where
            ScraperRun filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ScraperRun model
        order
            Order the returned ScraperRun records by any field
        distinct
            Filter ScraperRun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ScraperRun]
            The list of all ScraperRun records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ScraperRun records
        scraperruns = await ScraperRun.prisma().find_many(take=10)

        # find the first 5 ScraperRun records ordered by the status field
        scraperruns = await ScraperRun.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
        include: Optional[types.ScraperRunInclude] = None,
        order: Optional[Union[types.ScraperRunOrderByInput, List[types.ScraperRunOrderByInput]]] = None,
        distinct: Optional[List[types.ScraperRunScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ScraperRun record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ScraperRun filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ScraperRun model
        order
            Order the returned ScraperRun records by any field
        distinct
            Filter ScraperRun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ScraperRun
            The first ScraperRun record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ScraperRun record ordered by the marketsScraped field
        scraperrun = await ScraperRun.prisma().find_first(
            skip=1,
            order={
                'marketsScraped': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
        include: Optional[types.ScraperRunInclude] = None,
        order: Optional[Union[types.ScraperRunOrderByInput, List[types.ScraperRunOrderByInput]]] = None,
        distinct: Optional[List[types.ScraperRunScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ScraperRun record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ScraperRun filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ScraperRun model
        order
            Order the returned ScraperRun records by any field
        distinct
            Filter ScraperRun records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ScraperRun
            The first ScraperRun record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ScraperRun record ordered by the marketOutcomesScraped field
        scraperrun = await ScraperRun.prisma().find_first_or_raise(
            skip=1,
            order={
                'marketOutcomesScraped': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ScraperRunUpdateInput,
        where: types.ScraperRunWhereUniqueInput,
        include: Optional[types.ScraperRunInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ScraperRun record.

        Parameters
        ----------
        data
            ScraperRun record data specifying what to update
        where
            ScraperRun filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The updated ScraperRun record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        scraperrun = await ScraperRun.prisma().update(
            where={
                'id': 1598124042,
            },
            data={
                # data to update the ScraperRun record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ScraperRunWhereUniqueInput,
        data: types.ScraperRunUpsertInput,
        include: Optional[types.ScraperRunInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ScraperRun filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ScraperRun model

        Returns
        -------
        prisma.models.ScraperRun
            The created or updated ScraperRun record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        scraperrun = await ScraperRun.prisma().upsert(
            where={
                'id': 817623163,
            },
            data={
                'create': {
                    'id': 817623163,
                    'runType': 'bdbifjhbbi',
                },
                'update': {
                    'runType': 'bdbifjhbbi',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ScraperRunUpdateManyMutationInput,
        where: types.ScraperRunWhereInput,
    ) -> int:
        """Update multiple ScraperRun records

        Parameters
        ----------
        data
            ScraperRun data to update the selected ScraperRun records to
        where
            Filter to select the ScraperRun records to update

        Returns
        -------
        int
            The total number of ScraperRun records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ScraperRun records
        total = await ScraperRun.prisma().update_many(
            data={
                'commentsScraped': 1030557336
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ScraperRun records present in the database

        Parameters
        ----------
        select
            Select the ScraperRun fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ScraperRun filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScraperRunCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ScraperRun.prisma().count()

        # results: prisma.types.ScraperRunCountAggregateOutput
        results = await ScraperRun.prisma().count(
            select={
                '_all': True,
                'priceSnapshotsTaken': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ScraperRunCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
    ) -> types.ScraperRunCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ScraperRunCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScraperRunWhereInput] = None,
        cursor: Optional[types.ScraperRunWhereUniqueInput] = None,
    ) -> Union[int, types.ScraperRunCountAggregateOutput]:
        """Count the number of ScraperRun records present in the database

        Parameters
        ----------
        select
            Select the ScraperRun fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ScraperRun filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScraperRunCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ScraperRun.prisma().count()

        # results: prisma.types.ScraperRunCountAggregateOutput
        results = await ScraperRun.prisma().count(
            select={
                '_all': True,
                'tokensProcessed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ScraperRunCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ScraperRunWhereInput] = None
    ) -> int:
        """Delete multiple ScraperRun records.

        Parameters
        ----------
        where
            Optional ScraperRun filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ScraperRun records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ScraperRun records
        total = await ScraperRun.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ScraperRunScalarFieldKeys'],
        *,
        where: Optional['types.ScraperRunWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ScraperRunAvgAggregateInput'] = None,
        sum: Optional['types.ScraperRunSumAggregateInput'] = None,
        min: Optional['types.ScraperRunMinAggregateInput'] = None,
        max: Optional['types.ScraperRunMaxAggregateInput'] = None,
        having: Optional['types.ScraperRunScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ScraperRunCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ScraperRunScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ScraperRunScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ScraperRunGroupByOutput']:
        """Group ScraperRun records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ScraperRun fields to group records by
        where
            ScraperRun filter to select records
        take
            Limit the maximum number of ScraperRun records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ScraperRunGroupByOutput]
            A list of dictionaries representing the ScraperRun record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ScraperRun records by priceDataPointsStored values
        # and count how many records are in each group
        results = await ScraperRun.prisma().group_by(
            ['priceDataPointsStored'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models