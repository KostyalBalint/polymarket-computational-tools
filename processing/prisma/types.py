# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]


# Event types

class EventOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Event create method"""
    ticker: Optional[_str]
    slug: Optional[_str]
    title: Optional[_str]
    description: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[_str]
    creationDate: Optional[_str]
    endDate: Optional[_str]
    closedTime: Optional[datetime.datetime]
    eventDate: Optional[datetime.datetime]
    startTime: Optional[datetime.datetime]
    finishedTimestamp: Optional[datetime.datetime]
    image: Optional[_str]
    icon: Optional[_str]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    featured: Optional[_bool]
    restricted: Optional[_bool]
    isTemplate: Optional[_bool]
    commentsEnabled: Optional[_bool]
    enableOrderBook: Optional[_bool]
    automaticallyResolved: Optional[_bool]
    automaticallyActive: Optional[_bool]
    showAllOutcomes: Optional[_bool]
    showMarketImages: Optional[_bool]
    enableNegRisk: Optional[_bool]
    live: Optional[_bool]
    ended: Optional[_bool]
    pendingDeployment: Optional[_bool]
    deploying: Optional[_bool]
    estimateValue: Optional[_bool]
    cantEstimate: Optional[_bool]
    liquidity: Optional[_float]
    volume: Optional[_float]
    openInterest: Optional[_float]
    volume24hr: Optional[_float]
    volume1wk: Optional[_float]
    volume1mo: Optional[_float]
    volume1yr: Optional[_float]
    liquidityAmm: Optional[_float]
    liquidityClob: Optional[_float]
    competitive: Optional[_float]
    category: Optional[_str]
    sortBy: Optional[_str]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_str]
    updatedBy: Optional[_str]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    parentEvent: Optional[_str]
    seriesSlug: Optional[_str]
    disqusThread: Optional[_str]
    commentCount: Optional[_int]
    tweetCount: Optional[_int]
    featuredOrder: Optional[_int]
    eventWeek: Optional[_int]
    templateVariables: Optional[_str]
    score: Optional[_str]
    elapsed: Optional[_str]
    period: Optional[_str]
    gmpChartMode: Optional[_str]
    estimatedValue: Optional[_str]
    spreadsMainLine: Optional[_float]
    totalsMainLine: Optional[_float]
    carouselMap: Optional[_str]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameStatus: Optional[_str]
    negRisk: Optional[_bool]
    negRiskMarketID: Optional[_str]
    negRiskFeeBips: Optional[_float]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    markets: 'MarketCreateManyNestedWithoutRelationsInput'
    tags: 'TagCreateManyNestedWithoutRelationsInput'
    Comment: 'CommentCreateManyNestedWithoutRelationsInput'
    CommentCheckpoint: 'CommentCheckpointCreateManyNestedWithoutRelationsInput'


class EventCreateInput(EventOptionalCreateInput):
    """Required arguments to the Event create method"""
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class EventOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Event create method, without relations"""
    ticker: Optional[_str]
    slug: Optional[_str]
    title: Optional[_str]
    description: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[_str]
    creationDate: Optional[_str]
    endDate: Optional[_str]
    closedTime: Optional[datetime.datetime]
    eventDate: Optional[datetime.datetime]
    startTime: Optional[datetime.datetime]
    finishedTimestamp: Optional[datetime.datetime]
    image: Optional[_str]
    icon: Optional[_str]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    featured: Optional[_bool]
    restricted: Optional[_bool]
    isTemplate: Optional[_bool]
    commentsEnabled: Optional[_bool]
    enableOrderBook: Optional[_bool]
    automaticallyResolved: Optional[_bool]
    automaticallyActive: Optional[_bool]
    showAllOutcomes: Optional[_bool]
    showMarketImages: Optional[_bool]
    enableNegRisk: Optional[_bool]
    live: Optional[_bool]
    ended: Optional[_bool]
    pendingDeployment: Optional[_bool]
    deploying: Optional[_bool]
    estimateValue: Optional[_bool]
    cantEstimate: Optional[_bool]
    liquidity: Optional[_float]
    volume: Optional[_float]
    openInterest: Optional[_float]
    volume24hr: Optional[_float]
    volume1wk: Optional[_float]
    volume1mo: Optional[_float]
    volume1yr: Optional[_float]
    liquidityAmm: Optional[_float]
    liquidityClob: Optional[_float]
    competitive: Optional[_float]
    category: Optional[_str]
    sortBy: Optional[_str]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_str]
    updatedBy: Optional[_str]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    parentEvent: Optional[_str]
    seriesSlug: Optional[_str]
    disqusThread: Optional[_str]
    commentCount: Optional[_int]
    tweetCount: Optional[_int]
    featuredOrder: Optional[_int]
    eventWeek: Optional[_int]
    templateVariables: Optional[_str]
    score: Optional[_str]
    elapsed: Optional[_str]
    period: Optional[_str]
    gmpChartMode: Optional[_str]
    estimatedValue: Optional[_str]
    spreadsMainLine: Optional[_float]
    totalsMainLine: Optional[_float]
    carouselMap: Optional[_str]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameStatus: Optional[_str]
    negRisk: Optional[_bool]
    negRiskMarketID: Optional[_str]
    negRiskFeeBips: Optional[_float]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class EventCreateWithoutRelationsInput(EventOptionalCreateWithoutRelationsInput):
    """Required arguments to the Event create method, without relations"""
    id: _str

class EventConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'EventCreateWithoutRelationsInput'
    where: 'EventWhereUniqueInput'

class EventCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'EventCreateWithoutRelationsInput'
    connect: 'EventWhereUniqueInput'
    connect_or_create: 'EventConnectOrCreateWithoutRelationsInput'


class EventCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['EventCreateWithoutRelationsInput', List['EventCreateWithoutRelationsInput']]
    connect: Union['EventWhereUniqueInput', List['EventWhereUniqueInput']]
    connect_or_create: Union['EventConnectOrCreateWithoutRelationsInput', List['EventConnectOrCreateWithoutRelationsInput']]

_EventWhereUnique_id_Input = TypedDict(
    '_EventWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_EventWhereUnique_slug_Input = TypedDict(
    '_EventWhereUnique_slug_Input',
    {
        'slug': '_str',
    },
    total=True
)

EventWhereUniqueInput = Union[
    '_EventWhereUnique_id_Input',
    '_EventWhereUnique_slug_Input',
]


class EventUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    ticker: Optional[_str]
    slug: Optional[_str]
    title: Optional[_str]
    description: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[_str]
    creationDate: Optional[_str]
    endDate: Optional[_str]
    closedTime: Optional[datetime.datetime]
    eventDate: Optional[datetime.datetime]
    startTime: Optional[datetime.datetime]
    finishedTimestamp: Optional[datetime.datetime]
    image: Optional[_str]
    icon: Optional[_str]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    featured: Optional[_bool]
    restricted: Optional[_bool]
    isTemplate: Optional[_bool]
    commentsEnabled: Optional[_bool]
    enableOrderBook: Optional[_bool]
    automaticallyResolved: Optional[_bool]
    automaticallyActive: Optional[_bool]
    showAllOutcomes: Optional[_bool]
    showMarketImages: Optional[_bool]
    enableNegRisk: Optional[_bool]
    live: Optional[_bool]
    ended: Optional[_bool]
    pendingDeployment: Optional[_bool]
    deploying: Optional[_bool]
    estimateValue: Optional[_bool]
    cantEstimate: Optional[_bool]
    liquidity: Optional[Union[AtomicFloatInput, _float]]
    volume: Optional[Union[AtomicFloatInput, _float]]
    openInterest: Optional[Union[AtomicFloatInput, _float]]
    volume24hr: Optional[Union[AtomicFloatInput, _float]]
    volume1wk: Optional[Union[AtomicFloatInput, _float]]
    volume1mo: Optional[Union[AtomicFloatInput, _float]]
    volume1yr: Optional[Union[AtomicFloatInput, _float]]
    liquidityAmm: Optional[Union[AtomicFloatInput, _float]]
    liquidityClob: Optional[Union[AtomicFloatInput, _float]]
    competitive: Optional[Union[AtomicFloatInput, _float]]
    category: Optional[_str]
    sortBy: Optional[_str]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_str]
    updatedBy: Optional[_str]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    parentEvent: Optional[_str]
    seriesSlug: Optional[_str]
    disqusThread: Optional[_str]
    commentCount: Optional[Union[AtomicIntInput, _int]]
    tweetCount: Optional[Union[AtomicIntInput, _int]]
    featuredOrder: Optional[Union[AtomicIntInput, _int]]
    eventWeek: Optional[Union[AtomicIntInput, _int]]
    templateVariables: Optional[_str]
    score: Optional[_str]
    elapsed: Optional[_str]
    period: Optional[_str]
    gmpChartMode: Optional[_str]
    estimatedValue: Optional[_str]
    spreadsMainLine: Optional[Union[AtomicFloatInput, _float]]
    totalsMainLine: Optional[Union[AtomicFloatInput, _float]]
    carouselMap: Optional[_str]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameStatus: Optional[_str]
    negRisk: Optional[_bool]
    negRiskMarketID: Optional[_str]
    negRiskFeeBips: Optional[Union[AtomicFloatInput, _float]]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    markets: 'MarketUpdateManyWithoutRelationsInput'
    tags: 'TagUpdateManyWithoutRelationsInput'
    Comment: 'CommentUpdateManyWithoutRelationsInput'
    CommentCheckpoint: 'CommentCheckpointUpdateManyWithoutRelationsInput'


class EventUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    ticker: Optional[_str]
    slug: Optional[_str]
    title: Optional[_str]
    description: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[_str]
    creationDate: Optional[_str]
    endDate: Optional[_str]
    closedTime: Optional[datetime.datetime]
    eventDate: Optional[datetime.datetime]
    startTime: Optional[datetime.datetime]
    finishedTimestamp: Optional[datetime.datetime]
    image: Optional[_str]
    icon: Optional[_str]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    featured: Optional[_bool]
    restricted: Optional[_bool]
    isTemplate: Optional[_bool]
    commentsEnabled: Optional[_bool]
    enableOrderBook: Optional[_bool]
    automaticallyResolved: Optional[_bool]
    automaticallyActive: Optional[_bool]
    showAllOutcomes: Optional[_bool]
    showMarketImages: Optional[_bool]
    enableNegRisk: Optional[_bool]
    live: Optional[_bool]
    ended: Optional[_bool]
    pendingDeployment: Optional[_bool]
    deploying: Optional[_bool]
    estimateValue: Optional[_bool]
    cantEstimate: Optional[_bool]
    liquidity: Optional[Union[AtomicFloatInput, _float]]
    volume: Optional[Union[AtomicFloatInput, _float]]
    openInterest: Optional[Union[AtomicFloatInput, _float]]
    volume24hr: Optional[Union[AtomicFloatInput, _float]]
    volume1wk: Optional[Union[AtomicFloatInput, _float]]
    volume1mo: Optional[Union[AtomicFloatInput, _float]]
    volume1yr: Optional[Union[AtomicFloatInput, _float]]
    liquidityAmm: Optional[Union[AtomicFloatInput, _float]]
    liquidityClob: Optional[Union[AtomicFloatInput, _float]]
    competitive: Optional[Union[AtomicFloatInput, _float]]
    category: Optional[_str]
    sortBy: Optional[_str]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_str]
    updatedBy: Optional[_str]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    parentEvent: Optional[_str]
    seriesSlug: Optional[_str]
    disqusThread: Optional[_str]
    commentCount: Optional[Union[AtomicIntInput, _int]]
    tweetCount: Optional[Union[AtomicIntInput, _int]]
    featuredOrder: Optional[Union[AtomicIntInput, _int]]
    eventWeek: Optional[Union[AtomicIntInput, _int]]
    templateVariables: Optional[_str]
    score: Optional[_str]
    elapsed: Optional[_str]
    period: Optional[_str]
    gmpChartMode: Optional[_str]
    estimatedValue: Optional[_str]
    spreadsMainLine: Optional[Union[AtomicFloatInput, _float]]
    totalsMainLine: Optional[Union[AtomicFloatInput, _float]]
    carouselMap: Optional[_str]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameStatus: Optional[_str]
    negRisk: Optional[_bool]
    negRiskMarketID: Optional[_str]
    negRiskFeeBips: Optional[Union[AtomicFloatInput, _float]]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class EventUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['EventCreateWithoutRelationsInput']
    connect: List['EventWhereUniqueInput']
    connect_or_create: List['EventConnectOrCreateWithoutRelationsInput']
    set: List['EventWhereUniqueInput']
    disconnect: List['EventWhereUniqueInput']
    delete: List['EventWhereUniqueInput']

    # TODO
    # update: List['EventUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['EventUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['EventScalarWhereInput']
    # upsert: List['EventUpserteWithWhereUniqueWithoutRelationsInput']


class EventUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'EventCreateWithoutRelationsInput'
    connect: 'EventWhereUniqueInput'
    connect_or_create: 'EventConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'EventUpdateInput'
    # upsert: 'EventUpsertWithoutRelationsInput'


class EventUpsertInput(TypedDict):
    create: 'EventCreateInput'
    update: 'EventUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Event_id_OrderByInput = TypedDict(
    '_Event_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Event_ticker_OrderByInput = TypedDict(
    '_Event_ticker_OrderByInput',
    {
        'ticker': 'SortOrder',
    },
    total=True
)

_Event_slug_OrderByInput = TypedDict(
    '_Event_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Event_title_OrderByInput = TypedDict(
    '_Event_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Event_description_OrderByInput = TypedDict(
    '_Event_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Event_resolutionSource_OrderByInput = TypedDict(
    '_Event_resolutionSource_OrderByInput',
    {
        'resolutionSource': 'SortOrder',
    },
    total=True
)

_Event_startDate_OrderByInput = TypedDict(
    '_Event_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Event_creationDate_OrderByInput = TypedDict(
    '_Event_creationDate_OrderByInput',
    {
        'creationDate': 'SortOrder',
    },
    total=True
)

_Event_endDate_OrderByInput = TypedDict(
    '_Event_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_Event_closedTime_OrderByInput = TypedDict(
    '_Event_closedTime_OrderByInput',
    {
        'closedTime': 'SortOrder',
    },
    total=True
)

_Event_eventDate_OrderByInput = TypedDict(
    '_Event_eventDate_OrderByInput',
    {
        'eventDate': 'SortOrder',
    },
    total=True
)

_Event_startTime_OrderByInput = TypedDict(
    '_Event_startTime_OrderByInput',
    {
        'startTime': 'SortOrder',
    },
    total=True
)

_Event_finishedTimestamp_OrderByInput = TypedDict(
    '_Event_finishedTimestamp_OrderByInput',
    {
        'finishedTimestamp': 'SortOrder',
    },
    total=True
)

_Event_image_OrderByInput = TypedDict(
    '_Event_image_OrderByInput',
    {
        'image': 'SortOrder',
    },
    total=True
)

_Event_icon_OrderByInput = TypedDict(
    '_Event_icon_OrderByInput',
    {
        'icon': 'SortOrder',
    },
    total=True
)

_Event_active_OrderByInput = TypedDict(
    '_Event_active_OrderByInput',
    {
        'active': 'SortOrder',
    },
    total=True
)

_Event_closed_OrderByInput = TypedDict(
    '_Event_closed_OrderByInput',
    {
        'closed': 'SortOrder',
    },
    total=True
)

_Event_archived_OrderByInput = TypedDict(
    '_Event_archived_OrderByInput',
    {
        'archived': 'SortOrder',
    },
    total=True
)

_Event_new_OrderByInput = TypedDict(
    '_Event_new_OrderByInput',
    {
        'new': 'SortOrder',
    },
    total=True
)

_Event_featured_OrderByInput = TypedDict(
    '_Event_featured_OrderByInput',
    {
        'featured': 'SortOrder',
    },
    total=True
)

_Event_restricted_OrderByInput = TypedDict(
    '_Event_restricted_OrderByInput',
    {
        'restricted': 'SortOrder',
    },
    total=True
)

_Event_isTemplate_OrderByInput = TypedDict(
    '_Event_isTemplate_OrderByInput',
    {
        'isTemplate': 'SortOrder',
    },
    total=True
)

_Event_commentsEnabled_OrderByInput = TypedDict(
    '_Event_commentsEnabled_OrderByInput',
    {
        'commentsEnabled': 'SortOrder',
    },
    total=True
)

_Event_enableOrderBook_OrderByInput = TypedDict(
    '_Event_enableOrderBook_OrderByInput',
    {
        'enableOrderBook': 'SortOrder',
    },
    total=True
)

_Event_automaticallyResolved_OrderByInput = TypedDict(
    '_Event_automaticallyResolved_OrderByInput',
    {
        'automaticallyResolved': 'SortOrder',
    },
    total=True
)

_Event_automaticallyActive_OrderByInput = TypedDict(
    '_Event_automaticallyActive_OrderByInput',
    {
        'automaticallyActive': 'SortOrder',
    },
    total=True
)

_Event_showAllOutcomes_OrderByInput = TypedDict(
    '_Event_showAllOutcomes_OrderByInput',
    {
        'showAllOutcomes': 'SortOrder',
    },
    total=True
)

_Event_showMarketImages_OrderByInput = TypedDict(
    '_Event_showMarketImages_OrderByInput',
    {
        'showMarketImages': 'SortOrder',
    },
    total=True
)

_Event_enableNegRisk_OrderByInput = TypedDict(
    '_Event_enableNegRisk_OrderByInput',
    {
        'enableNegRisk': 'SortOrder',
    },
    total=True
)

_Event_live_OrderByInput = TypedDict(
    '_Event_live_OrderByInput',
    {
        'live': 'SortOrder',
    },
    total=True
)

_Event_ended_OrderByInput = TypedDict(
    '_Event_ended_OrderByInput',
    {
        'ended': 'SortOrder',
    },
    total=True
)

_Event_pendingDeployment_OrderByInput = TypedDict(
    '_Event_pendingDeployment_OrderByInput',
    {
        'pendingDeployment': 'SortOrder',
    },
    total=True
)

_Event_deploying_OrderByInput = TypedDict(
    '_Event_deploying_OrderByInput',
    {
        'deploying': 'SortOrder',
    },
    total=True
)

_Event_estimateValue_OrderByInput = TypedDict(
    '_Event_estimateValue_OrderByInput',
    {
        'estimateValue': 'SortOrder',
    },
    total=True
)

_Event_cantEstimate_OrderByInput = TypedDict(
    '_Event_cantEstimate_OrderByInput',
    {
        'cantEstimate': 'SortOrder',
    },
    total=True
)

_Event_liquidity_OrderByInput = TypedDict(
    '_Event_liquidity_OrderByInput',
    {
        'liquidity': 'SortOrder',
    },
    total=True
)

_Event_volume_OrderByInput = TypedDict(
    '_Event_volume_OrderByInput',
    {
        'volume': 'SortOrder',
    },
    total=True
)

_Event_openInterest_OrderByInput = TypedDict(
    '_Event_openInterest_OrderByInput',
    {
        'openInterest': 'SortOrder',
    },
    total=True
)

_Event_volume24hr_OrderByInput = TypedDict(
    '_Event_volume24hr_OrderByInput',
    {
        'volume24hr': 'SortOrder',
    },
    total=True
)

_Event_volume1wk_OrderByInput = TypedDict(
    '_Event_volume1wk_OrderByInput',
    {
        'volume1wk': 'SortOrder',
    },
    total=True
)

_Event_volume1mo_OrderByInput = TypedDict(
    '_Event_volume1mo_OrderByInput',
    {
        'volume1mo': 'SortOrder',
    },
    total=True
)

_Event_volume1yr_OrderByInput = TypedDict(
    '_Event_volume1yr_OrderByInput',
    {
        'volume1yr': 'SortOrder',
    },
    total=True
)

_Event_liquidityAmm_OrderByInput = TypedDict(
    '_Event_liquidityAmm_OrderByInput',
    {
        'liquidityAmm': 'SortOrder',
    },
    total=True
)

_Event_liquidityClob_OrderByInput = TypedDict(
    '_Event_liquidityClob_OrderByInput',
    {
        'liquidityClob': 'SortOrder',
    },
    total=True
)

_Event_competitive_OrderByInput = TypedDict(
    '_Event_competitive_OrderByInput',
    {
        'competitive': 'SortOrder',
    },
    total=True
)

_Event_category_OrderByInput = TypedDict(
    '_Event_category_OrderByInput',
    {
        'category': 'SortOrder',
    },
    total=True
)

_Event_sortBy_OrderByInput = TypedDict(
    '_Event_sortBy_OrderByInput',
    {
        'sortBy': 'SortOrder',
    },
    total=True
)

_Event_publishedAt_OrderByInput = TypedDict(
    '_Event_publishedAt_OrderByInput',
    {
        'publishedAt': 'SortOrder',
    },
    total=True
)

_Event_createdBy_OrderByInput = TypedDict(
    '_Event_createdBy_OrderByInput',
    {
        'createdBy': 'SortOrder',
    },
    total=True
)

_Event_updatedBy_OrderByInput = TypedDict(
    '_Event_updatedBy_OrderByInput',
    {
        'updatedBy': 'SortOrder',
    },
    total=True
)

_Event_createdAt_OrderByInput = TypedDict(
    '_Event_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Event_updatedAt_OrderByInput = TypedDict(
    '_Event_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Event_parentEvent_OrderByInput = TypedDict(
    '_Event_parentEvent_OrderByInput',
    {
        'parentEvent': 'SortOrder',
    },
    total=True
)

_Event_seriesSlug_OrderByInput = TypedDict(
    '_Event_seriesSlug_OrderByInput',
    {
        'seriesSlug': 'SortOrder',
    },
    total=True
)

_Event_disqusThread_OrderByInput = TypedDict(
    '_Event_disqusThread_OrderByInput',
    {
        'disqusThread': 'SortOrder',
    },
    total=True
)

_Event_commentCount_OrderByInput = TypedDict(
    '_Event_commentCount_OrderByInput',
    {
        'commentCount': 'SortOrder',
    },
    total=True
)

_Event_tweetCount_OrderByInput = TypedDict(
    '_Event_tweetCount_OrderByInput',
    {
        'tweetCount': 'SortOrder',
    },
    total=True
)

_Event_featuredOrder_OrderByInput = TypedDict(
    '_Event_featuredOrder_OrderByInput',
    {
        'featuredOrder': 'SortOrder',
    },
    total=True
)

_Event_eventWeek_OrderByInput = TypedDict(
    '_Event_eventWeek_OrderByInput',
    {
        'eventWeek': 'SortOrder',
    },
    total=True
)

_Event_templateVariables_OrderByInput = TypedDict(
    '_Event_templateVariables_OrderByInput',
    {
        'templateVariables': 'SortOrder',
    },
    total=True
)

_Event_score_OrderByInput = TypedDict(
    '_Event_score_OrderByInput',
    {
        'score': 'SortOrder',
    },
    total=True
)

_Event_elapsed_OrderByInput = TypedDict(
    '_Event_elapsed_OrderByInput',
    {
        'elapsed': 'SortOrder',
    },
    total=True
)

_Event_period_OrderByInput = TypedDict(
    '_Event_period_OrderByInput',
    {
        'period': 'SortOrder',
    },
    total=True
)

_Event_gmpChartMode_OrderByInput = TypedDict(
    '_Event_gmpChartMode_OrderByInput',
    {
        'gmpChartMode': 'SortOrder',
    },
    total=True
)

_Event_estimatedValue_OrderByInput = TypedDict(
    '_Event_estimatedValue_OrderByInput',
    {
        'estimatedValue': 'SortOrder',
    },
    total=True
)

_Event_spreadsMainLine_OrderByInput = TypedDict(
    '_Event_spreadsMainLine_OrderByInput',
    {
        'spreadsMainLine': 'SortOrder',
    },
    total=True
)

_Event_totalsMainLine_OrderByInput = TypedDict(
    '_Event_totalsMainLine_OrderByInput',
    {
        'totalsMainLine': 'SortOrder',
    },
    total=True
)

_Event_carouselMap_OrderByInput = TypedDict(
    '_Event_carouselMap_OrderByInput',
    {
        'carouselMap': 'SortOrder',
    },
    total=True
)

_Event_deployingTimestamp_OrderByInput = TypedDict(
    '_Event_deployingTimestamp_OrderByInput',
    {
        'deployingTimestamp': 'SortOrder',
    },
    total=True
)

_Event_scheduledDeploymentTimestamp_OrderByInput = TypedDict(
    '_Event_scheduledDeploymentTimestamp_OrderByInput',
    {
        'scheduledDeploymentTimestamp': 'SortOrder',
    },
    total=True
)

_Event_gameStatus_OrderByInput = TypedDict(
    '_Event_gameStatus_OrderByInput',
    {
        'gameStatus': 'SortOrder',
    },
    total=True
)

_Event_negRisk_OrderByInput = TypedDict(
    '_Event_negRisk_OrderByInput',
    {
        'negRisk': 'SortOrder',
    },
    total=True
)

_Event_negRiskMarketID_OrderByInput = TypedDict(
    '_Event_negRiskMarketID_OrderByInput',
    {
        'negRiskMarketID': 'SortOrder',
    },
    total=True
)

_Event_negRiskFeeBips_OrderByInput = TypedDict(
    '_Event_negRiskFeeBips_OrderByInput',
    {
        'negRiskFeeBips': 'SortOrder',
    },
    total=True
)

_Event_scrapedAt_OrderByInput = TypedDict(
    '_Event_scrapedAt_OrderByInput',
    {
        'scrapedAt': 'SortOrder',
    },
    total=True
)

_Event_createdInDb_OrderByInput = TypedDict(
    '_Event_createdInDb_OrderByInput',
    {
        'createdInDb': 'SortOrder',
    },
    total=True
)

_Event_RelevanceInner = TypedDict(
    '_Event_RelevanceInner',
    {
        'fields': 'List[EventScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Event_RelevanceOrderByInput = TypedDict(
    '_Event_RelevanceOrderByInput',
    {
        '_relevance': '_Event_RelevanceInner',
    },
    total=True
)

EventOrderByInput = Union[
    '_Event_id_OrderByInput',
    '_Event_ticker_OrderByInput',
    '_Event_slug_OrderByInput',
    '_Event_title_OrderByInput',
    '_Event_description_OrderByInput',
    '_Event_resolutionSource_OrderByInput',
    '_Event_startDate_OrderByInput',
    '_Event_creationDate_OrderByInput',
    '_Event_endDate_OrderByInput',
    '_Event_closedTime_OrderByInput',
    '_Event_eventDate_OrderByInput',
    '_Event_startTime_OrderByInput',
    '_Event_finishedTimestamp_OrderByInput',
    '_Event_image_OrderByInput',
    '_Event_icon_OrderByInput',
    '_Event_active_OrderByInput',
    '_Event_closed_OrderByInput',
    '_Event_archived_OrderByInput',
    '_Event_new_OrderByInput',
    '_Event_featured_OrderByInput',
    '_Event_restricted_OrderByInput',
    '_Event_isTemplate_OrderByInput',
    '_Event_commentsEnabled_OrderByInput',
    '_Event_enableOrderBook_OrderByInput',
    '_Event_automaticallyResolved_OrderByInput',
    '_Event_automaticallyActive_OrderByInput',
    '_Event_showAllOutcomes_OrderByInput',
    '_Event_showMarketImages_OrderByInput',
    '_Event_enableNegRisk_OrderByInput',
    '_Event_live_OrderByInput',
    '_Event_ended_OrderByInput',
    '_Event_pendingDeployment_OrderByInput',
    '_Event_deploying_OrderByInput',
    '_Event_estimateValue_OrderByInput',
    '_Event_cantEstimate_OrderByInput',
    '_Event_liquidity_OrderByInput',
    '_Event_volume_OrderByInput',
    '_Event_openInterest_OrderByInput',
    '_Event_volume24hr_OrderByInput',
    '_Event_volume1wk_OrderByInput',
    '_Event_volume1mo_OrderByInput',
    '_Event_volume1yr_OrderByInput',
    '_Event_liquidityAmm_OrderByInput',
    '_Event_liquidityClob_OrderByInput',
    '_Event_competitive_OrderByInput',
    '_Event_category_OrderByInput',
    '_Event_sortBy_OrderByInput',
    '_Event_publishedAt_OrderByInput',
    '_Event_createdBy_OrderByInput',
    '_Event_updatedBy_OrderByInput',
    '_Event_createdAt_OrderByInput',
    '_Event_updatedAt_OrderByInput',
    '_Event_parentEvent_OrderByInput',
    '_Event_seriesSlug_OrderByInput',
    '_Event_disqusThread_OrderByInput',
    '_Event_commentCount_OrderByInput',
    '_Event_tweetCount_OrderByInput',
    '_Event_featuredOrder_OrderByInput',
    '_Event_eventWeek_OrderByInput',
    '_Event_templateVariables_OrderByInput',
    '_Event_score_OrderByInput',
    '_Event_elapsed_OrderByInput',
    '_Event_period_OrderByInput',
    '_Event_gmpChartMode_OrderByInput',
    '_Event_estimatedValue_OrderByInput',
    '_Event_spreadsMainLine_OrderByInput',
    '_Event_totalsMainLine_OrderByInput',
    '_Event_carouselMap_OrderByInput',
    '_Event_deployingTimestamp_OrderByInput',
    '_Event_scheduledDeploymentTimestamp_OrderByInput',
    '_Event_gameStatus_OrderByInput',
    '_Event_negRisk_OrderByInput',
    '_Event_negRiskMarketID_OrderByInput',
    '_Event_negRiskFeeBips_OrderByInput',
    '_Event_scrapedAt_OrderByInput',
    '_Event_createdInDb_OrderByInput',
    '_Event_RelevanceOrderByInput',
]



# recursive Event types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

EventRelationFilter = TypedDict(
    'EventRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class EventListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class EventInclude(TypedDict, total=False):
    """Event relational arguments"""
    markets: Union[bool, 'FindManyMarketArgsFromEvent']
    tags: Union[bool, 'FindManyTagArgsFromEvent']
    Comment: Union[bool, 'FindManyCommentArgsFromEvent']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromEvent']


    

class EventIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromEventRecursive1']


class EventIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromEventRecursive2']


class EventIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromEventRecursive3']


class EventIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromEventRecursive4']


class EventIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class EventArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyEventArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    events: Union[bool, 'FindManyEventArgsFromEventRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromEventRecursive1']


class MarketIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    events: Union[bool, 'FindManyEventArgsFromEventRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromEventRecursive2']


class MarketIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    events: Union[bool, 'FindManyEventArgsFromEventRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromEventRecursive3']


class MarketIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    events: Union[bool, 'FindManyEventArgsFromEventRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromEventRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromEventRecursive4']


class MarketIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class MarketArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyMarketArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    market: Union[bool, 'MarketArgsFromEventRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromEventRecursive1']


class MarketOutcomeIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    market: Union[bool, 'MarketArgsFromEventRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromEventRecursive2']


class MarketOutcomeIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    market: Union[bool, 'MarketArgsFromEventRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromEventRecursive3']


class MarketOutcomeIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    market: Union[bool, 'MarketArgsFromEventRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromEventRecursive4']


class MarketOutcomeIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class MarketOutcomeArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyMarketOutcomeArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromEventRecursive1']


class TagIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromEventRecursive2']


class TagIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromEventRecursive3']


class TagIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    markets: Union[bool, 'FindManyMarketArgsFromEventRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromEventRecursive4']


class TagIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class TagArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyTagArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    profile: Union[bool, 'UserProfileArgsFromEventRecursive1']
    event: Union[bool, 'EventArgsFromEventRecursive1']
    parentComment: Union[bool, 'CommentArgsFromEventRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromEventRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromEventRecursive1']


class CommentIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    profile: Union[bool, 'UserProfileArgsFromEventRecursive2']
    event: Union[bool, 'EventArgsFromEventRecursive2']
    parentComment: Union[bool, 'CommentArgsFromEventRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromEventRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromEventRecursive2']


class CommentIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    profile: Union[bool, 'UserProfileArgsFromEventRecursive3']
    event: Union[bool, 'EventArgsFromEventRecursive3']
    parentComment: Union[bool, 'CommentArgsFromEventRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromEventRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromEventRecursive3']


class CommentIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    profile: Union[bool, 'UserProfileArgsFromEventRecursive4']
    event: Union[bool, 'EventArgsFromEventRecursive4']
    parentComment: Union[bool, 'CommentArgsFromEventRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromEventRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromEventRecursive4']


class CommentIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class CommentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyCommentArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    comment: Union[bool, 'CommentArgsFromEventRecursive1']


class CommentReactionIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    comment: Union[bool, 'CommentArgsFromEventRecursive2']


class CommentReactionIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    comment: Union[bool, 'CommentArgsFromEventRecursive3']


class CommentReactionIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    comment: Union[bool, 'CommentArgsFromEventRecursive4']


class CommentReactionIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class CommentReactionArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyCommentReactionArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive1']


class UserProfileIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive2']


class UserProfileIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive3']


class UserProfileIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    Comment: Union[bool, 'FindManyCommentArgsFromEventRecursive4']


class UserProfileIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class UserProfileArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyUserProfileArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    event: Union[bool, 'EventArgsFromEventRecursive1']


class CommentCheckpointIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    event: Union[bool, 'EventArgsFromEventRecursive2']


class CommentCheckpointIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    event: Union[bool, 'EventArgsFromEventRecursive3']


class CommentCheckpointIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    event: Union[bool, 'EventArgsFromEventRecursive4']


class CommentCheckpointIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class CommentCheckpointArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyCommentCheckpointArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromEventRecursive1']


class TokenPriceIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromEventRecursive2']


class TokenPriceIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromEventRecursive3']


class TokenPriceIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromEventRecursive4']


class TokenPriceIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class TokenPriceArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyTokenPriceArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromEvent(TypedDict, total=False):
    """Relational arguments for Event"""


class ScraperRunIncludeFromEventRecursive1(TypedDict, total=False):
    """Relational arguments for Event"""


class ScraperRunIncludeFromEventRecursive2(TypedDict, total=False):
    """Relational arguments for Event"""


class ScraperRunIncludeFromEventRecursive3(TypedDict, total=False):
    """Relational arguments for Event"""


class ScraperRunIncludeFromEventRecursive4(TypedDict, total=False):
    """Relational arguments for Event"""

    

class ScraperRunArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    
    

class FindManyScraperRunArgsFromEvent(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromEventRecursive1(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromEventRecursive2(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromEventRecursive3(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromEventRecursive4(TypedDict, total=False):
    """Arguments for Event"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyEventArgs = FindManyEventArgsFromEvent
FindFirstEventArgs = FindManyEventArgsFromEvent


    

class EventWhereInput(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ticker: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    title: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, _str, 'types.StringFilter']
    creationDate: Union[None, _str, 'types.StringFilter']
    endDate: Union[None, _str, 'types.StringFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    eventDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    featured: Union[None, _bool, 'types.BooleanFilter']
    restricted: Union[None, _bool, 'types.BooleanFilter']
    isTemplate: Union[None, _bool, 'types.BooleanFilter']
    commentsEnabled: Union[None, _bool, 'types.BooleanFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    automaticallyResolved: Union[None, _bool, 'types.BooleanFilter']
    automaticallyActive: Union[None, _bool, 'types.BooleanFilter']
    showAllOutcomes: Union[None, _bool, 'types.BooleanFilter']
    showMarketImages: Union[None, _bool, 'types.BooleanFilter']
    enableNegRisk: Union[None, _bool, 'types.BooleanFilter']
    live: Union[None, _bool, 'types.BooleanFilter']
    ended: Union[None, _bool, 'types.BooleanFilter']
    pendingDeployment: Union[None, _bool, 'types.BooleanFilter']
    deploying: Union[None, _bool, 'types.BooleanFilter']
    estimateValue: Union[None, _bool, 'types.BooleanFilter']
    cantEstimate: Union[None, _bool, 'types.BooleanFilter']
    liquidity: Union[None, _float, 'types.FloatFilter']
    volume: Union[None, _float, 'types.FloatFilter']
    openInterest: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    competitive: Union[None, _float, 'types.FloatFilter']
    category: Union[None, _str, 'types.StringFilter']
    sortBy: Union[None, _str, 'types.StringFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _str, 'types.StringFilter']
    updatedBy: Union[None, _str, 'types.StringFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    parentEvent: Union[None, _str, 'types.StringFilter']
    seriesSlug: Union[None, _str, 'types.StringFilter']
    disqusThread: Union[None, _str, 'types.StringFilter']
    commentCount: Union[None, _int, 'types.IntFilter']
    tweetCount: Union[None, _int, 'types.IntFilter']
    featuredOrder: Union[None, _int, 'types.IntFilter']
    eventWeek: Union[None, _int, 'types.IntFilter']
    templateVariables: Union[None, _str, 'types.StringFilter']
    score: Union[None, _str, 'types.StringFilter']
    elapsed: Union[None, _str, 'types.StringFilter']
    period: Union[None, _str, 'types.StringFilter']
    gmpChartMode: Union[None, _str, 'types.StringFilter']
    estimatedValue: Union[None, _str, 'types.StringFilter']
    spreadsMainLine: Union[None, _float, 'types.FloatFilter']
    totalsMainLine: Union[None, _float, 'types.FloatFilter']
    carouselMap: Union[None, _str, 'types.StringFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameStatus: Union[None, _str, 'types.StringFilter']
    negRisk: Union[None, _bool, 'types.BooleanFilter']
    negRiskMarketID: Union[None, _str, 'types.StringFilter']
    negRiskFeeBips: Union[None, _float, 'types.FloatFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    tags: 'TagListRelationFilter'
    Comment: 'CommentListRelationFilter'
    CommentCheckpoint: 'CommentCheckpointListRelationFilter'

    # should be noted that AND and NOT should be Union['EventWhereInputRecursive1', List['EventWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['EventWhereInputRecursive1']
    OR: List['EventWhereInputRecursive1']
    NOT: List['EventWhereInputRecursive1']


class EventWhereInputRecursive1(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ticker: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    title: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, _str, 'types.StringFilter']
    creationDate: Union[None, _str, 'types.StringFilter']
    endDate: Union[None, _str, 'types.StringFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    eventDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    featured: Union[None, _bool, 'types.BooleanFilter']
    restricted: Union[None, _bool, 'types.BooleanFilter']
    isTemplate: Union[None, _bool, 'types.BooleanFilter']
    commentsEnabled: Union[None, _bool, 'types.BooleanFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    automaticallyResolved: Union[None, _bool, 'types.BooleanFilter']
    automaticallyActive: Union[None, _bool, 'types.BooleanFilter']
    showAllOutcomes: Union[None, _bool, 'types.BooleanFilter']
    showMarketImages: Union[None, _bool, 'types.BooleanFilter']
    enableNegRisk: Union[None, _bool, 'types.BooleanFilter']
    live: Union[None, _bool, 'types.BooleanFilter']
    ended: Union[None, _bool, 'types.BooleanFilter']
    pendingDeployment: Union[None, _bool, 'types.BooleanFilter']
    deploying: Union[None, _bool, 'types.BooleanFilter']
    estimateValue: Union[None, _bool, 'types.BooleanFilter']
    cantEstimate: Union[None, _bool, 'types.BooleanFilter']
    liquidity: Union[None, _float, 'types.FloatFilter']
    volume: Union[None, _float, 'types.FloatFilter']
    openInterest: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    competitive: Union[None, _float, 'types.FloatFilter']
    category: Union[None, _str, 'types.StringFilter']
    sortBy: Union[None, _str, 'types.StringFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _str, 'types.StringFilter']
    updatedBy: Union[None, _str, 'types.StringFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    parentEvent: Union[None, _str, 'types.StringFilter']
    seriesSlug: Union[None, _str, 'types.StringFilter']
    disqusThread: Union[None, _str, 'types.StringFilter']
    commentCount: Union[None, _int, 'types.IntFilter']
    tweetCount: Union[None, _int, 'types.IntFilter']
    featuredOrder: Union[None, _int, 'types.IntFilter']
    eventWeek: Union[None, _int, 'types.IntFilter']
    templateVariables: Union[None, _str, 'types.StringFilter']
    score: Union[None, _str, 'types.StringFilter']
    elapsed: Union[None, _str, 'types.StringFilter']
    period: Union[None, _str, 'types.StringFilter']
    gmpChartMode: Union[None, _str, 'types.StringFilter']
    estimatedValue: Union[None, _str, 'types.StringFilter']
    spreadsMainLine: Union[None, _float, 'types.FloatFilter']
    totalsMainLine: Union[None, _float, 'types.FloatFilter']
    carouselMap: Union[None, _str, 'types.StringFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameStatus: Union[None, _str, 'types.StringFilter']
    negRisk: Union[None, _bool, 'types.BooleanFilter']
    negRiskMarketID: Union[None, _str, 'types.StringFilter']
    negRiskFeeBips: Union[None, _float, 'types.FloatFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    tags: 'TagListRelationFilter'
    Comment: 'CommentListRelationFilter'
    CommentCheckpoint: 'CommentCheckpointListRelationFilter'

    # should be noted that AND and NOT should be Union['EventWhereInputRecursive2', List['EventWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['EventWhereInputRecursive2']
    OR: List['EventWhereInputRecursive2']
    NOT: List['EventWhereInputRecursive2']


class EventWhereInputRecursive2(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ticker: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    title: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, _str, 'types.StringFilter']
    creationDate: Union[None, _str, 'types.StringFilter']
    endDate: Union[None, _str, 'types.StringFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    eventDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    featured: Union[None, _bool, 'types.BooleanFilter']
    restricted: Union[None, _bool, 'types.BooleanFilter']
    isTemplate: Union[None, _bool, 'types.BooleanFilter']
    commentsEnabled: Union[None, _bool, 'types.BooleanFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    automaticallyResolved: Union[None, _bool, 'types.BooleanFilter']
    automaticallyActive: Union[None, _bool, 'types.BooleanFilter']
    showAllOutcomes: Union[None, _bool, 'types.BooleanFilter']
    showMarketImages: Union[None, _bool, 'types.BooleanFilter']
    enableNegRisk: Union[None, _bool, 'types.BooleanFilter']
    live: Union[None, _bool, 'types.BooleanFilter']
    ended: Union[None, _bool, 'types.BooleanFilter']
    pendingDeployment: Union[None, _bool, 'types.BooleanFilter']
    deploying: Union[None, _bool, 'types.BooleanFilter']
    estimateValue: Union[None, _bool, 'types.BooleanFilter']
    cantEstimate: Union[None, _bool, 'types.BooleanFilter']
    liquidity: Union[None, _float, 'types.FloatFilter']
    volume: Union[None, _float, 'types.FloatFilter']
    openInterest: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    competitive: Union[None, _float, 'types.FloatFilter']
    category: Union[None, _str, 'types.StringFilter']
    sortBy: Union[None, _str, 'types.StringFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _str, 'types.StringFilter']
    updatedBy: Union[None, _str, 'types.StringFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    parentEvent: Union[None, _str, 'types.StringFilter']
    seriesSlug: Union[None, _str, 'types.StringFilter']
    disqusThread: Union[None, _str, 'types.StringFilter']
    commentCount: Union[None, _int, 'types.IntFilter']
    tweetCount: Union[None, _int, 'types.IntFilter']
    featuredOrder: Union[None, _int, 'types.IntFilter']
    eventWeek: Union[None, _int, 'types.IntFilter']
    templateVariables: Union[None, _str, 'types.StringFilter']
    score: Union[None, _str, 'types.StringFilter']
    elapsed: Union[None, _str, 'types.StringFilter']
    period: Union[None, _str, 'types.StringFilter']
    gmpChartMode: Union[None, _str, 'types.StringFilter']
    estimatedValue: Union[None, _str, 'types.StringFilter']
    spreadsMainLine: Union[None, _float, 'types.FloatFilter']
    totalsMainLine: Union[None, _float, 'types.FloatFilter']
    carouselMap: Union[None, _str, 'types.StringFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameStatus: Union[None, _str, 'types.StringFilter']
    negRisk: Union[None, _bool, 'types.BooleanFilter']
    negRiskMarketID: Union[None, _str, 'types.StringFilter']
    negRiskFeeBips: Union[None, _float, 'types.FloatFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    tags: 'TagListRelationFilter'
    Comment: 'CommentListRelationFilter'
    CommentCheckpoint: 'CommentCheckpointListRelationFilter'

    # should be noted that AND and NOT should be Union['EventWhereInputRecursive3', List['EventWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['EventWhereInputRecursive3']
    OR: List['EventWhereInputRecursive3']
    NOT: List['EventWhereInputRecursive3']


class EventWhereInputRecursive3(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ticker: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    title: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, _str, 'types.StringFilter']
    creationDate: Union[None, _str, 'types.StringFilter']
    endDate: Union[None, _str, 'types.StringFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    eventDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    featured: Union[None, _bool, 'types.BooleanFilter']
    restricted: Union[None, _bool, 'types.BooleanFilter']
    isTemplate: Union[None, _bool, 'types.BooleanFilter']
    commentsEnabled: Union[None, _bool, 'types.BooleanFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    automaticallyResolved: Union[None, _bool, 'types.BooleanFilter']
    automaticallyActive: Union[None, _bool, 'types.BooleanFilter']
    showAllOutcomes: Union[None, _bool, 'types.BooleanFilter']
    showMarketImages: Union[None, _bool, 'types.BooleanFilter']
    enableNegRisk: Union[None, _bool, 'types.BooleanFilter']
    live: Union[None, _bool, 'types.BooleanFilter']
    ended: Union[None, _bool, 'types.BooleanFilter']
    pendingDeployment: Union[None, _bool, 'types.BooleanFilter']
    deploying: Union[None, _bool, 'types.BooleanFilter']
    estimateValue: Union[None, _bool, 'types.BooleanFilter']
    cantEstimate: Union[None, _bool, 'types.BooleanFilter']
    liquidity: Union[None, _float, 'types.FloatFilter']
    volume: Union[None, _float, 'types.FloatFilter']
    openInterest: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    competitive: Union[None, _float, 'types.FloatFilter']
    category: Union[None, _str, 'types.StringFilter']
    sortBy: Union[None, _str, 'types.StringFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _str, 'types.StringFilter']
    updatedBy: Union[None, _str, 'types.StringFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    parentEvent: Union[None, _str, 'types.StringFilter']
    seriesSlug: Union[None, _str, 'types.StringFilter']
    disqusThread: Union[None, _str, 'types.StringFilter']
    commentCount: Union[None, _int, 'types.IntFilter']
    tweetCount: Union[None, _int, 'types.IntFilter']
    featuredOrder: Union[None, _int, 'types.IntFilter']
    eventWeek: Union[None, _int, 'types.IntFilter']
    templateVariables: Union[None, _str, 'types.StringFilter']
    score: Union[None, _str, 'types.StringFilter']
    elapsed: Union[None, _str, 'types.StringFilter']
    period: Union[None, _str, 'types.StringFilter']
    gmpChartMode: Union[None, _str, 'types.StringFilter']
    estimatedValue: Union[None, _str, 'types.StringFilter']
    spreadsMainLine: Union[None, _float, 'types.FloatFilter']
    totalsMainLine: Union[None, _float, 'types.FloatFilter']
    carouselMap: Union[None, _str, 'types.StringFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameStatus: Union[None, _str, 'types.StringFilter']
    negRisk: Union[None, _bool, 'types.BooleanFilter']
    negRiskMarketID: Union[None, _str, 'types.StringFilter']
    negRiskFeeBips: Union[None, _float, 'types.FloatFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    tags: 'TagListRelationFilter'
    Comment: 'CommentListRelationFilter'
    CommentCheckpoint: 'CommentCheckpointListRelationFilter'

    # should be noted that AND and NOT should be Union['EventWhereInputRecursive4', List['EventWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['EventWhereInputRecursive4']
    OR: List['EventWhereInputRecursive4']
    NOT: List['EventWhereInputRecursive4']


class EventWhereInputRecursive4(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    ticker: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    title: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, _str, 'types.StringFilter']
    creationDate: Union[None, _str, 'types.StringFilter']
    endDate: Union[None, _str, 'types.StringFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    eventDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    startTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    finishedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    featured: Union[None, _bool, 'types.BooleanFilter']
    restricted: Union[None, _bool, 'types.BooleanFilter']
    isTemplate: Union[None, _bool, 'types.BooleanFilter']
    commentsEnabled: Union[None, _bool, 'types.BooleanFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    automaticallyResolved: Union[None, _bool, 'types.BooleanFilter']
    automaticallyActive: Union[None, _bool, 'types.BooleanFilter']
    showAllOutcomes: Union[None, _bool, 'types.BooleanFilter']
    showMarketImages: Union[None, _bool, 'types.BooleanFilter']
    enableNegRisk: Union[None, _bool, 'types.BooleanFilter']
    live: Union[None, _bool, 'types.BooleanFilter']
    ended: Union[None, _bool, 'types.BooleanFilter']
    pendingDeployment: Union[None, _bool, 'types.BooleanFilter']
    deploying: Union[None, _bool, 'types.BooleanFilter']
    estimateValue: Union[None, _bool, 'types.BooleanFilter']
    cantEstimate: Union[None, _bool, 'types.BooleanFilter']
    liquidity: Union[None, _float, 'types.FloatFilter']
    volume: Union[None, _float, 'types.FloatFilter']
    openInterest: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    competitive: Union[None, _float, 'types.FloatFilter']
    category: Union[None, _str, 'types.StringFilter']
    sortBy: Union[None, _str, 'types.StringFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _str, 'types.StringFilter']
    updatedBy: Union[None, _str, 'types.StringFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    parentEvent: Union[None, _str, 'types.StringFilter']
    seriesSlug: Union[None, _str, 'types.StringFilter']
    disqusThread: Union[None, _str, 'types.StringFilter']
    commentCount: Union[None, _int, 'types.IntFilter']
    tweetCount: Union[None, _int, 'types.IntFilter']
    featuredOrder: Union[None, _int, 'types.IntFilter']
    eventWeek: Union[None, _int, 'types.IntFilter']
    templateVariables: Union[None, _str, 'types.StringFilter']
    score: Union[None, _str, 'types.StringFilter']
    elapsed: Union[None, _str, 'types.StringFilter']
    period: Union[None, _str, 'types.StringFilter']
    gmpChartMode: Union[None, _str, 'types.StringFilter']
    estimatedValue: Union[None, _str, 'types.StringFilter']
    spreadsMainLine: Union[None, _float, 'types.FloatFilter']
    totalsMainLine: Union[None, _float, 'types.FloatFilter']
    carouselMap: Union[None, _str, 'types.StringFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameStatus: Union[None, _str, 'types.StringFilter']
    negRisk: Union[None, _bool, 'types.BooleanFilter']
    negRiskMarketID: Union[None, _str, 'types.StringFilter']
    negRiskFeeBips: Union[None, _float, 'types.FloatFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    tags: 'TagListRelationFilter'
    Comment: 'CommentListRelationFilter'
    CommentCheckpoint: 'CommentCheckpointListRelationFilter'



# aggregate Event types


    

class EventScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ticker: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[_str, 'types.StringWithAggregatesFilter']
    creationDate: Union[_str, 'types.StringWithAggregatesFilter']
    endDate: Union[_str, 'types.StringWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    eventDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    featured: Union[_bool, 'types.BooleanWithAggregatesFilter']
    restricted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isTemplate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    commentsEnabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyResolved: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showAllOutcomes: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showMarketImages: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableNegRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    live: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ended: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pendingDeployment: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deploying: Union[_bool, 'types.BooleanWithAggregatesFilter']
    estimateValue: Union[_bool, 'types.BooleanWithAggregatesFilter']
    cantEstimate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    liquidity: Union[_float, 'types.FloatWithAggregatesFilter']
    volume: Union[_float, 'types.FloatWithAggregatesFilter']
    openInterest: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    competitive: Union[_float, 'types.FloatWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    sortBy: Union[_str, 'types.StringWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_str, 'types.StringWithAggregatesFilter']
    updatedBy: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentEvent: Union[_str, 'types.StringWithAggregatesFilter']
    seriesSlug: Union[_str, 'types.StringWithAggregatesFilter']
    disqusThread: Union[_str, 'types.StringWithAggregatesFilter']
    commentCount: Union[_int, 'types.IntWithAggregatesFilter']
    tweetCount: Union[_int, 'types.IntWithAggregatesFilter']
    featuredOrder: Union[_int, 'types.IntWithAggregatesFilter']
    eventWeek: Union[_int, 'types.IntWithAggregatesFilter']
    templateVariables: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_str, 'types.StringWithAggregatesFilter']
    elapsed: Union[_str, 'types.StringWithAggregatesFilter']
    period: Union[_str, 'types.StringWithAggregatesFilter']
    gmpChartMode: Union[_str, 'types.StringWithAggregatesFilter']
    estimatedValue: Union[_str, 'types.StringWithAggregatesFilter']
    spreadsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    totalsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    carouselMap: Union[_str, 'types.StringWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameStatus: Union[_str, 'types.StringWithAggregatesFilter']
    negRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    negRiskMarketID: Union[_str, 'types.StringWithAggregatesFilter']
    negRiskFeeBips: Union[_float, 'types.FloatWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EventScalarWhereWithAggregatesInputRecursive1']
    OR: List['EventScalarWhereWithAggregatesInputRecursive1']
    NOT: List['EventScalarWhereWithAggregatesInputRecursive1']


class EventScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ticker: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[_str, 'types.StringWithAggregatesFilter']
    creationDate: Union[_str, 'types.StringWithAggregatesFilter']
    endDate: Union[_str, 'types.StringWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    eventDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    featured: Union[_bool, 'types.BooleanWithAggregatesFilter']
    restricted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isTemplate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    commentsEnabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyResolved: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showAllOutcomes: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showMarketImages: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableNegRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    live: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ended: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pendingDeployment: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deploying: Union[_bool, 'types.BooleanWithAggregatesFilter']
    estimateValue: Union[_bool, 'types.BooleanWithAggregatesFilter']
    cantEstimate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    liquidity: Union[_float, 'types.FloatWithAggregatesFilter']
    volume: Union[_float, 'types.FloatWithAggregatesFilter']
    openInterest: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    competitive: Union[_float, 'types.FloatWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    sortBy: Union[_str, 'types.StringWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_str, 'types.StringWithAggregatesFilter']
    updatedBy: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentEvent: Union[_str, 'types.StringWithAggregatesFilter']
    seriesSlug: Union[_str, 'types.StringWithAggregatesFilter']
    disqusThread: Union[_str, 'types.StringWithAggregatesFilter']
    commentCount: Union[_int, 'types.IntWithAggregatesFilter']
    tweetCount: Union[_int, 'types.IntWithAggregatesFilter']
    featuredOrder: Union[_int, 'types.IntWithAggregatesFilter']
    eventWeek: Union[_int, 'types.IntWithAggregatesFilter']
    templateVariables: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_str, 'types.StringWithAggregatesFilter']
    elapsed: Union[_str, 'types.StringWithAggregatesFilter']
    period: Union[_str, 'types.StringWithAggregatesFilter']
    gmpChartMode: Union[_str, 'types.StringWithAggregatesFilter']
    estimatedValue: Union[_str, 'types.StringWithAggregatesFilter']
    spreadsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    totalsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    carouselMap: Union[_str, 'types.StringWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameStatus: Union[_str, 'types.StringWithAggregatesFilter']
    negRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    negRiskMarketID: Union[_str, 'types.StringWithAggregatesFilter']
    negRiskFeeBips: Union[_float, 'types.FloatWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EventScalarWhereWithAggregatesInputRecursive2']
    OR: List['EventScalarWhereWithAggregatesInputRecursive2']
    NOT: List['EventScalarWhereWithAggregatesInputRecursive2']


class EventScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ticker: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[_str, 'types.StringWithAggregatesFilter']
    creationDate: Union[_str, 'types.StringWithAggregatesFilter']
    endDate: Union[_str, 'types.StringWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    eventDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    featured: Union[_bool, 'types.BooleanWithAggregatesFilter']
    restricted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isTemplate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    commentsEnabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyResolved: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showAllOutcomes: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showMarketImages: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableNegRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    live: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ended: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pendingDeployment: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deploying: Union[_bool, 'types.BooleanWithAggregatesFilter']
    estimateValue: Union[_bool, 'types.BooleanWithAggregatesFilter']
    cantEstimate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    liquidity: Union[_float, 'types.FloatWithAggregatesFilter']
    volume: Union[_float, 'types.FloatWithAggregatesFilter']
    openInterest: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    competitive: Union[_float, 'types.FloatWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    sortBy: Union[_str, 'types.StringWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_str, 'types.StringWithAggregatesFilter']
    updatedBy: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentEvent: Union[_str, 'types.StringWithAggregatesFilter']
    seriesSlug: Union[_str, 'types.StringWithAggregatesFilter']
    disqusThread: Union[_str, 'types.StringWithAggregatesFilter']
    commentCount: Union[_int, 'types.IntWithAggregatesFilter']
    tweetCount: Union[_int, 'types.IntWithAggregatesFilter']
    featuredOrder: Union[_int, 'types.IntWithAggregatesFilter']
    eventWeek: Union[_int, 'types.IntWithAggregatesFilter']
    templateVariables: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_str, 'types.StringWithAggregatesFilter']
    elapsed: Union[_str, 'types.StringWithAggregatesFilter']
    period: Union[_str, 'types.StringWithAggregatesFilter']
    gmpChartMode: Union[_str, 'types.StringWithAggregatesFilter']
    estimatedValue: Union[_str, 'types.StringWithAggregatesFilter']
    spreadsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    totalsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    carouselMap: Union[_str, 'types.StringWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameStatus: Union[_str, 'types.StringWithAggregatesFilter']
    negRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    negRiskMarketID: Union[_str, 'types.StringWithAggregatesFilter']
    negRiskFeeBips: Union[_float, 'types.FloatWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EventScalarWhereWithAggregatesInputRecursive3']
    OR: List['EventScalarWhereWithAggregatesInputRecursive3']
    NOT: List['EventScalarWhereWithAggregatesInputRecursive3']


class EventScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ticker: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[_str, 'types.StringWithAggregatesFilter']
    creationDate: Union[_str, 'types.StringWithAggregatesFilter']
    endDate: Union[_str, 'types.StringWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    eventDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    featured: Union[_bool, 'types.BooleanWithAggregatesFilter']
    restricted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isTemplate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    commentsEnabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyResolved: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showAllOutcomes: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showMarketImages: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableNegRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    live: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ended: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pendingDeployment: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deploying: Union[_bool, 'types.BooleanWithAggregatesFilter']
    estimateValue: Union[_bool, 'types.BooleanWithAggregatesFilter']
    cantEstimate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    liquidity: Union[_float, 'types.FloatWithAggregatesFilter']
    volume: Union[_float, 'types.FloatWithAggregatesFilter']
    openInterest: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    competitive: Union[_float, 'types.FloatWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    sortBy: Union[_str, 'types.StringWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_str, 'types.StringWithAggregatesFilter']
    updatedBy: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentEvent: Union[_str, 'types.StringWithAggregatesFilter']
    seriesSlug: Union[_str, 'types.StringWithAggregatesFilter']
    disqusThread: Union[_str, 'types.StringWithAggregatesFilter']
    commentCount: Union[_int, 'types.IntWithAggregatesFilter']
    tweetCount: Union[_int, 'types.IntWithAggregatesFilter']
    featuredOrder: Union[_int, 'types.IntWithAggregatesFilter']
    eventWeek: Union[_int, 'types.IntWithAggregatesFilter']
    templateVariables: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_str, 'types.StringWithAggregatesFilter']
    elapsed: Union[_str, 'types.StringWithAggregatesFilter']
    period: Union[_str, 'types.StringWithAggregatesFilter']
    gmpChartMode: Union[_str, 'types.StringWithAggregatesFilter']
    estimatedValue: Union[_str, 'types.StringWithAggregatesFilter']
    spreadsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    totalsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    carouselMap: Union[_str, 'types.StringWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameStatus: Union[_str, 'types.StringWithAggregatesFilter']
    negRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    negRiskMarketID: Union[_str, 'types.StringWithAggregatesFilter']
    negRiskFeeBips: Union[_float, 'types.FloatWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['EventScalarWhereWithAggregatesInputRecursive4']
    OR: List['EventScalarWhereWithAggregatesInputRecursive4']
    NOT: List['EventScalarWhereWithAggregatesInputRecursive4']


class EventScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Event arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    ticker: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[_str, 'types.StringWithAggregatesFilter']
    creationDate: Union[_str, 'types.StringWithAggregatesFilter']
    endDate: Union[_str, 'types.StringWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    eventDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    finishedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    featured: Union[_bool, 'types.BooleanWithAggregatesFilter']
    restricted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isTemplate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    commentsEnabled: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyResolved: Union[_bool, 'types.BooleanWithAggregatesFilter']
    automaticallyActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showAllOutcomes: Union[_bool, 'types.BooleanWithAggregatesFilter']
    showMarketImages: Union[_bool, 'types.BooleanWithAggregatesFilter']
    enableNegRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    live: Union[_bool, 'types.BooleanWithAggregatesFilter']
    ended: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pendingDeployment: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deploying: Union[_bool, 'types.BooleanWithAggregatesFilter']
    estimateValue: Union[_bool, 'types.BooleanWithAggregatesFilter']
    cantEstimate: Union[_bool, 'types.BooleanWithAggregatesFilter']
    liquidity: Union[_float, 'types.FloatWithAggregatesFilter']
    volume: Union[_float, 'types.FloatWithAggregatesFilter']
    openInterest: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    competitive: Union[_float, 'types.FloatWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    sortBy: Union[_str, 'types.StringWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_str, 'types.StringWithAggregatesFilter']
    updatedBy: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentEvent: Union[_str, 'types.StringWithAggregatesFilter']
    seriesSlug: Union[_str, 'types.StringWithAggregatesFilter']
    disqusThread: Union[_str, 'types.StringWithAggregatesFilter']
    commentCount: Union[_int, 'types.IntWithAggregatesFilter']
    tweetCount: Union[_int, 'types.IntWithAggregatesFilter']
    featuredOrder: Union[_int, 'types.IntWithAggregatesFilter']
    eventWeek: Union[_int, 'types.IntWithAggregatesFilter']
    templateVariables: Union[_str, 'types.StringWithAggregatesFilter']
    score: Union[_str, 'types.StringWithAggregatesFilter']
    elapsed: Union[_str, 'types.StringWithAggregatesFilter']
    period: Union[_str, 'types.StringWithAggregatesFilter']
    gmpChartMode: Union[_str, 'types.StringWithAggregatesFilter']
    estimatedValue: Union[_str, 'types.StringWithAggregatesFilter']
    spreadsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    totalsMainLine: Union[_float, 'types.FloatWithAggregatesFilter']
    carouselMap: Union[_str, 'types.StringWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameStatus: Union[_str, 'types.StringWithAggregatesFilter']
    negRisk: Union[_bool, 'types.BooleanWithAggregatesFilter']
    negRiskMarketID: Union[_str, 'types.StringWithAggregatesFilter']
    negRiskFeeBips: Union[_float, 'types.FloatWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class EventGroupByOutput(TypedDict, total=False):
    id: _str
    ticker: _str
    slug: _str
    title: _str
    description: _str
    resolutionSource: _str
    startDate: _str
    creationDate: _str
    endDate: _str
    closedTime: datetime.datetime
    eventDate: datetime.datetime
    startTime: datetime.datetime
    finishedTimestamp: datetime.datetime
    image: _str
    icon: _str
    active: _bool
    closed: _bool
    archived: _bool
    new: _bool
    featured: _bool
    restricted: _bool
    isTemplate: _bool
    commentsEnabled: _bool
    enableOrderBook: _bool
    automaticallyResolved: _bool
    automaticallyActive: _bool
    showAllOutcomes: _bool
    showMarketImages: _bool
    enableNegRisk: _bool
    live: _bool
    ended: _bool
    pendingDeployment: _bool
    deploying: _bool
    estimateValue: _bool
    cantEstimate: _bool
    liquidity: _float
    volume: _float
    openInterest: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    liquidityAmm: _float
    liquidityClob: _float
    competitive: _float
    category: _str
    sortBy: _str
    publishedAt: datetime.datetime
    createdBy: _str
    updatedBy: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    parentEvent: _str
    seriesSlug: _str
    disqusThread: _str
    commentCount: _int
    tweetCount: _int
    featuredOrder: _int
    eventWeek: _int
    templateVariables: _str
    score: _str
    elapsed: _str
    period: _str
    gmpChartMode: _str
    estimatedValue: _str
    spreadsMainLine: _float
    totalsMainLine: _float
    carouselMap: _str
    deployingTimestamp: datetime.datetime
    scheduledDeploymentTimestamp: datetime.datetime
    gameStatus: _str
    negRisk: _bool
    negRiskMarketID: _str
    negRiskFeeBips: _float
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    _sum: 'EventSumAggregateOutput'
    _avg: 'EventAvgAggregateOutput'
    _min: 'EventMinAggregateOutput'
    _max: 'EventMaxAggregateOutput'
    _count: 'EventCountAggregateOutput'


class EventAvgAggregateOutput(TypedDict, total=False):
    """Event output for aggregating averages"""
    liquidity: float
    volume: float
    openInterest: float
    volume24hr: float
    volume1wk: float
    volume1mo: float
    volume1yr: float
    liquidityAmm: float
    liquidityClob: float
    competitive: float
    commentCount: float
    tweetCount: float
    featuredOrder: float
    eventWeek: float
    spreadsMainLine: float
    totalsMainLine: float
    negRiskFeeBips: float


class EventSumAggregateOutput(TypedDict, total=False):
    """Event output for aggregating sums"""
    liquidity: _float
    volume: _float
    openInterest: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    liquidityAmm: _float
    liquidityClob: _float
    competitive: _float
    commentCount: _int
    tweetCount: _int
    featuredOrder: _int
    eventWeek: _int
    spreadsMainLine: _float
    totalsMainLine: _float
    negRiskFeeBips: _float


class EventScalarAggregateOutput(TypedDict, total=False):
    """Event output including scalar fields"""
    id: _str
    ticker: _str
    slug: _str
    title: _str
    description: _str
    resolutionSource: _str
    startDate: _str
    creationDate: _str
    endDate: _str
    closedTime: datetime.datetime
    eventDate: datetime.datetime
    startTime: datetime.datetime
    finishedTimestamp: datetime.datetime
    image: _str
    icon: _str
    active: _bool
    closed: _bool
    archived: _bool
    new: _bool
    featured: _bool
    restricted: _bool
    isTemplate: _bool
    commentsEnabled: _bool
    enableOrderBook: _bool
    automaticallyResolved: _bool
    automaticallyActive: _bool
    showAllOutcomes: _bool
    showMarketImages: _bool
    enableNegRisk: _bool
    live: _bool
    ended: _bool
    pendingDeployment: _bool
    deploying: _bool
    estimateValue: _bool
    cantEstimate: _bool
    liquidity: _float
    volume: _float
    openInterest: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    liquidityAmm: _float
    liquidityClob: _float
    competitive: _float
    category: _str
    sortBy: _str
    publishedAt: datetime.datetime
    createdBy: _str
    updatedBy: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    parentEvent: _str
    seriesSlug: _str
    disqusThread: _str
    commentCount: _int
    tweetCount: _int
    featuredOrder: _int
    eventWeek: _int
    templateVariables: _str
    score: _str
    elapsed: _str
    period: _str
    gmpChartMode: _str
    estimatedValue: _str
    spreadsMainLine: _float
    totalsMainLine: _float
    carouselMap: _str
    deployingTimestamp: datetime.datetime
    scheduledDeploymentTimestamp: datetime.datetime
    gameStatus: _str
    negRisk: _bool
    negRiskMarketID: _str
    negRiskFeeBips: _float
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


EventMinAggregateOutput = EventScalarAggregateOutput
EventMaxAggregateOutput = EventScalarAggregateOutput


class EventMaxAggregateInput(TypedDict, total=False):
    """Event input for aggregating by max"""
    id: bool
    ticker: bool
    slug: bool
    title: bool
    description: bool
    resolutionSource: bool
    startDate: bool
    creationDate: bool
    endDate: bool
    closedTime: bool
    eventDate: bool
    startTime: bool
    finishedTimestamp: bool
    image: bool
    icon: bool
    active: bool
    closed: bool
    archived: bool
    new: bool
    featured: bool
    restricted: bool
    isTemplate: bool
    commentsEnabled: bool
    enableOrderBook: bool
    automaticallyResolved: bool
    automaticallyActive: bool
    showAllOutcomes: bool
    showMarketImages: bool
    enableNegRisk: bool
    live: bool
    ended: bool
    pendingDeployment: bool
    deploying: bool
    estimateValue: bool
    cantEstimate: bool
    liquidity: bool
    volume: bool
    openInterest: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    liquidityAmm: bool
    liquidityClob: bool
    competitive: bool
    category: bool
    sortBy: bool
    publishedAt: bool
    createdBy: bool
    updatedBy: bool
    createdAt: bool
    updatedAt: bool
    parentEvent: bool
    seriesSlug: bool
    disqusThread: bool
    commentCount: bool
    tweetCount: bool
    featuredOrder: bool
    eventWeek: bool
    templateVariables: bool
    score: bool
    elapsed: bool
    period: bool
    gmpChartMode: bool
    estimatedValue: bool
    spreadsMainLine: bool
    totalsMainLine: bool
    carouselMap: bool
    deployingTimestamp: bool
    scheduledDeploymentTimestamp: bool
    gameStatus: bool
    negRisk: bool
    negRiskMarketID: bool
    negRiskFeeBips: bool
    scrapedAt: bool
    createdInDb: bool


class EventMinAggregateInput(TypedDict, total=False):
    """Event input for aggregating by min"""
    id: bool
    ticker: bool
    slug: bool
    title: bool
    description: bool
    resolutionSource: bool
    startDate: bool
    creationDate: bool
    endDate: bool
    closedTime: bool
    eventDate: bool
    startTime: bool
    finishedTimestamp: bool
    image: bool
    icon: bool
    active: bool
    closed: bool
    archived: bool
    new: bool
    featured: bool
    restricted: bool
    isTemplate: bool
    commentsEnabled: bool
    enableOrderBook: bool
    automaticallyResolved: bool
    automaticallyActive: bool
    showAllOutcomes: bool
    showMarketImages: bool
    enableNegRisk: bool
    live: bool
    ended: bool
    pendingDeployment: bool
    deploying: bool
    estimateValue: bool
    cantEstimate: bool
    liquidity: bool
    volume: bool
    openInterest: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    liquidityAmm: bool
    liquidityClob: bool
    competitive: bool
    category: bool
    sortBy: bool
    publishedAt: bool
    createdBy: bool
    updatedBy: bool
    createdAt: bool
    updatedAt: bool
    parentEvent: bool
    seriesSlug: bool
    disqusThread: bool
    commentCount: bool
    tweetCount: bool
    featuredOrder: bool
    eventWeek: bool
    templateVariables: bool
    score: bool
    elapsed: bool
    period: bool
    gmpChartMode: bool
    estimatedValue: bool
    spreadsMainLine: bool
    totalsMainLine: bool
    carouselMap: bool
    deployingTimestamp: bool
    scheduledDeploymentTimestamp: bool
    gameStatus: bool
    negRisk: bool
    negRiskMarketID: bool
    negRiskFeeBips: bool
    scrapedAt: bool
    createdInDb: bool


class EventNumberAggregateInput(TypedDict, total=False):
    """Event input for aggregating numbers"""
    liquidity: bool
    volume: bool
    openInterest: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    liquidityAmm: bool
    liquidityClob: bool
    competitive: bool
    commentCount: bool
    tweetCount: bool
    featuredOrder: bool
    eventWeek: bool
    spreadsMainLine: bool
    totalsMainLine: bool
    negRiskFeeBips: bool


EventAvgAggregateInput = EventNumberAggregateInput
EventSumAggregateInput = EventNumberAggregateInput


EventCountAggregateInput = TypedDict(
    'EventCountAggregateInput',
    {
        'id': bool,
        'ticker': bool,
        'slug': bool,
        'title': bool,
        'description': bool,
        'resolutionSource': bool,
        'startDate': bool,
        'creationDate': bool,
        'endDate': bool,
        'closedTime': bool,
        'eventDate': bool,
        'startTime': bool,
        'finishedTimestamp': bool,
        'image': bool,
        'icon': bool,
        'active': bool,
        'closed': bool,
        'archived': bool,
        'new': bool,
        'featured': bool,
        'restricted': bool,
        'isTemplate': bool,
        'commentsEnabled': bool,
        'enableOrderBook': bool,
        'automaticallyResolved': bool,
        'automaticallyActive': bool,
        'showAllOutcomes': bool,
        'showMarketImages': bool,
        'enableNegRisk': bool,
        'live': bool,
        'ended': bool,
        'pendingDeployment': bool,
        'deploying': bool,
        'estimateValue': bool,
        'cantEstimate': bool,
        'liquidity': bool,
        'volume': bool,
        'openInterest': bool,
        'volume24hr': bool,
        'volume1wk': bool,
        'volume1mo': bool,
        'volume1yr': bool,
        'liquidityAmm': bool,
        'liquidityClob': bool,
        'competitive': bool,
        'category': bool,
        'sortBy': bool,
        'publishedAt': bool,
        'createdBy': bool,
        'updatedBy': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'parentEvent': bool,
        'seriesSlug': bool,
        'disqusThread': bool,
        'commentCount': bool,
        'tweetCount': bool,
        'featuredOrder': bool,
        'eventWeek': bool,
        'templateVariables': bool,
        'score': bool,
        'elapsed': bool,
        'period': bool,
        'gmpChartMode': bool,
        'estimatedValue': bool,
        'spreadsMainLine': bool,
        'totalsMainLine': bool,
        'carouselMap': bool,
        'deployingTimestamp': bool,
        'scheduledDeploymentTimestamp': bool,
        'gameStatus': bool,
        'negRisk': bool,
        'negRiskMarketID': bool,
        'negRiskFeeBips': bool,
        'scrapedAt': bool,
        'createdInDb': bool,
        '_all': bool,
    },
    total=False,
)

EventCountAggregateOutput = TypedDict(
    'EventCountAggregateOutput',
    {
        'id': int,
        'ticker': int,
        'slug': int,
        'title': int,
        'description': int,
        'resolutionSource': int,
        'startDate': int,
        'creationDate': int,
        'endDate': int,
        'closedTime': int,
        'eventDate': int,
        'startTime': int,
        'finishedTimestamp': int,
        'image': int,
        'icon': int,
        'active': int,
        'closed': int,
        'archived': int,
        'new': int,
        'featured': int,
        'restricted': int,
        'isTemplate': int,
        'commentsEnabled': int,
        'enableOrderBook': int,
        'automaticallyResolved': int,
        'automaticallyActive': int,
        'showAllOutcomes': int,
        'showMarketImages': int,
        'enableNegRisk': int,
        'live': int,
        'ended': int,
        'pendingDeployment': int,
        'deploying': int,
        'estimateValue': int,
        'cantEstimate': int,
        'liquidity': int,
        'volume': int,
        'openInterest': int,
        'volume24hr': int,
        'volume1wk': int,
        'volume1mo': int,
        'volume1yr': int,
        'liquidityAmm': int,
        'liquidityClob': int,
        'competitive': int,
        'category': int,
        'sortBy': int,
        'publishedAt': int,
        'createdBy': int,
        'updatedBy': int,
        'createdAt': int,
        'updatedAt': int,
        'parentEvent': int,
        'seriesSlug': int,
        'disqusThread': int,
        'commentCount': int,
        'tweetCount': int,
        'featuredOrder': int,
        'eventWeek': int,
        'templateVariables': int,
        'score': int,
        'elapsed': int,
        'period': int,
        'gmpChartMode': int,
        'estimatedValue': int,
        'spreadsMainLine': int,
        'totalsMainLine': int,
        'carouselMap': int,
        'deployingTimestamp': int,
        'scheduledDeploymentTimestamp': int,
        'gameStatus': int,
        'negRisk': int,
        'negRiskMarketID': int,
        'negRiskFeeBips': int,
        'scrapedAt': int,
        'createdInDb': int,
        '_all': int,
    },
    total=False,
)


EventKeys = Literal[
    'id',
    'ticker',
    'slug',
    'title',
    'description',
    'resolutionSource',
    'startDate',
    'creationDate',
    'endDate',
    'closedTime',
    'eventDate',
    'startTime',
    'finishedTimestamp',
    'image',
    'icon',
    'active',
    'closed',
    'archived',
    'new',
    'featured',
    'restricted',
    'isTemplate',
    'commentsEnabled',
    'enableOrderBook',
    'automaticallyResolved',
    'automaticallyActive',
    'showAllOutcomes',
    'showMarketImages',
    'enableNegRisk',
    'live',
    'ended',
    'pendingDeployment',
    'deploying',
    'estimateValue',
    'cantEstimate',
    'liquidity',
    'volume',
    'openInterest',
    'volume24hr',
    'volume1wk',
    'volume1mo',
    'volume1yr',
    'liquidityAmm',
    'liquidityClob',
    'competitive',
    'category',
    'sortBy',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'parentEvent',
    'seriesSlug',
    'disqusThread',
    'commentCount',
    'tweetCount',
    'featuredOrder',
    'eventWeek',
    'templateVariables',
    'score',
    'elapsed',
    'period',
    'gmpChartMode',
    'estimatedValue',
    'spreadsMainLine',
    'totalsMainLine',
    'carouselMap',
    'deployingTimestamp',
    'scheduledDeploymentTimestamp',
    'gameStatus',
    'negRisk',
    'negRiskMarketID',
    'negRiskFeeBips',
    'scrapedAt',
    'createdInDb',
    'markets',
    'tags',
    'Comment',
    'CommentCheckpoint',
]
EventScalarFieldKeys = Literal[
    'id',
    'ticker',
    'slug',
    'title',
    'description',
    'resolutionSource',
    'startDate',
    'creationDate',
    'endDate',
    'closedTime',
    'eventDate',
    'startTime',
    'finishedTimestamp',
    'image',
    'icon',
    'active',
    'closed',
    'archived',
    'new',
    'featured',
    'restricted',
    'isTemplate',
    'commentsEnabled',
    'enableOrderBook',
    'automaticallyResolved',
    'automaticallyActive',
    'showAllOutcomes',
    'showMarketImages',
    'enableNegRisk',
    'live',
    'ended',
    'pendingDeployment',
    'deploying',
    'estimateValue',
    'cantEstimate',
    'liquidity',
    'volume',
    'openInterest',
    'volume24hr',
    'volume1wk',
    'volume1mo',
    'volume1yr',
    'liquidityAmm',
    'liquidityClob',
    'competitive',
    'category',
    'sortBy',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'parentEvent',
    'seriesSlug',
    'disqusThread',
    'commentCount',
    'tweetCount',
    'featuredOrder',
    'eventWeek',
    'templateVariables',
    'score',
    'elapsed',
    'period',
    'gmpChartMode',
    'estimatedValue',
    'spreadsMainLine',
    'totalsMainLine',
    'carouselMap',
    'deployingTimestamp',
    'scheduledDeploymentTimestamp',
    'gameStatus',
    'negRisk',
    'negRiskMarketID',
    'negRiskFeeBips',
    'scrapedAt',
    'createdInDb',
]
EventScalarFieldKeysT = TypeVar('EventScalarFieldKeysT', bound=EventScalarFieldKeys)

EventRelationalFieldKeys = Literal[
        'markets',
        'tags',
        'Comment',
        'CommentCheckpoint',
    ]

# Market types

class MarketOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Market create method"""
    conditionId: Optional[_str]
    questionID: Optional[_str]
    slug: Optional[_str]
    question: Optional[_str]
    description: Optional[_str]
    category: Optional[_str]
    image: Optional[_str]
    icon: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[datetime.datetime]
    endDate: Optional[datetime.datetime]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    closedTime: Optional[datetime.datetime]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    marketType: Optional[_str]
    formatType: Optional[_str]
    ammType: Optional[_str]
    volume: Optional[_str]
    volumeNum: Optional[_float]
    volume24hr: Optional[_float]
    volume1wk: Optional[_float]
    volume1mo: Optional[_float]
    volume1yr: Optional[_float]
    volumeAmm: Optional[_float]
    volumeClob: Optional[_float]
    volume24hrAmm: Optional[_float]
    volume1wkAmm: Optional[_float]
    volume1moAmm: Optional[_float]
    volume1yrAmm: Optional[_float]
    volume24hrClob: Optional[_float]
    volume1wkClob: Optional[_float]
    volume1moClob: Optional[_float]
    volume1yrClob: Optional[_float]
    liquidity: Optional[_str]
    liquidityNum: Optional[_float]
    liquidityAmm: Optional[_float]
    liquidityClob: Optional[_float]
    oneDayPriceChange: Optional[_float]
    oneHourPriceChange: Optional[_float]
    oneWeekPriceChange: Optional[_float]
    oneMonthPriceChange: Optional[_float]
    oneYearPriceChange: Optional[_float]
    lastTradePrice: Optional[_float]
    bestBid: Optional[_float]
    bestAsk: Optional[_float]
    spread: Optional[_float]
    enableOrderBook: Optional[_bool]
    fee: Optional[_str]
    makerBaseFee: Optional[_float]
    takerBaseFee: Optional[_float]
    denominationToken: Optional[_str]
    marketMakerAddress: Optional[_str]
    clobTokenIds: List[_str]
    createdBy: Optional[_int]
    updatedBy: Optional[_int]
    creator: Optional[_str]
    marketGroup: Optional[_int]
    groupItemTitle: Optional[_str]
    groupItemThreshold: Optional[_str]
    groupItemRange: Optional[_str]
    curationOrder: Optional[_int]
    score: Optional[_float]
    mailchimpTag: Optional[_str]
    outcomes: Optional[_str]
    outcomePrices: Optional[_str]
    shortOutcomes: Optional[_str]
    readyTimestamp: Optional[datetime.datetime]
    fundedTimestamp: Optional[datetime.datetime]
    acceptingOrdersTimestamp: Optional[datetime.datetime]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameId: Optional[_str]
    teamAID: Optional[_str]
    teamBID: Optional[_str]
    sportsMarketType: Optional[_str]
    line: Optional[_float]
    umaBond: Optional[_str]
    umaReward: Optional[_str]
    customLiveness: Optional[_int]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    events: 'EventCreateManyNestedWithoutRelationsInput'
    tags: 'TagCreateManyNestedWithoutRelationsInput'
    marketOutcomes: 'MarketOutcomeCreateManyNestedWithoutRelationsInput'


class MarketCreateInput(MarketOptionalCreateInput):
    """Required arguments to the Market create method"""
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MarketOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Market create method, without relations"""
    conditionId: Optional[_str]
    questionID: Optional[_str]
    slug: Optional[_str]
    question: Optional[_str]
    description: Optional[_str]
    category: Optional[_str]
    image: Optional[_str]
    icon: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[datetime.datetime]
    endDate: Optional[datetime.datetime]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    closedTime: Optional[datetime.datetime]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    marketType: Optional[_str]
    formatType: Optional[_str]
    ammType: Optional[_str]
    volume: Optional[_str]
    volumeNum: Optional[_float]
    volume24hr: Optional[_float]
    volume1wk: Optional[_float]
    volume1mo: Optional[_float]
    volume1yr: Optional[_float]
    volumeAmm: Optional[_float]
    volumeClob: Optional[_float]
    volume24hrAmm: Optional[_float]
    volume1wkAmm: Optional[_float]
    volume1moAmm: Optional[_float]
    volume1yrAmm: Optional[_float]
    volume24hrClob: Optional[_float]
    volume1wkClob: Optional[_float]
    volume1moClob: Optional[_float]
    volume1yrClob: Optional[_float]
    liquidity: Optional[_str]
    liquidityNum: Optional[_float]
    liquidityAmm: Optional[_float]
    liquidityClob: Optional[_float]
    oneDayPriceChange: Optional[_float]
    oneHourPriceChange: Optional[_float]
    oneWeekPriceChange: Optional[_float]
    oneMonthPriceChange: Optional[_float]
    oneYearPriceChange: Optional[_float]
    lastTradePrice: Optional[_float]
    bestBid: Optional[_float]
    bestAsk: Optional[_float]
    spread: Optional[_float]
    enableOrderBook: Optional[_bool]
    fee: Optional[_str]
    makerBaseFee: Optional[_float]
    takerBaseFee: Optional[_float]
    denominationToken: Optional[_str]
    marketMakerAddress: Optional[_str]
    clobTokenIds: List[_str]
    createdBy: Optional[_int]
    updatedBy: Optional[_int]
    creator: Optional[_str]
    marketGroup: Optional[_int]
    groupItemTitle: Optional[_str]
    groupItemThreshold: Optional[_str]
    groupItemRange: Optional[_str]
    curationOrder: Optional[_int]
    score: Optional[_float]
    mailchimpTag: Optional[_str]
    outcomes: Optional[_str]
    outcomePrices: Optional[_str]
    shortOutcomes: Optional[_str]
    readyTimestamp: Optional[datetime.datetime]
    fundedTimestamp: Optional[datetime.datetime]
    acceptingOrdersTimestamp: Optional[datetime.datetime]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameId: Optional[_str]
    teamAID: Optional[_str]
    teamBID: Optional[_str]
    sportsMarketType: Optional[_str]
    line: Optional[_float]
    umaBond: Optional[_str]
    umaReward: Optional[_str]
    customLiveness: Optional[_int]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class MarketCreateWithoutRelationsInput(MarketOptionalCreateWithoutRelationsInput):
    """Required arguments to the Market create method, without relations"""
    id: _str

class MarketConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MarketCreateWithoutRelationsInput'
    where: 'MarketWhereUniqueInput'

class MarketCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MarketCreateWithoutRelationsInput'
    connect: 'MarketWhereUniqueInput'
    connect_or_create: 'MarketConnectOrCreateWithoutRelationsInput'


class MarketCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MarketCreateWithoutRelationsInput', List['MarketCreateWithoutRelationsInput']]
    connect: Union['MarketWhereUniqueInput', List['MarketWhereUniqueInput']]
    connect_or_create: Union['MarketConnectOrCreateWithoutRelationsInput', List['MarketConnectOrCreateWithoutRelationsInput']]

_MarketWhereUnique_id_Input = TypedDict(
    '_MarketWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_MarketWhereUnique_slug_Input = TypedDict(
    '_MarketWhereUnique_slug_Input',
    {
        'slug': '_str',
    },
    total=True
)

MarketWhereUniqueInput = Union[
    '_MarketWhereUnique_id_Input',
    '_MarketWhereUnique_slug_Input',
]


class MarketUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    conditionId: Optional[_str]
    questionID: Optional[_str]
    slug: Optional[_str]
    question: Optional[_str]
    description: Optional[_str]
    category: Optional[_str]
    image: Optional[_str]
    icon: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[datetime.datetime]
    endDate: Optional[datetime.datetime]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    closedTime: Optional[datetime.datetime]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    marketType: Optional[_str]
    formatType: Optional[_str]
    ammType: Optional[_str]
    volume: Optional[_str]
    volumeNum: Optional[Union[AtomicFloatInput, _float]]
    volume24hr: Optional[Union[AtomicFloatInput, _float]]
    volume1wk: Optional[Union[AtomicFloatInput, _float]]
    volume1mo: Optional[Union[AtomicFloatInput, _float]]
    volume1yr: Optional[Union[AtomicFloatInput, _float]]
    volumeAmm: Optional[Union[AtomicFloatInput, _float]]
    volumeClob: Optional[Union[AtomicFloatInput, _float]]
    volume24hrAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1wkAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1moAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1yrAmm: Optional[Union[AtomicFloatInput, _float]]
    volume24hrClob: Optional[Union[AtomicFloatInput, _float]]
    volume1wkClob: Optional[Union[AtomicFloatInput, _float]]
    volume1moClob: Optional[Union[AtomicFloatInput, _float]]
    volume1yrClob: Optional[Union[AtomicFloatInput, _float]]
    liquidity: Optional[_str]
    liquidityNum: Optional[Union[AtomicFloatInput, _float]]
    liquidityAmm: Optional[Union[AtomicFloatInput, _float]]
    liquidityClob: Optional[Union[AtomicFloatInput, _float]]
    oneDayPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneHourPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneWeekPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneMonthPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneYearPriceChange: Optional[Union[AtomicFloatInput, _float]]
    lastTradePrice: Optional[Union[AtomicFloatInput, _float]]
    bestBid: Optional[Union[AtomicFloatInput, _float]]
    bestAsk: Optional[Union[AtomicFloatInput, _float]]
    spread: Optional[Union[AtomicFloatInput, _float]]
    enableOrderBook: Optional[_bool]
    fee: Optional[_str]
    makerBaseFee: Optional[Union[AtomicFloatInput, _float]]
    takerBaseFee: Optional[Union[AtomicFloatInput, _float]]
    denominationToken: Optional[_str]
    marketMakerAddress: Optional[_str]
    clobTokenIds: 'types.StringListUpdate'
    createdBy: Optional[Union[AtomicIntInput, _int]]
    updatedBy: Optional[Union[AtomicIntInput, _int]]
    creator: Optional[_str]
    marketGroup: Optional[Union[AtomicIntInput, _int]]
    groupItemTitle: Optional[_str]
    groupItemThreshold: Optional[_str]
    groupItemRange: Optional[_str]
    curationOrder: Optional[Union[AtomicIntInput, _int]]
    score: Optional[Union[AtomicFloatInput, _float]]
    mailchimpTag: Optional[_str]
    outcomes: Optional[_str]
    outcomePrices: Optional[_str]
    shortOutcomes: Optional[_str]
    readyTimestamp: Optional[datetime.datetime]
    fundedTimestamp: Optional[datetime.datetime]
    acceptingOrdersTimestamp: Optional[datetime.datetime]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameId: Optional[_str]
    teamAID: Optional[_str]
    teamBID: Optional[_str]
    sportsMarketType: Optional[_str]
    line: Optional[Union[AtomicFloatInput, _float]]
    umaBond: Optional[_str]
    umaReward: Optional[_str]
    customLiveness: Optional[Union[AtomicIntInput, _int]]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    events: 'EventUpdateManyWithoutRelationsInput'
    tags: 'TagUpdateManyWithoutRelationsInput'
    marketOutcomes: 'MarketOutcomeUpdateManyWithoutRelationsInput'


class MarketUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    conditionId: Optional[_str]
    questionID: Optional[_str]
    slug: Optional[_str]
    question: Optional[_str]
    description: Optional[_str]
    category: Optional[_str]
    image: Optional[_str]
    icon: Optional[_str]
    resolutionSource: Optional[_str]
    startDate: Optional[datetime.datetime]
    endDate: Optional[datetime.datetime]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    closedTime: Optional[datetime.datetime]
    active: Optional[_bool]
    closed: Optional[_bool]
    archived: Optional[_bool]
    new: Optional[_bool]
    marketType: Optional[_str]
    formatType: Optional[_str]
    ammType: Optional[_str]
    volume: Optional[_str]
    volumeNum: Optional[Union[AtomicFloatInput, _float]]
    volume24hr: Optional[Union[AtomicFloatInput, _float]]
    volume1wk: Optional[Union[AtomicFloatInput, _float]]
    volume1mo: Optional[Union[AtomicFloatInput, _float]]
    volume1yr: Optional[Union[AtomicFloatInput, _float]]
    volumeAmm: Optional[Union[AtomicFloatInput, _float]]
    volumeClob: Optional[Union[AtomicFloatInput, _float]]
    volume24hrAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1wkAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1moAmm: Optional[Union[AtomicFloatInput, _float]]
    volume1yrAmm: Optional[Union[AtomicFloatInput, _float]]
    volume24hrClob: Optional[Union[AtomicFloatInput, _float]]
    volume1wkClob: Optional[Union[AtomicFloatInput, _float]]
    volume1moClob: Optional[Union[AtomicFloatInput, _float]]
    volume1yrClob: Optional[Union[AtomicFloatInput, _float]]
    liquidity: Optional[_str]
    liquidityNum: Optional[Union[AtomicFloatInput, _float]]
    liquidityAmm: Optional[Union[AtomicFloatInput, _float]]
    liquidityClob: Optional[Union[AtomicFloatInput, _float]]
    oneDayPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneHourPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneWeekPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneMonthPriceChange: Optional[Union[AtomicFloatInput, _float]]
    oneYearPriceChange: Optional[Union[AtomicFloatInput, _float]]
    lastTradePrice: Optional[Union[AtomicFloatInput, _float]]
    bestBid: Optional[Union[AtomicFloatInput, _float]]
    bestAsk: Optional[Union[AtomicFloatInput, _float]]
    spread: Optional[Union[AtomicFloatInput, _float]]
    enableOrderBook: Optional[_bool]
    fee: Optional[_str]
    makerBaseFee: Optional[Union[AtomicFloatInput, _float]]
    takerBaseFee: Optional[Union[AtomicFloatInput, _float]]
    denominationToken: Optional[_str]
    marketMakerAddress: Optional[_str]
    clobTokenIds: 'types.StringListUpdate'
    createdBy: Optional[Union[AtomicIntInput, _int]]
    updatedBy: Optional[Union[AtomicIntInput, _int]]
    creator: Optional[_str]
    marketGroup: Optional[Union[AtomicIntInput, _int]]
    groupItemTitle: Optional[_str]
    groupItemThreshold: Optional[_str]
    groupItemRange: Optional[_str]
    curationOrder: Optional[Union[AtomicIntInput, _int]]
    score: Optional[Union[AtomicFloatInput, _float]]
    mailchimpTag: Optional[_str]
    outcomes: Optional[_str]
    outcomePrices: Optional[_str]
    shortOutcomes: Optional[_str]
    readyTimestamp: Optional[datetime.datetime]
    fundedTimestamp: Optional[datetime.datetime]
    acceptingOrdersTimestamp: Optional[datetime.datetime]
    deployingTimestamp: Optional[datetime.datetime]
    scheduledDeploymentTimestamp: Optional[datetime.datetime]
    gameId: Optional[_str]
    teamAID: Optional[_str]
    teamBID: Optional[_str]
    sportsMarketType: Optional[_str]
    line: Optional[Union[AtomicFloatInput, _float]]
    umaBond: Optional[_str]
    umaReward: Optional[_str]
    customLiveness: Optional[Union[AtomicIntInput, _int]]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class MarketUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MarketCreateWithoutRelationsInput']
    connect: List['MarketWhereUniqueInput']
    connect_or_create: List['MarketConnectOrCreateWithoutRelationsInput']
    set: List['MarketWhereUniqueInput']
    disconnect: List['MarketWhereUniqueInput']
    delete: List['MarketWhereUniqueInput']

    # TODO
    # update: List['MarketUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MarketUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MarketScalarWhereInput']
    # upsert: List['MarketUpserteWithWhereUniqueWithoutRelationsInput']


class MarketUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MarketCreateWithoutRelationsInput'
    connect: 'MarketWhereUniqueInput'
    connect_or_create: 'MarketConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MarketUpdateInput'
    # upsert: 'MarketUpsertWithoutRelationsInput'


class MarketUpsertInput(TypedDict):
    create: 'MarketCreateInput'
    update: 'MarketUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Market_id_OrderByInput = TypedDict(
    '_Market_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Market_conditionId_OrderByInput = TypedDict(
    '_Market_conditionId_OrderByInput',
    {
        'conditionId': 'SortOrder',
    },
    total=True
)

_Market_questionID_OrderByInput = TypedDict(
    '_Market_questionID_OrderByInput',
    {
        'questionID': 'SortOrder',
    },
    total=True
)

_Market_slug_OrderByInput = TypedDict(
    '_Market_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Market_question_OrderByInput = TypedDict(
    '_Market_question_OrderByInput',
    {
        'question': 'SortOrder',
    },
    total=True
)

_Market_description_OrderByInput = TypedDict(
    '_Market_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Market_category_OrderByInput = TypedDict(
    '_Market_category_OrderByInput',
    {
        'category': 'SortOrder',
    },
    total=True
)

_Market_image_OrderByInput = TypedDict(
    '_Market_image_OrderByInput',
    {
        'image': 'SortOrder',
    },
    total=True
)

_Market_icon_OrderByInput = TypedDict(
    '_Market_icon_OrderByInput',
    {
        'icon': 'SortOrder',
    },
    total=True
)

_Market_resolutionSource_OrderByInput = TypedDict(
    '_Market_resolutionSource_OrderByInput',
    {
        'resolutionSource': 'SortOrder',
    },
    total=True
)

_Market_startDate_OrderByInput = TypedDict(
    '_Market_startDate_OrderByInput',
    {
        'startDate': 'SortOrder',
    },
    total=True
)

_Market_endDate_OrderByInput = TypedDict(
    '_Market_endDate_OrderByInput',
    {
        'endDate': 'SortOrder',
    },
    total=True
)

_Market_createdAt_OrderByInput = TypedDict(
    '_Market_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Market_updatedAt_OrderByInput = TypedDict(
    '_Market_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Market_closedTime_OrderByInput = TypedDict(
    '_Market_closedTime_OrderByInput',
    {
        'closedTime': 'SortOrder',
    },
    total=True
)

_Market_active_OrderByInput = TypedDict(
    '_Market_active_OrderByInput',
    {
        'active': 'SortOrder',
    },
    total=True
)

_Market_closed_OrderByInput = TypedDict(
    '_Market_closed_OrderByInput',
    {
        'closed': 'SortOrder',
    },
    total=True
)

_Market_archived_OrderByInput = TypedDict(
    '_Market_archived_OrderByInput',
    {
        'archived': 'SortOrder',
    },
    total=True
)

_Market_new_OrderByInput = TypedDict(
    '_Market_new_OrderByInput',
    {
        'new': 'SortOrder',
    },
    total=True
)

_Market_marketType_OrderByInput = TypedDict(
    '_Market_marketType_OrderByInput',
    {
        'marketType': 'SortOrder',
    },
    total=True
)

_Market_formatType_OrderByInput = TypedDict(
    '_Market_formatType_OrderByInput',
    {
        'formatType': 'SortOrder',
    },
    total=True
)

_Market_ammType_OrderByInput = TypedDict(
    '_Market_ammType_OrderByInput',
    {
        'ammType': 'SortOrder',
    },
    total=True
)

_Market_volume_OrderByInput = TypedDict(
    '_Market_volume_OrderByInput',
    {
        'volume': 'SortOrder',
    },
    total=True
)

_Market_volumeNum_OrderByInput = TypedDict(
    '_Market_volumeNum_OrderByInput',
    {
        'volumeNum': 'SortOrder',
    },
    total=True
)

_Market_volume24hr_OrderByInput = TypedDict(
    '_Market_volume24hr_OrderByInput',
    {
        'volume24hr': 'SortOrder',
    },
    total=True
)

_Market_volume1wk_OrderByInput = TypedDict(
    '_Market_volume1wk_OrderByInput',
    {
        'volume1wk': 'SortOrder',
    },
    total=True
)

_Market_volume1mo_OrderByInput = TypedDict(
    '_Market_volume1mo_OrderByInput',
    {
        'volume1mo': 'SortOrder',
    },
    total=True
)

_Market_volume1yr_OrderByInput = TypedDict(
    '_Market_volume1yr_OrderByInput',
    {
        'volume1yr': 'SortOrder',
    },
    total=True
)

_Market_volumeAmm_OrderByInput = TypedDict(
    '_Market_volumeAmm_OrderByInput',
    {
        'volumeAmm': 'SortOrder',
    },
    total=True
)

_Market_volumeClob_OrderByInput = TypedDict(
    '_Market_volumeClob_OrderByInput',
    {
        'volumeClob': 'SortOrder',
    },
    total=True
)

_Market_volume24hrAmm_OrderByInput = TypedDict(
    '_Market_volume24hrAmm_OrderByInput',
    {
        'volume24hrAmm': 'SortOrder',
    },
    total=True
)

_Market_volume1wkAmm_OrderByInput = TypedDict(
    '_Market_volume1wkAmm_OrderByInput',
    {
        'volume1wkAmm': 'SortOrder',
    },
    total=True
)

_Market_volume1moAmm_OrderByInput = TypedDict(
    '_Market_volume1moAmm_OrderByInput',
    {
        'volume1moAmm': 'SortOrder',
    },
    total=True
)

_Market_volume1yrAmm_OrderByInput = TypedDict(
    '_Market_volume1yrAmm_OrderByInput',
    {
        'volume1yrAmm': 'SortOrder',
    },
    total=True
)

_Market_volume24hrClob_OrderByInput = TypedDict(
    '_Market_volume24hrClob_OrderByInput',
    {
        'volume24hrClob': 'SortOrder',
    },
    total=True
)

_Market_volume1wkClob_OrderByInput = TypedDict(
    '_Market_volume1wkClob_OrderByInput',
    {
        'volume1wkClob': 'SortOrder',
    },
    total=True
)

_Market_volume1moClob_OrderByInput = TypedDict(
    '_Market_volume1moClob_OrderByInput',
    {
        'volume1moClob': 'SortOrder',
    },
    total=True
)

_Market_volume1yrClob_OrderByInput = TypedDict(
    '_Market_volume1yrClob_OrderByInput',
    {
        'volume1yrClob': 'SortOrder',
    },
    total=True
)

_Market_liquidity_OrderByInput = TypedDict(
    '_Market_liquidity_OrderByInput',
    {
        'liquidity': 'SortOrder',
    },
    total=True
)

_Market_liquidityNum_OrderByInput = TypedDict(
    '_Market_liquidityNum_OrderByInput',
    {
        'liquidityNum': 'SortOrder',
    },
    total=True
)

_Market_liquidityAmm_OrderByInput = TypedDict(
    '_Market_liquidityAmm_OrderByInput',
    {
        'liquidityAmm': 'SortOrder',
    },
    total=True
)

_Market_liquidityClob_OrderByInput = TypedDict(
    '_Market_liquidityClob_OrderByInput',
    {
        'liquidityClob': 'SortOrder',
    },
    total=True
)

_Market_oneDayPriceChange_OrderByInput = TypedDict(
    '_Market_oneDayPriceChange_OrderByInput',
    {
        'oneDayPriceChange': 'SortOrder',
    },
    total=True
)

_Market_oneHourPriceChange_OrderByInput = TypedDict(
    '_Market_oneHourPriceChange_OrderByInput',
    {
        'oneHourPriceChange': 'SortOrder',
    },
    total=True
)

_Market_oneWeekPriceChange_OrderByInput = TypedDict(
    '_Market_oneWeekPriceChange_OrderByInput',
    {
        'oneWeekPriceChange': 'SortOrder',
    },
    total=True
)

_Market_oneMonthPriceChange_OrderByInput = TypedDict(
    '_Market_oneMonthPriceChange_OrderByInput',
    {
        'oneMonthPriceChange': 'SortOrder',
    },
    total=True
)

_Market_oneYearPriceChange_OrderByInput = TypedDict(
    '_Market_oneYearPriceChange_OrderByInput',
    {
        'oneYearPriceChange': 'SortOrder',
    },
    total=True
)

_Market_lastTradePrice_OrderByInput = TypedDict(
    '_Market_lastTradePrice_OrderByInput',
    {
        'lastTradePrice': 'SortOrder',
    },
    total=True
)

_Market_bestBid_OrderByInput = TypedDict(
    '_Market_bestBid_OrderByInput',
    {
        'bestBid': 'SortOrder',
    },
    total=True
)

_Market_bestAsk_OrderByInput = TypedDict(
    '_Market_bestAsk_OrderByInput',
    {
        'bestAsk': 'SortOrder',
    },
    total=True
)

_Market_spread_OrderByInput = TypedDict(
    '_Market_spread_OrderByInput',
    {
        'spread': 'SortOrder',
    },
    total=True
)

_Market_enableOrderBook_OrderByInput = TypedDict(
    '_Market_enableOrderBook_OrderByInput',
    {
        'enableOrderBook': 'SortOrder',
    },
    total=True
)

_Market_fee_OrderByInput = TypedDict(
    '_Market_fee_OrderByInput',
    {
        'fee': 'SortOrder',
    },
    total=True
)

_Market_makerBaseFee_OrderByInput = TypedDict(
    '_Market_makerBaseFee_OrderByInput',
    {
        'makerBaseFee': 'SortOrder',
    },
    total=True
)

_Market_takerBaseFee_OrderByInput = TypedDict(
    '_Market_takerBaseFee_OrderByInput',
    {
        'takerBaseFee': 'SortOrder',
    },
    total=True
)

_Market_denominationToken_OrderByInput = TypedDict(
    '_Market_denominationToken_OrderByInput',
    {
        'denominationToken': 'SortOrder',
    },
    total=True
)

_Market_marketMakerAddress_OrderByInput = TypedDict(
    '_Market_marketMakerAddress_OrderByInput',
    {
        'marketMakerAddress': 'SortOrder',
    },
    total=True
)

_Market_clobTokenIds_OrderByInput = TypedDict(
    '_Market_clobTokenIds_OrderByInput',
    {
        'clobTokenIds': 'SortOrder',
    },
    total=True
)

_Market_createdBy_OrderByInput = TypedDict(
    '_Market_createdBy_OrderByInput',
    {
        'createdBy': 'SortOrder',
    },
    total=True
)

_Market_updatedBy_OrderByInput = TypedDict(
    '_Market_updatedBy_OrderByInput',
    {
        'updatedBy': 'SortOrder',
    },
    total=True
)

_Market_creator_OrderByInput = TypedDict(
    '_Market_creator_OrderByInput',
    {
        'creator': 'SortOrder',
    },
    total=True
)

_Market_marketGroup_OrderByInput = TypedDict(
    '_Market_marketGroup_OrderByInput',
    {
        'marketGroup': 'SortOrder',
    },
    total=True
)

_Market_groupItemTitle_OrderByInput = TypedDict(
    '_Market_groupItemTitle_OrderByInput',
    {
        'groupItemTitle': 'SortOrder',
    },
    total=True
)

_Market_groupItemThreshold_OrderByInput = TypedDict(
    '_Market_groupItemThreshold_OrderByInput',
    {
        'groupItemThreshold': 'SortOrder',
    },
    total=True
)

_Market_groupItemRange_OrderByInput = TypedDict(
    '_Market_groupItemRange_OrderByInput',
    {
        'groupItemRange': 'SortOrder',
    },
    total=True
)

_Market_curationOrder_OrderByInput = TypedDict(
    '_Market_curationOrder_OrderByInput',
    {
        'curationOrder': 'SortOrder',
    },
    total=True
)

_Market_score_OrderByInput = TypedDict(
    '_Market_score_OrderByInput',
    {
        'score': 'SortOrder',
    },
    total=True
)

_Market_mailchimpTag_OrderByInput = TypedDict(
    '_Market_mailchimpTag_OrderByInput',
    {
        'mailchimpTag': 'SortOrder',
    },
    total=True
)

_Market_outcomes_OrderByInput = TypedDict(
    '_Market_outcomes_OrderByInput',
    {
        'outcomes': 'SortOrder',
    },
    total=True
)

_Market_outcomePrices_OrderByInput = TypedDict(
    '_Market_outcomePrices_OrderByInput',
    {
        'outcomePrices': 'SortOrder',
    },
    total=True
)

_Market_shortOutcomes_OrderByInput = TypedDict(
    '_Market_shortOutcomes_OrderByInput',
    {
        'shortOutcomes': 'SortOrder',
    },
    total=True
)

_Market_readyTimestamp_OrderByInput = TypedDict(
    '_Market_readyTimestamp_OrderByInput',
    {
        'readyTimestamp': 'SortOrder',
    },
    total=True
)

_Market_fundedTimestamp_OrderByInput = TypedDict(
    '_Market_fundedTimestamp_OrderByInput',
    {
        'fundedTimestamp': 'SortOrder',
    },
    total=True
)

_Market_acceptingOrdersTimestamp_OrderByInput = TypedDict(
    '_Market_acceptingOrdersTimestamp_OrderByInput',
    {
        'acceptingOrdersTimestamp': 'SortOrder',
    },
    total=True
)

_Market_deployingTimestamp_OrderByInput = TypedDict(
    '_Market_deployingTimestamp_OrderByInput',
    {
        'deployingTimestamp': 'SortOrder',
    },
    total=True
)

_Market_scheduledDeploymentTimestamp_OrderByInput = TypedDict(
    '_Market_scheduledDeploymentTimestamp_OrderByInput',
    {
        'scheduledDeploymentTimestamp': 'SortOrder',
    },
    total=True
)

_Market_gameId_OrderByInput = TypedDict(
    '_Market_gameId_OrderByInput',
    {
        'gameId': 'SortOrder',
    },
    total=True
)

_Market_teamAID_OrderByInput = TypedDict(
    '_Market_teamAID_OrderByInput',
    {
        'teamAID': 'SortOrder',
    },
    total=True
)

_Market_teamBID_OrderByInput = TypedDict(
    '_Market_teamBID_OrderByInput',
    {
        'teamBID': 'SortOrder',
    },
    total=True
)

_Market_sportsMarketType_OrderByInput = TypedDict(
    '_Market_sportsMarketType_OrderByInput',
    {
        'sportsMarketType': 'SortOrder',
    },
    total=True
)

_Market_line_OrderByInput = TypedDict(
    '_Market_line_OrderByInput',
    {
        'line': 'SortOrder',
    },
    total=True
)

_Market_umaBond_OrderByInput = TypedDict(
    '_Market_umaBond_OrderByInput',
    {
        'umaBond': 'SortOrder',
    },
    total=True
)

_Market_umaReward_OrderByInput = TypedDict(
    '_Market_umaReward_OrderByInput',
    {
        'umaReward': 'SortOrder',
    },
    total=True
)

_Market_customLiveness_OrderByInput = TypedDict(
    '_Market_customLiveness_OrderByInput',
    {
        'customLiveness': 'SortOrder',
    },
    total=True
)

_Market_scrapedAt_OrderByInput = TypedDict(
    '_Market_scrapedAt_OrderByInput',
    {
        'scrapedAt': 'SortOrder',
    },
    total=True
)

_Market_createdInDb_OrderByInput = TypedDict(
    '_Market_createdInDb_OrderByInput',
    {
        'createdInDb': 'SortOrder',
    },
    total=True
)

_Market_RelevanceInner = TypedDict(
    '_Market_RelevanceInner',
    {
        'fields': 'List[MarketScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Market_RelevanceOrderByInput = TypedDict(
    '_Market_RelevanceOrderByInput',
    {
        '_relevance': '_Market_RelevanceInner',
    },
    total=True
)

MarketOrderByInput = Union[
    '_Market_id_OrderByInput',
    '_Market_conditionId_OrderByInput',
    '_Market_questionID_OrderByInput',
    '_Market_slug_OrderByInput',
    '_Market_question_OrderByInput',
    '_Market_description_OrderByInput',
    '_Market_category_OrderByInput',
    '_Market_image_OrderByInput',
    '_Market_icon_OrderByInput',
    '_Market_resolutionSource_OrderByInput',
    '_Market_startDate_OrderByInput',
    '_Market_endDate_OrderByInput',
    '_Market_createdAt_OrderByInput',
    '_Market_updatedAt_OrderByInput',
    '_Market_closedTime_OrderByInput',
    '_Market_active_OrderByInput',
    '_Market_closed_OrderByInput',
    '_Market_archived_OrderByInput',
    '_Market_new_OrderByInput',
    '_Market_marketType_OrderByInput',
    '_Market_formatType_OrderByInput',
    '_Market_ammType_OrderByInput',
    '_Market_volume_OrderByInput',
    '_Market_volumeNum_OrderByInput',
    '_Market_volume24hr_OrderByInput',
    '_Market_volume1wk_OrderByInput',
    '_Market_volume1mo_OrderByInput',
    '_Market_volume1yr_OrderByInput',
    '_Market_volumeAmm_OrderByInput',
    '_Market_volumeClob_OrderByInput',
    '_Market_volume24hrAmm_OrderByInput',
    '_Market_volume1wkAmm_OrderByInput',
    '_Market_volume1moAmm_OrderByInput',
    '_Market_volume1yrAmm_OrderByInput',
    '_Market_volume24hrClob_OrderByInput',
    '_Market_volume1wkClob_OrderByInput',
    '_Market_volume1moClob_OrderByInput',
    '_Market_volume1yrClob_OrderByInput',
    '_Market_liquidity_OrderByInput',
    '_Market_liquidityNum_OrderByInput',
    '_Market_liquidityAmm_OrderByInput',
    '_Market_liquidityClob_OrderByInput',
    '_Market_oneDayPriceChange_OrderByInput',
    '_Market_oneHourPriceChange_OrderByInput',
    '_Market_oneWeekPriceChange_OrderByInput',
    '_Market_oneMonthPriceChange_OrderByInput',
    '_Market_oneYearPriceChange_OrderByInput',
    '_Market_lastTradePrice_OrderByInput',
    '_Market_bestBid_OrderByInput',
    '_Market_bestAsk_OrderByInput',
    '_Market_spread_OrderByInput',
    '_Market_enableOrderBook_OrderByInput',
    '_Market_fee_OrderByInput',
    '_Market_makerBaseFee_OrderByInput',
    '_Market_takerBaseFee_OrderByInput',
    '_Market_denominationToken_OrderByInput',
    '_Market_marketMakerAddress_OrderByInput',
    '_Market_clobTokenIds_OrderByInput',
    '_Market_createdBy_OrderByInput',
    '_Market_updatedBy_OrderByInput',
    '_Market_creator_OrderByInput',
    '_Market_marketGroup_OrderByInput',
    '_Market_groupItemTitle_OrderByInput',
    '_Market_groupItemThreshold_OrderByInput',
    '_Market_groupItemRange_OrderByInput',
    '_Market_curationOrder_OrderByInput',
    '_Market_score_OrderByInput',
    '_Market_mailchimpTag_OrderByInput',
    '_Market_outcomes_OrderByInput',
    '_Market_outcomePrices_OrderByInput',
    '_Market_shortOutcomes_OrderByInput',
    '_Market_readyTimestamp_OrderByInput',
    '_Market_fundedTimestamp_OrderByInput',
    '_Market_acceptingOrdersTimestamp_OrderByInput',
    '_Market_deployingTimestamp_OrderByInput',
    '_Market_scheduledDeploymentTimestamp_OrderByInput',
    '_Market_gameId_OrderByInput',
    '_Market_teamAID_OrderByInput',
    '_Market_teamBID_OrderByInput',
    '_Market_sportsMarketType_OrderByInput',
    '_Market_line_OrderByInput',
    '_Market_umaBond_OrderByInput',
    '_Market_umaReward_OrderByInput',
    '_Market_customLiveness_OrderByInput',
    '_Market_scrapedAt_OrderByInput',
    '_Market_createdInDb_OrderByInput',
    '_Market_RelevanceOrderByInput',
]



# recursive Market types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MarketRelationFilter = TypedDict(
    'MarketRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MarketListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MarketInclude(TypedDict, total=False):
    """Market relational arguments"""
    events: Union[bool, 'FindManyEventArgsFromMarket']
    tags: Union[bool, 'FindManyTagArgsFromMarket']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarket']


    

class EventIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketRecursive1']


class EventIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketRecursive2']


class EventIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketRecursive3']


class EventIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketRecursive4']


class EventIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class EventArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyEventArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    events: Union[bool, 'FindManyEventArgsFromMarketRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketRecursive1']


class MarketIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    events: Union[bool, 'FindManyEventArgsFromMarketRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketRecursive2']


class MarketIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    events: Union[bool, 'FindManyEventArgsFromMarketRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketRecursive3']


class MarketIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    events: Union[bool, 'FindManyEventArgsFromMarketRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromMarketRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketRecursive4']


class MarketIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class MarketArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyMarketArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    market: Union[bool, 'MarketArgsFromMarketRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketRecursive1']


class MarketOutcomeIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    market: Union[bool, 'MarketArgsFromMarketRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketRecursive2']


class MarketOutcomeIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    market: Union[bool, 'MarketArgsFromMarketRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketRecursive3']


class MarketOutcomeIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    market: Union[bool, 'MarketArgsFromMarketRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketRecursive4']


class MarketOutcomeIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class MarketOutcomeArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyMarketOutcomeArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromMarketRecursive1']


class TagIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromMarketRecursive2']


class TagIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromMarketRecursive3']


class TagIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromMarketRecursive4']


class TagIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class TagArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyTagArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    profile: Union[bool, 'UserProfileArgsFromMarketRecursive1']
    event: Union[bool, 'EventArgsFromMarketRecursive1']
    parentComment: Union[bool, 'CommentArgsFromMarketRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketRecursive1']


class CommentIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    profile: Union[bool, 'UserProfileArgsFromMarketRecursive2']
    event: Union[bool, 'EventArgsFromMarketRecursive2']
    parentComment: Union[bool, 'CommentArgsFromMarketRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketRecursive2']


class CommentIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    profile: Union[bool, 'UserProfileArgsFromMarketRecursive3']
    event: Union[bool, 'EventArgsFromMarketRecursive3']
    parentComment: Union[bool, 'CommentArgsFromMarketRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketRecursive3']


class CommentIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    profile: Union[bool, 'UserProfileArgsFromMarketRecursive4']
    event: Union[bool, 'EventArgsFromMarketRecursive4']
    parentComment: Union[bool, 'CommentArgsFromMarketRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketRecursive4']


class CommentIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class CommentArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyCommentArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    comment: Union[bool, 'CommentArgsFromMarketRecursive1']


class CommentReactionIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    comment: Union[bool, 'CommentArgsFromMarketRecursive2']


class CommentReactionIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    comment: Union[bool, 'CommentArgsFromMarketRecursive3']


class CommentReactionIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    comment: Union[bool, 'CommentArgsFromMarketRecursive4']


class CommentReactionIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class CommentReactionArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyCommentReactionArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive1']


class UserProfileIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive2']


class UserProfileIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive3']


class UserProfileIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketRecursive4']


class UserProfileIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class UserProfileArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyUserProfileArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    event: Union[bool, 'EventArgsFromMarketRecursive1']


class CommentCheckpointIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    event: Union[bool, 'EventArgsFromMarketRecursive2']


class CommentCheckpointIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    event: Union[bool, 'EventArgsFromMarketRecursive3']


class CommentCheckpointIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    event: Union[bool, 'EventArgsFromMarketRecursive4']


class CommentCheckpointIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class CommentCheckpointArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyCommentCheckpointArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketRecursive1']


class TokenPriceIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketRecursive2']


class TokenPriceIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketRecursive3']


class TokenPriceIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketRecursive4']


class TokenPriceIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class TokenPriceArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyTokenPriceArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromMarket(TypedDict, total=False):
    """Relational arguments for Market"""


class ScraperRunIncludeFromMarketRecursive1(TypedDict, total=False):
    """Relational arguments for Market"""


class ScraperRunIncludeFromMarketRecursive2(TypedDict, total=False):
    """Relational arguments for Market"""


class ScraperRunIncludeFromMarketRecursive3(TypedDict, total=False):
    """Relational arguments for Market"""


class ScraperRunIncludeFromMarketRecursive4(TypedDict, total=False):
    """Relational arguments for Market"""

    

class ScraperRunArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    
    

class FindManyScraperRunArgsFromMarket(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromMarketRecursive1(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromMarketRecursive2(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromMarketRecursive3(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromMarketRecursive4(TypedDict, total=False):
    """Arguments for Market"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyMarketArgs = FindManyMarketArgsFromMarket
FindFirstMarketArgs = FindManyMarketArgsFromMarket


    

class MarketWhereInput(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    conditionId: Union[None, _str, 'types.StringFilter']
    questionID: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    question: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    marketType: Union[None, _str, 'types.StringFilter']
    formatType: Union[None, _str, 'types.StringFilter']
    ammType: Union[None, _str, 'types.StringFilter']
    volume: Union[None, _str, 'types.StringFilter']
    volumeNum: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    volumeAmm: Union[None, _float, 'types.FloatFilter']
    volumeClob: Union[None, _float, 'types.FloatFilter']
    volume24hrAmm: Union[None, _float, 'types.FloatFilter']
    volume1wkAmm: Union[None, _float, 'types.FloatFilter']
    volume1moAmm: Union[None, _float, 'types.FloatFilter']
    volume1yrAmm: Union[None, _float, 'types.FloatFilter']
    volume24hrClob: Union[None, _float, 'types.FloatFilter']
    volume1wkClob: Union[None, _float, 'types.FloatFilter']
    volume1moClob: Union[None, _float, 'types.FloatFilter']
    volume1yrClob: Union[None, _float, 'types.FloatFilter']
    liquidity: Union[None, _str, 'types.StringFilter']
    liquidityNum: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    oneDayPriceChange: Union[None, _float, 'types.FloatFilter']
    oneHourPriceChange: Union[None, _float, 'types.FloatFilter']
    oneWeekPriceChange: Union[None, _float, 'types.FloatFilter']
    oneMonthPriceChange: Union[None, _float, 'types.FloatFilter']
    oneYearPriceChange: Union[None, _float, 'types.FloatFilter']
    lastTradePrice: Union[None, _float, 'types.FloatFilter']
    bestBid: Union[None, _float, 'types.FloatFilter']
    bestAsk: Union[None, _float, 'types.FloatFilter']
    spread: Union[None, _float, 'types.FloatFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    fee: Union[None, _str, 'types.StringFilter']
    makerBaseFee: Union[None, _float, 'types.FloatFilter']
    takerBaseFee: Union[None, _float, 'types.FloatFilter']
    denominationToken: Union[None, _str, 'types.StringFilter']
    marketMakerAddress: Union[None, _str, 'types.StringFilter']
    clobTokenIds: 'types.StringListFilter'
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    creator: Union[None, _str, 'types.StringFilter']
    marketGroup: Union[None, _int, 'types.IntFilter']
    groupItemTitle: Union[None, _str, 'types.StringFilter']
    groupItemThreshold: Union[None, _str, 'types.StringFilter']
    groupItemRange: Union[None, _str, 'types.StringFilter']
    curationOrder: Union[None, _int, 'types.IntFilter']
    score: Union[None, _float, 'types.FloatFilter']
    mailchimpTag: Union[None, _str, 'types.StringFilter']
    outcomes: Union[None, _str, 'types.StringFilter']
    outcomePrices: Union[None, _str, 'types.StringFilter']
    shortOutcomes: Union[None, _str, 'types.StringFilter']
    readyTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    fundedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    acceptingOrdersTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameId: Union[None, _str, 'types.StringFilter']
    teamAID: Union[None, _str, 'types.StringFilter']
    teamBID: Union[None, _str, 'types.StringFilter']
    sportsMarketType: Union[None, _str, 'types.StringFilter']
    line: Union[None, _float, 'types.FloatFilter']
    umaBond: Union[None, _str, 'types.StringFilter']
    umaReward: Union[None, _str, 'types.StringFilter']
    customLiveness: Union[None, _int, 'types.IntFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    events: 'EventListRelationFilter'
    tags: 'TagListRelationFilter'
    marketOutcomes: 'MarketOutcomeListRelationFilter'

    # should be noted that AND and NOT should be Union['MarketWhereInputRecursive1', List['MarketWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MarketWhereInputRecursive1']
    OR: List['MarketWhereInputRecursive1']
    NOT: List['MarketWhereInputRecursive1']


class MarketWhereInputRecursive1(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    conditionId: Union[None, _str, 'types.StringFilter']
    questionID: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    question: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    marketType: Union[None, _str, 'types.StringFilter']
    formatType: Union[None, _str, 'types.StringFilter']
    ammType: Union[None, _str, 'types.StringFilter']
    volume: Union[None, _str, 'types.StringFilter']
    volumeNum: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    volumeAmm: Union[None, _float, 'types.FloatFilter']
    volumeClob: Union[None, _float, 'types.FloatFilter']
    volume24hrAmm: Union[None, _float, 'types.FloatFilter']
    volume1wkAmm: Union[None, _float, 'types.FloatFilter']
    volume1moAmm: Union[None, _float, 'types.FloatFilter']
    volume1yrAmm: Union[None, _float, 'types.FloatFilter']
    volume24hrClob: Union[None, _float, 'types.FloatFilter']
    volume1wkClob: Union[None, _float, 'types.FloatFilter']
    volume1moClob: Union[None, _float, 'types.FloatFilter']
    volume1yrClob: Union[None, _float, 'types.FloatFilter']
    liquidity: Union[None, _str, 'types.StringFilter']
    liquidityNum: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    oneDayPriceChange: Union[None, _float, 'types.FloatFilter']
    oneHourPriceChange: Union[None, _float, 'types.FloatFilter']
    oneWeekPriceChange: Union[None, _float, 'types.FloatFilter']
    oneMonthPriceChange: Union[None, _float, 'types.FloatFilter']
    oneYearPriceChange: Union[None, _float, 'types.FloatFilter']
    lastTradePrice: Union[None, _float, 'types.FloatFilter']
    bestBid: Union[None, _float, 'types.FloatFilter']
    bestAsk: Union[None, _float, 'types.FloatFilter']
    spread: Union[None, _float, 'types.FloatFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    fee: Union[None, _str, 'types.StringFilter']
    makerBaseFee: Union[None, _float, 'types.FloatFilter']
    takerBaseFee: Union[None, _float, 'types.FloatFilter']
    denominationToken: Union[None, _str, 'types.StringFilter']
    marketMakerAddress: Union[None, _str, 'types.StringFilter']
    clobTokenIds: 'types.StringListFilter'
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    creator: Union[None, _str, 'types.StringFilter']
    marketGroup: Union[None, _int, 'types.IntFilter']
    groupItemTitle: Union[None, _str, 'types.StringFilter']
    groupItemThreshold: Union[None, _str, 'types.StringFilter']
    groupItemRange: Union[None, _str, 'types.StringFilter']
    curationOrder: Union[None, _int, 'types.IntFilter']
    score: Union[None, _float, 'types.FloatFilter']
    mailchimpTag: Union[None, _str, 'types.StringFilter']
    outcomes: Union[None, _str, 'types.StringFilter']
    outcomePrices: Union[None, _str, 'types.StringFilter']
    shortOutcomes: Union[None, _str, 'types.StringFilter']
    readyTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    fundedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    acceptingOrdersTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameId: Union[None, _str, 'types.StringFilter']
    teamAID: Union[None, _str, 'types.StringFilter']
    teamBID: Union[None, _str, 'types.StringFilter']
    sportsMarketType: Union[None, _str, 'types.StringFilter']
    line: Union[None, _float, 'types.FloatFilter']
    umaBond: Union[None, _str, 'types.StringFilter']
    umaReward: Union[None, _str, 'types.StringFilter']
    customLiveness: Union[None, _int, 'types.IntFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    events: 'EventListRelationFilter'
    tags: 'TagListRelationFilter'
    marketOutcomes: 'MarketOutcomeListRelationFilter'

    # should be noted that AND and NOT should be Union['MarketWhereInputRecursive2', List['MarketWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MarketWhereInputRecursive2']
    OR: List['MarketWhereInputRecursive2']
    NOT: List['MarketWhereInputRecursive2']


class MarketWhereInputRecursive2(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    conditionId: Union[None, _str, 'types.StringFilter']
    questionID: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    question: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    marketType: Union[None, _str, 'types.StringFilter']
    formatType: Union[None, _str, 'types.StringFilter']
    ammType: Union[None, _str, 'types.StringFilter']
    volume: Union[None, _str, 'types.StringFilter']
    volumeNum: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    volumeAmm: Union[None, _float, 'types.FloatFilter']
    volumeClob: Union[None, _float, 'types.FloatFilter']
    volume24hrAmm: Union[None, _float, 'types.FloatFilter']
    volume1wkAmm: Union[None, _float, 'types.FloatFilter']
    volume1moAmm: Union[None, _float, 'types.FloatFilter']
    volume1yrAmm: Union[None, _float, 'types.FloatFilter']
    volume24hrClob: Union[None, _float, 'types.FloatFilter']
    volume1wkClob: Union[None, _float, 'types.FloatFilter']
    volume1moClob: Union[None, _float, 'types.FloatFilter']
    volume1yrClob: Union[None, _float, 'types.FloatFilter']
    liquidity: Union[None, _str, 'types.StringFilter']
    liquidityNum: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    oneDayPriceChange: Union[None, _float, 'types.FloatFilter']
    oneHourPriceChange: Union[None, _float, 'types.FloatFilter']
    oneWeekPriceChange: Union[None, _float, 'types.FloatFilter']
    oneMonthPriceChange: Union[None, _float, 'types.FloatFilter']
    oneYearPriceChange: Union[None, _float, 'types.FloatFilter']
    lastTradePrice: Union[None, _float, 'types.FloatFilter']
    bestBid: Union[None, _float, 'types.FloatFilter']
    bestAsk: Union[None, _float, 'types.FloatFilter']
    spread: Union[None, _float, 'types.FloatFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    fee: Union[None, _str, 'types.StringFilter']
    makerBaseFee: Union[None, _float, 'types.FloatFilter']
    takerBaseFee: Union[None, _float, 'types.FloatFilter']
    denominationToken: Union[None, _str, 'types.StringFilter']
    marketMakerAddress: Union[None, _str, 'types.StringFilter']
    clobTokenIds: 'types.StringListFilter'
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    creator: Union[None, _str, 'types.StringFilter']
    marketGroup: Union[None, _int, 'types.IntFilter']
    groupItemTitle: Union[None, _str, 'types.StringFilter']
    groupItemThreshold: Union[None, _str, 'types.StringFilter']
    groupItemRange: Union[None, _str, 'types.StringFilter']
    curationOrder: Union[None, _int, 'types.IntFilter']
    score: Union[None, _float, 'types.FloatFilter']
    mailchimpTag: Union[None, _str, 'types.StringFilter']
    outcomes: Union[None, _str, 'types.StringFilter']
    outcomePrices: Union[None, _str, 'types.StringFilter']
    shortOutcomes: Union[None, _str, 'types.StringFilter']
    readyTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    fundedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    acceptingOrdersTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameId: Union[None, _str, 'types.StringFilter']
    teamAID: Union[None, _str, 'types.StringFilter']
    teamBID: Union[None, _str, 'types.StringFilter']
    sportsMarketType: Union[None, _str, 'types.StringFilter']
    line: Union[None, _float, 'types.FloatFilter']
    umaBond: Union[None, _str, 'types.StringFilter']
    umaReward: Union[None, _str, 'types.StringFilter']
    customLiveness: Union[None, _int, 'types.IntFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    events: 'EventListRelationFilter'
    tags: 'TagListRelationFilter'
    marketOutcomes: 'MarketOutcomeListRelationFilter'

    # should be noted that AND and NOT should be Union['MarketWhereInputRecursive3', List['MarketWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MarketWhereInputRecursive3']
    OR: List['MarketWhereInputRecursive3']
    NOT: List['MarketWhereInputRecursive3']


class MarketWhereInputRecursive3(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    conditionId: Union[None, _str, 'types.StringFilter']
    questionID: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    question: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    marketType: Union[None, _str, 'types.StringFilter']
    formatType: Union[None, _str, 'types.StringFilter']
    ammType: Union[None, _str, 'types.StringFilter']
    volume: Union[None, _str, 'types.StringFilter']
    volumeNum: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    volumeAmm: Union[None, _float, 'types.FloatFilter']
    volumeClob: Union[None, _float, 'types.FloatFilter']
    volume24hrAmm: Union[None, _float, 'types.FloatFilter']
    volume1wkAmm: Union[None, _float, 'types.FloatFilter']
    volume1moAmm: Union[None, _float, 'types.FloatFilter']
    volume1yrAmm: Union[None, _float, 'types.FloatFilter']
    volume24hrClob: Union[None, _float, 'types.FloatFilter']
    volume1wkClob: Union[None, _float, 'types.FloatFilter']
    volume1moClob: Union[None, _float, 'types.FloatFilter']
    volume1yrClob: Union[None, _float, 'types.FloatFilter']
    liquidity: Union[None, _str, 'types.StringFilter']
    liquidityNum: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    oneDayPriceChange: Union[None, _float, 'types.FloatFilter']
    oneHourPriceChange: Union[None, _float, 'types.FloatFilter']
    oneWeekPriceChange: Union[None, _float, 'types.FloatFilter']
    oneMonthPriceChange: Union[None, _float, 'types.FloatFilter']
    oneYearPriceChange: Union[None, _float, 'types.FloatFilter']
    lastTradePrice: Union[None, _float, 'types.FloatFilter']
    bestBid: Union[None, _float, 'types.FloatFilter']
    bestAsk: Union[None, _float, 'types.FloatFilter']
    spread: Union[None, _float, 'types.FloatFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    fee: Union[None, _str, 'types.StringFilter']
    makerBaseFee: Union[None, _float, 'types.FloatFilter']
    takerBaseFee: Union[None, _float, 'types.FloatFilter']
    denominationToken: Union[None, _str, 'types.StringFilter']
    marketMakerAddress: Union[None, _str, 'types.StringFilter']
    clobTokenIds: 'types.StringListFilter'
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    creator: Union[None, _str, 'types.StringFilter']
    marketGroup: Union[None, _int, 'types.IntFilter']
    groupItemTitle: Union[None, _str, 'types.StringFilter']
    groupItemThreshold: Union[None, _str, 'types.StringFilter']
    groupItemRange: Union[None, _str, 'types.StringFilter']
    curationOrder: Union[None, _int, 'types.IntFilter']
    score: Union[None, _float, 'types.FloatFilter']
    mailchimpTag: Union[None, _str, 'types.StringFilter']
    outcomes: Union[None, _str, 'types.StringFilter']
    outcomePrices: Union[None, _str, 'types.StringFilter']
    shortOutcomes: Union[None, _str, 'types.StringFilter']
    readyTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    fundedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    acceptingOrdersTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameId: Union[None, _str, 'types.StringFilter']
    teamAID: Union[None, _str, 'types.StringFilter']
    teamBID: Union[None, _str, 'types.StringFilter']
    sportsMarketType: Union[None, _str, 'types.StringFilter']
    line: Union[None, _float, 'types.FloatFilter']
    umaBond: Union[None, _str, 'types.StringFilter']
    umaReward: Union[None, _str, 'types.StringFilter']
    customLiveness: Union[None, _int, 'types.IntFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    events: 'EventListRelationFilter'
    tags: 'TagListRelationFilter'
    marketOutcomes: 'MarketOutcomeListRelationFilter'

    # should be noted that AND and NOT should be Union['MarketWhereInputRecursive4', List['MarketWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MarketWhereInputRecursive4']
    OR: List['MarketWhereInputRecursive4']
    NOT: List['MarketWhereInputRecursive4']


class MarketWhereInputRecursive4(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    conditionId: Union[None, _str, 'types.StringFilter']
    questionID: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    question: Union[None, _str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    category: Union[None, _str, 'types.StringFilter']
    image: Union[None, _str, 'types.StringFilter']
    icon: Union[None, _str, 'types.StringFilter']
    resolutionSource: Union[None, _str, 'types.StringFilter']
    startDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    endDate: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    closedTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    active: Union[None, _bool, 'types.BooleanFilter']
    closed: Union[None, _bool, 'types.BooleanFilter']
    archived: Union[None, _bool, 'types.BooleanFilter']
    new: Union[None, _bool, 'types.BooleanFilter']
    marketType: Union[None, _str, 'types.StringFilter']
    formatType: Union[None, _str, 'types.StringFilter']
    ammType: Union[None, _str, 'types.StringFilter']
    volume: Union[None, _str, 'types.StringFilter']
    volumeNum: Union[None, _float, 'types.FloatFilter']
    volume24hr: Union[None, _float, 'types.FloatFilter']
    volume1wk: Union[None, _float, 'types.FloatFilter']
    volume1mo: Union[None, _float, 'types.FloatFilter']
    volume1yr: Union[None, _float, 'types.FloatFilter']
    volumeAmm: Union[None, _float, 'types.FloatFilter']
    volumeClob: Union[None, _float, 'types.FloatFilter']
    volume24hrAmm: Union[None, _float, 'types.FloatFilter']
    volume1wkAmm: Union[None, _float, 'types.FloatFilter']
    volume1moAmm: Union[None, _float, 'types.FloatFilter']
    volume1yrAmm: Union[None, _float, 'types.FloatFilter']
    volume24hrClob: Union[None, _float, 'types.FloatFilter']
    volume1wkClob: Union[None, _float, 'types.FloatFilter']
    volume1moClob: Union[None, _float, 'types.FloatFilter']
    volume1yrClob: Union[None, _float, 'types.FloatFilter']
    liquidity: Union[None, _str, 'types.StringFilter']
    liquidityNum: Union[None, _float, 'types.FloatFilter']
    liquidityAmm: Union[None, _float, 'types.FloatFilter']
    liquidityClob: Union[None, _float, 'types.FloatFilter']
    oneDayPriceChange: Union[None, _float, 'types.FloatFilter']
    oneHourPriceChange: Union[None, _float, 'types.FloatFilter']
    oneWeekPriceChange: Union[None, _float, 'types.FloatFilter']
    oneMonthPriceChange: Union[None, _float, 'types.FloatFilter']
    oneYearPriceChange: Union[None, _float, 'types.FloatFilter']
    lastTradePrice: Union[None, _float, 'types.FloatFilter']
    bestBid: Union[None, _float, 'types.FloatFilter']
    bestAsk: Union[None, _float, 'types.FloatFilter']
    spread: Union[None, _float, 'types.FloatFilter']
    enableOrderBook: Union[None, _bool, 'types.BooleanFilter']
    fee: Union[None, _str, 'types.StringFilter']
    makerBaseFee: Union[None, _float, 'types.FloatFilter']
    takerBaseFee: Union[None, _float, 'types.FloatFilter']
    denominationToken: Union[None, _str, 'types.StringFilter']
    marketMakerAddress: Union[None, _str, 'types.StringFilter']
    clobTokenIds: 'types.StringListFilter'
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    creator: Union[None, _str, 'types.StringFilter']
    marketGroup: Union[None, _int, 'types.IntFilter']
    groupItemTitle: Union[None, _str, 'types.StringFilter']
    groupItemThreshold: Union[None, _str, 'types.StringFilter']
    groupItemRange: Union[None, _str, 'types.StringFilter']
    curationOrder: Union[None, _int, 'types.IntFilter']
    score: Union[None, _float, 'types.FloatFilter']
    mailchimpTag: Union[None, _str, 'types.StringFilter']
    outcomes: Union[None, _str, 'types.StringFilter']
    outcomePrices: Union[None, _str, 'types.StringFilter']
    shortOutcomes: Union[None, _str, 'types.StringFilter']
    readyTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    fundedTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    acceptingOrdersTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    deployingTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scheduledDeploymentTimestamp: Union[None, datetime.datetime, 'types.DateTimeFilter']
    gameId: Union[None, _str, 'types.StringFilter']
    teamAID: Union[None, _str, 'types.StringFilter']
    teamBID: Union[None, _str, 'types.StringFilter']
    sportsMarketType: Union[None, _str, 'types.StringFilter']
    line: Union[None, _float, 'types.FloatFilter']
    umaBond: Union[None, _str, 'types.StringFilter']
    umaReward: Union[None, _str, 'types.StringFilter']
    customLiveness: Union[None, _int, 'types.IntFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    events: 'EventListRelationFilter'
    tags: 'TagListRelationFilter'
    marketOutcomes: 'MarketOutcomeListRelationFilter'



# aggregate Market types


    

class MarketScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    conditionId: Union[_str, 'types.StringWithAggregatesFilter']
    questionID: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    marketType: Union[_str, 'types.StringWithAggregatesFilter']
    formatType: Union[_str, 'types.StringWithAggregatesFilter']
    ammType: Union[_str, 'types.StringWithAggregatesFilter']
    volume: Union[_str, 'types.StringWithAggregatesFilter']
    volumeNum: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidity: Union[_str, 'types.StringWithAggregatesFilter']
    liquidityNum: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    oneDayPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneHourPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneWeekPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneMonthPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneYearPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    lastTradePrice: Union[_float, 'types.FloatWithAggregatesFilter']
    bestBid: Union[_float, 'types.FloatWithAggregatesFilter']
    bestAsk: Union[_float, 'types.FloatWithAggregatesFilter']
    spread: Union[_float, 'types.FloatWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    fee: Union[_str, 'types.StringWithAggregatesFilter']
    makerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    takerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    denominationToken: Union[_str, 'types.StringWithAggregatesFilter']
    marketMakerAddress: Union[_str, 'types.StringWithAggregatesFilter']
    clobTokenIds: Union[_str, 'types.StringWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    creator: Union[_str, 'types.StringWithAggregatesFilter']
    marketGroup: Union[_int, 'types.IntWithAggregatesFilter']
    groupItemTitle: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemThreshold: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemRange: Union[_str, 'types.StringWithAggregatesFilter']
    curationOrder: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_float, 'types.FloatWithAggregatesFilter']
    mailchimpTag: Union[_str, 'types.StringWithAggregatesFilter']
    outcomes: Union[_str, 'types.StringWithAggregatesFilter']
    outcomePrices: Union[_str, 'types.StringWithAggregatesFilter']
    shortOutcomes: Union[_str, 'types.StringWithAggregatesFilter']
    readyTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    fundedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    acceptingOrdersTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameId: Union[_str, 'types.StringWithAggregatesFilter']
    teamAID: Union[_str, 'types.StringWithAggregatesFilter']
    teamBID: Union[_str, 'types.StringWithAggregatesFilter']
    sportsMarketType: Union[_str, 'types.StringWithAggregatesFilter']
    line: Union[_float, 'types.FloatWithAggregatesFilter']
    umaBond: Union[_str, 'types.StringWithAggregatesFilter']
    umaReward: Union[_str, 'types.StringWithAggregatesFilter']
    customLiveness: Union[_int, 'types.IntWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MarketScalarWhereWithAggregatesInputRecursive1']
    OR: List['MarketScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MarketScalarWhereWithAggregatesInputRecursive1']


class MarketScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    conditionId: Union[_str, 'types.StringWithAggregatesFilter']
    questionID: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    marketType: Union[_str, 'types.StringWithAggregatesFilter']
    formatType: Union[_str, 'types.StringWithAggregatesFilter']
    ammType: Union[_str, 'types.StringWithAggregatesFilter']
    volume: Union[_str, 'types.StringWithAggregatesFilter']
    volumeNum: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidity: Union[_str, 'types.StringWithAggregatesFilter']
    liquidityNum: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    oneDayPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneHourPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneWeekPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneMonthPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneYearPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    lastTradePrice: Union[_float, 'types.FloatWithAggregatesFilter']
    bestBid: Union[_float, 'types.FloatWithAggregatesFilter']
    bestAsk: Union[_float, 'types.FloatWithAggregatesFilter']
    spread: Union[_float, 'types.FloatWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    fee: Union[_str, 'types.StringWithAggregatesFilter']
    makerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    takerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    denominationToken: Union[_str, 'types.StringWithAggregatesFilter']
    marketMakerAddress: Union[_str, 'types.StringWithAggregatesFilter']
    clobTokenIds: Union[_str, 'types.StringWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    creator: Union[_str, 'types.StringWithAggregatesFilter']
    marketGroup: Union[_int, 'types.IntWithAggregatesFilter']
    groupItemTitle: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemThreshold: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemRange: Union[_str, 'types.StringWithAggregatesFilter']
    curationOrder: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_float, 'types.FloatWithAggregatesFilter']
    mailchimpTag: Union[_str, 'types.StringWithAggregatesFilter']
    outcomes: Union[_str, 'types.StringWithAggregatesFilter']
    outcomePrices: Union[_str, 'types.StringWithAggregatesFilter']
    shortOutcomes: Union[_str, 'types.StringWithAggregatesFilter']
    readyTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    fundedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    acceptingOrdersTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameId: Union[_str, 'types.StringWithAggregatesFilter']
    teamAID: Union[_str, 'types.StringWithAggregatesFilter']
    teamBID: Union[_str, 'types.StringWithAggregatesFilter']
    sportsMarketType: Union[_str, 'types.StringWithAggregatesFilter']
    line: Union[_float, 'types.FloatWithAggregatesFilter']
    umaBond: Union[_str, 'types.StringWithAggregatesFilter']
    umaReward: Union[_str, 'types.StringWithAggregatesFilter']
    customLiveness: Union[_int, 'types.IntWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MarketScalarWhereWithAggregatesInputRecursive2']
    OR: List['MarketScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MarketScalarWhereWithAggregatesInputRecursive2']


class MarketScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    conditionId: Union[_str, 'types.StringWithAggregatesFilter']
    questionID: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    marketType: Union[_str, 'types.StringWithAggregatesFilter']
    formatType: Union[_str, 'types.StringWithAggregatesFilter']
    ammType: Union[_str, 'types.StringWithAggregatesFilter']
    volume: Union[_str, 'types.StringWithAggregatesFilter']
    volumeNum: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidity: Union[_str, 'types.StringWithAggregatesFilter']
    liquidityNum: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    oneDayPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneHourPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneWeekPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneMonthPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneYearPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    lastTradePrice: Union[_float, 'types.FloatWithAggregatesFilter']
    bestBid: Union[_float, 'types.FloatWithAggregatesFilter']
    bestAsk: Union[_float, 'types.FloatWithAggregatesFilter']
    spread: Union[_float, 'types.FloatWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    fee: Union[_str, 'types.StringWithAggregatesFilter']
    makerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    takerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    denominationToken: Union[_str, 'types.StringWithAggregatesFilter']
    marketMakerAddress: Union[_str, 'types.StringWithAggregatesFilter']
    clobTokenIds: Union[_str, 'types.StringWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    creator: Union[_str, 'types.StringWithAggregatesFilter']
    marketGroup: Union[_int, 'types.IntWithAggregatesFilter']
    groupItemTitle: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemThreshold: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemRange: Union[_str, 'types.StringWithAggregatesFilter']
    curationOrder: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_float, 'types.FloatWithAggregatesFilter']
    mailchimpTag: Union[_str, 'types.StringWithAggregatesFilter']
    outcomes: Union[_str, 'types.StringWithAggregatesFilter']
    outcomePrices: Union[_str, 'types.StringWithAggregatesFilter']
    shortOutcomes: Union[_str, 'types.StringWithAggregatesFilter']
    readyTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    fundedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    acceptingOrdersTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameId: Union[_str, 'types.StringWithAggregatesFilter']
    teamAID: Union[_str, 'types.StringWithAggregatesFilter']
    teamBID: Union[_str, 'types.StringWithAggregatesFilter']
    sportsMarketType: Union[_str, 'types.StringWithAggregatesFilter']
    line: Union[_float, 'types.FloatWithAggregatesFilter']
    umaBond: Union[_str, 'types.StringWithAggregatesFilter']
    umaReward: Union[_str, 'types.StringWithAggregatesFilter']
    customLiveness: Union[_int, 'types.IntWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MarketScalarWhereWithAggregatesInputRecursive3']
    OR: List['MarketScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MarketScalarWhereWithAggregatesInputRecursive3']


class MarketScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    conditionId: Union[_str, 'types.StringWithAggregatesFilter']
    questionID: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    marketType: Union[_str, 'types.StringWithAggregatesFilter']
    formatType: Union[_str, 'types.StringWithAggregatesFilter']
    ammType: Union[_str, 'types.StringWithAggregatesFilter']
    volume: Union[_str, 'types.StringWithAggregatesFilter']
    volumeNum: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidity: Union[_str, 'types.StringWithAggregatesFilter']
    liquidityNum: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    oneDayPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneHourPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneWeekPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneMonthPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneYearPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    lastTradePrice: Union[_float, 'types.FloatWithAggregatesFilter']
    bestBid: Union[_float, 'types.FloatWithAggregatesFilter']
    bestAsk: Union[_float, 'types.FloatWithAggregatesFilter']
    spread: Union[_float, 'types.FloatWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    fee: Union[_str, 'types.StringWithAggregatesFilter']
    makerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    takerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    denominationToken: Union[_str, 'types.StringWithAggregatesFilter']
    marketMakerAddress: Union[_str, 'types.StringWithAggregatesFilter']
    clobTokenIds: Union[_str, 'types.StringWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    creator: Union[_str, 'types.StringWithAggregatesFilter']
    marketGroup: Union[_int, 'types.IntWithAggregatesFilter']
    groupItemTitle: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemThreshold: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemRange: Union[_str, 'types.StringWithAggregatesFilter']
    curationOrder: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_float, 'types.FloatWithAggregatesFilter']
    mailchimpTag: Union[_str, 'types.StringWithAggregatesFilter']
    outcomes: Union[_str, 'types.StringWithAggregatesFilter']
    outcomePrices: Union[_str, 'types.StringWithAggregatesFilter']
    shortOutcomes: Union[_str, 'types.StringWithAggregatesFilter']
    readyTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    fundedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    acceptingOrdersTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameId: Union[_str, 'types.StringWithAggregatesFilter']
    teamAID: Union[_str, 'types.StringWithAggregatesFilter']
    teamBID: Union[_str, 'types.StringWithAggregatesFilter']
    sportsMarketType: Union[_str, 'types.StringWithAggregatesFilter']
    line: Union[_float, 'types.FloatWithAggregatesFilter']
    umaBond: Union[_str, 'types.StringWithAggregatesFilter']
    umaReward: Union[_str, 'types.StringWithAggregatesFilter']
    customLiveness: Union[_int, 'types.IntWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['MarketScalarWhereWithAggregatesInputRecursive4']
    OR: List['MarketScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MarketScalarWhereWithAggregatesInputRecursive4']


class MarketScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Market arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    conditionId: Union[_str, 'types.StringWithAggregatesFilter']
    questionID: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    question: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    category: Union[_str, 'types.StringWithAggregatesFilter']
    image: Union[_str, 'types.StringWithAggregatesFilter']
    icon: Union[_str, 'types.StringWithAggregatesFilter']
    resolutionSource: Union[_str, 'types.StringWithAggregatesFilter']
    startDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endDate: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    closedTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    active: Union[_bool, 'types.BooleanWithAggregatesFilter']
    closed: Union[_bool, 'types.BooleanWithAggregatesFilter']
    archived: Union[_bool, 'types.BooleanWithAggregatesFilter']
    new: Union[_bool, 'types.BooleanWithAggregatesFilter']
    marketType: Union[_str, 'types.StringWithAggregatesFilter']
    formatType: Union[_str, 'types.StringWithAggregatesFilter']
    ammType: Union[_str, 'types.StringWithAggregatesFilter']
    volume: Union[_str, 'types.StringWithAggregatesFilter']
    volumeNum: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hr: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wk: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1mo: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yr: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volumeClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    volume24hrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1wkClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1moClob: Union[_float, 'types.FloatWithAggregatesFilter']
    volume1yrClob: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidity: Union[_str, 'types.StringWithAggregatesFilter']
    liquidityNum: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityAmm: Union[_float, 'types.FloatWithAggregatesFilter']
    liquidityClob: Union[_float, 'types.FloatWithAggregatesFilter']
    oneDayPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneHourPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneWeekPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneMonthPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    oneYearPriceChange: Union[_float, 'types.FloatWithAggregatesFilter']
    lastTradePrice: Union[_float, 'types.FloatWithAggregatesFilter']
    bestBid: Union[_float, 'types.FloatWithAggregatesFilter']
    bestAsk: Union[_float, 'types.FloatWithAggregatesFilter']
    spread: Union[_float, 'types.FloatWithAggregatesFilter']
    enableOrderBook: Union[_bool, 'types.BooleanWithAggregatesFilter']
    fee: Union[_str, 'types.StringWithAggregatesFilter']
    makerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    takerBaseFee: Union[_float, 'types.FloatWithAggregatesFilter']
    denominationToken: Union[_str, 'types.StringWithAggregatesFilter']
    marketMakerAddress: Union[_str, 'types.StringWithAggregatesFilter']
    clobTokenIds: Union[_str, 'types.StringWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    creator: Union[_str, 'types.StringWithAggregatesFilter']
    marketGroup: Union[_int, 'types.IntWithAggregatesFilter']
    groupItemTitle: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemThreshold: Union[_str, 'types.StringWithAggregatesFilter']
    groupItemRange: Union[_str, 'types.StringWithAggregatesFilter']
    curationOrder: Union[_int, 'types.IntWithAggregatesFilter']
    score: Union[_float, 'types.FloatWithAggregatesFilter']
    mailchimpTag: Union[_str, 'types.StringWithAggregatesFilter']
    outcomes: Union[_str, 'types.StringWithAggregatesFilter']
    outcomePrices: Union[_str, 'types.StringWithAggregatesFilter']
    shortOutcomes: Union[_str, 'types.StringWithAggregatesFilter']
    readyTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    fundedTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    acceptingOrdersTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deployingTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scheduledDeploymentTimestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    gameId: Union[_str, 'types.StringWithAggregatesFilter']
    teamAID: Union[_str, 'types.StringWithAggregatesFilter']
    teamBID: Union[_str, 'types.StringWithAggregatesFilter']
    sportsMarketType: Union[_str, 'types.StringWithAggregatesFilter']
    line: Union[_float, 'types.FloatWithAggregatesFilter']
    umaBond: Union[_str, 'types.StringWithAggregatesFilter']
    umaReward: Union[_str, 'types.StringWithAggregatesFilter']
    customLiveness: Union[_int, 'types.IntWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class MarketGroupByOutput(TypedDict, total=False):
    id: _str
    conditionId: _str
    questionID: _str
    slug: _str
    question: _str
    description: _str
    category: _str
    image: _str
    icon: _str
    resolutionSource: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    closedTime: datetime.datetime
    active: _bool
    closed: _bool
    archived: _bool
    new: _bool
    marketType: _str
    formatType: _str
    ammType: _str
    volume: _str
    volumeNum: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    volumeAmm: _float
    volumeClob: _float
    volume24hrAmm: _float
    volume1wkAmm: _float
    volume1moAmm: _float
    volume1yrAmm: _float
    volume24hrClob: _float
    volume1wkClob: _float
    volume1moClob: _float
    volume1yrClob: _float
    liquidity: _str
    liquidityNum: _float
    liquidityAmm: _float
    liquidityClob: _float
    oneDayPriceChange: _float
    oneHourPriceChange: _float
    oneWeekPriceChange: _float
    oneMonthPriceChange: _float
    oneYearPriceChange: _float
    lastTradePrice: _float
    bestBid: _float
    bestAsk: _float
    spread: _float
    enableOrderBook: _bool
    fee: _str
    makerBaseFee: _float
    takerBaseFee: _float
    denominationToken: _str
    marketMakerAddress: _str
    clobTokenIds: List[_str]
    createdBy: _int
    updatedBy: _int
    creator: _str
    marketGroup: _int
    groupItemTitle: _str
    groupItemThreshold: _str
    groupItemRange: _str
    curationOrder: _int
    score: _float
    mailchimpTag: _str
    outcomes: _str
    outcomePrices: _str
    shortOutcomes: _str
    readyTimestamp: datetime.datetime
    fundedTimestamp: datetime.datetime
    acceptingOrdersTimestamp: datetime.datetime
    deployingTimestamp: datetime.datetime
    scheduledDeploymentTimestamp: datetime.datetime
    gameId: _str
    teamAID: _str
    teamBID: _str
    sportsMarketType: _str
    line: _float
    umaBond: _str
    umaReward: _str
    customLiveness: _int
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    _sum: 'MarketSumAggregateOutput'
    _avg: 'MarketAvgAggregateOutput'
    _min: 'MarketMinAggregateOutput'
    _max: 'MarketMaxAggregateOutput'
    _count: 'MarketCountAggregateOutput'


class MarketAvgAggregateOutput(TypedDict, total=False):
    """Market output for aggregating averages"""
    volumeNum: float
    volume24hr: float
    volume1wk: float
    volume1mo: float
    volume1yr: float
    volumeAmm: float
    volumeClob: float
    volume24hrAmm: float
    volume1wkAmm: float
    volume1moAmm: float
    volume1yrAmm: float
    volume24hrClob: float
    volume1wkClob: float
    volume1moClob: float
    volume1yrClob: float
    liquidityNum: float
    liquidityAmm: float
    liquidityClob: float
    oneDayPriceChange: float
    oneHourPriceChange: float
    oneWeekPriceChange: float
    oneMonthPriceChange: float
    oneYearPriceChange: float
    lastTradePrice: float
    bestBid: float
    bestAsk: float
    spread: float
    makerBaseFee: float
    takerBaseFee: float
    createdBy: float
    updatedBy: float
    marketGroup: float
    curationOrder: float
    score: float
    line: float
    customLiveness: float


class MarketSumAggregateOutput(TypedDict, total=False):
    """Market output for aggregating sums"""
    volumeNum: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    volumeAmm: _float
    volumeClob: _float
    volume24hrAmm: _float
    volume1wkAmm: _float
    volume1moAmm: _float
    volume1yrAmm: _float
    volume24hrClob: _float
    volume1wkClob: _float
    volume1moClob: _float
    volume1yrClob: _float
    liquidityNum: _float
    liquidityAmm: _float
    liquidityClob: _float
    oneDayPriceChange: _float
    oneHourPriceChange: _float
    oneWeekPriceChange: _float
    oneMonthPriceChange: _float
    oneYearPriceChange: _float
    lastTradePrice: _float
    bestBid: _float
    bestAsk: _float
    spread: _float
    makerBaseFee: _float
    takerBaseFee: _float
    createdBy: _int
    updatedBy: _int
    marketGroup: _int
    curationOrder: _int
    score: _float
    line: _float
    customLiveness: _int


class MarketScalarAggregateOutput(TypedDict, total=False):
    """Market output including scalar fields"""
    id: _str
    conditionId: _str
    questionID: _str
    slug: _str
    question: _str
    description: _str
    category: _str
    image: _str
    icon: _str
    resolutionSource: _str
    startDate: datetime.datetime
    endDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    closedTime: datetime.datetime
    active: _bool
    closed: _bool
    archived: _bool
    new: _bool
    marketType: _str
    formatType: _str
    ammType: _str
    volume: _str
    volumeNum: _float
    volume24hr: _float
    volume1wk: _float
    volume1mo: _float
    volume1yr: _float
    volumeAmm: _float
    volumeClob: _float
    volume24hrAmm: _float
    volume1wkAmm: _float
    volume1moAmm: _float
    volume1yrAmm: _float
    volume24hrClob: _float
    volume1wkClob: _float
    volume1moClob: _float
    volume1yrClob: _float
    liquidity: _str
    liquidityNum: _float
    liquidityAmm: _float
    liquidityClob: _float
    oneDayPriceChange: _float
    oneHourPriceChange: _float
    oneWeekPriceChange: _float
    oneMonthPriceChange: _float
    oneYearPriceChange: _float
    lastTradePrice: _float
    bestBid: _float
    bestAsk: _float
    spread: _float
    enableOrderBook: _bool
    fee: _str
    makerBaseFee: _float
    takerBaseFee: _float
    denominationToken: _str
    marketMakerAddress: _str
    clobTokenIds: List[_str]
    createdBy: _int
    updatedBy: _int
    creator: _str
    marketGroup: _int
    groupItemTitle: _str
    groupItemThreshold: _str
    groupItemRange: _str
    curationOrder: _int
    score: _float
    mailchimpTag: _str
    outcomes: _str
    outcomePrices: _str
    shortOutcomes: _str
    readyTimestamp: datetime.datetime
    fundedTimestamp: datetime.datetime
    acceptingOrdersTimestamp: datetime.datetime
    deployingTimestamp: datetime.datetime
    scheduledDeploymentTimestamp: datetime.datetime
    gameId: _str
    teamAID: _str
    teamBID: _str
    sportsMarketType: _str
    line: _float
    umaBond: _str
    umaReward: _str
    customLiveness: _int
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


MarketMinAggregateOutput = MarketScalarAggregateOutput
MarketMaxAggregateOutput = MarketScalarAggregateOutput


class MarketMaxAggregateInput(TypedDict, total=False):
    """Market input for aggregating by max"""
    id: bool
    conditionId: bool
    questionID: bool
    slug: bool
    question: bool
    description: bool
    category: bool
    image: bool
    icon: bool
    resolutionSource: bool
    startDate: bool
    endDate: bool
    createdAt: bool
    updatedAt: bool
    closedTime: bool
    active: bool
    closed: bool
    archived: bool
    new: bool
    marketType: bool
    formatType: bool
    ammType: bool
    volume: bool
    volumeNum: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    volumeAmm: bool
    volumeClob: bool
    volume24hrAmm: bool
    volume1wkAmm: bool
    volume1moAmm: bool
    volume1yrAmm: bool
    volume24hrClob: bool
    volume1wkClob: bool
    volume1moClob: bool
    volume1yrClob: bool
    liquidity: bool
    liquidityNum: bool
    liquidityAmm: bool
    liquidityClob: bool
    oneDayPriceChange: bool
    oneHourPriceChange: bool
    oneWeekPriceChange: bool
    oneMonthPriceChange: bool
    oneYearPriceChange: bool
    lastTradePrice: bool
    bestBid: bool
    bestAsk: bool
    spread: bool
    enableOrderBook: bool
    fee: bool
    makerBaseFee: bool
    takerBaseFee: bool
    denominationToken: bool
    marketMakerAddress: bool
    clobTokenIds: bool
    createdBy: bool
    updatedBy: bool
    creator: bool
    marketGroup: bool
    groupItemTitle: bool
    groupItemThreshold: bool
    groupItemRange: bool
    curationOrder: bool
    score: bool
    mailchimpTag: bool
    outcomes: bool
    outcomePrices: bool
    shortOutcomes: bool
    readyTimestamp: bool
    fundedTimestamp: bool
    acceptingOrdersTimestamp: bool
    deployingTimestamp: bool
    scheduledDeploymentTimestamp: bool
    gameId: bool
    teamAID: bool
    teamBID: bool
    sportsMarketType: bool
    line: bool
    umaBond: bool
    umaReward: bool
    customLiveness: bool
    scrapedAt: bool
    createdInDb: bool


class MarketMinAggregateInput(TypedDict, total=False):
    """Market input for aggregating by min"""
    id: bool
    conditionId: bool
    questionID: bool
    slug: bool
    question: bool
    description: bool
    category: bool
    image: bool
    icon: bool
    resolutionSource: bool
    startDate: bool
    endDate: bool
    createdAt: bool
    updatedAt: bool
    closedTime: bool
    active: bool
    closed: bool
    archived: bool
    new: bool
    marketType: bool
    formatType: bool
    ammType: bool
    volume: bool
    volumeNum: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    volumeAmm: bool
    volumeClob: bool
    volume24hrAmm: bool
    volume1wkAmm: bool
    volume1moAmm: bool
    volume1yrAmm: bool
    volume24hrClob: bool
    volume1wkClob: bool
    volume1moClob: bool
    volume1yrClob: bool
    liquidity: bool
    liquidityNum: bool
    liquidityAmm: bool
    liquidityClob: bool
    oneDayPriceChange: bool
    oneHourPriceChange: bool
    oneWeekPriceChange: bool
    oneMonthPriceChange: bool
    oneYearPriceChange: bool
    lastTradePrice: bool
    bestBid: bool
    bestAsk: bool
    spread: bool
    enableOrderBook: bool
    fee: bool
    makerBaseFee: bool
    takerBaseFee: bool
    denominationToken: bool
    marketMakerAddress: bool
    clobTokenIds: bool
    createdBy: bool
    updatedBy: bool
    creator: bool
    marketGroup: bool
    groupItemTitle: bool
    groupItemThreshold: bool
    groupItemRange: bool
    curationOrder: bool
    score: bool
    mailchimpTag: bool
    outcomes: bool
    outcomePrices: bool
    shortOutcomes: bool
    readyTimestamp: bool
    fundedTimestamp: bool
    acceptingOrdersTimestamp: bool
    deployingTimestamp: bool
    scheduledDeploymentTimestamp: bool
    gameId: bool
    teamAID: bool
    teamBID: bool
    sportsMarketType: bool
    line: bool
    umaBond: bool
    umaReward: bool
    customLiveness: bool
    scrapedAt: bool
    createdInDb: bool


class MarketNumberAggregateInput(TypedDict, total=False):
    """Market input for aggregating numbers"""
    volumeNum: bool
    volume24hr: bool
    volume1wk: bool
    volume1mo: bool
    volume1yr: bool
    volumeAmm: bool
    volumeClob: bool
    volume24hrAmm: bool
    volume1wkAmm: bool
    volume1moAmm: bool
    volume1yrAmm: bool
    volume24hrClob: bool
    volume1wkClob: bool
    volume1moClob: bool
    volume1yrClob: bool
    liquidityNum: bool
    liquidityAmm: bool
    liquidityClob: bool
    oneDayPriceChange: bool
    oneHourPriceChange: bool
    oneWeekPriceChange: bool
    oneMonthPriceChange: bool
    oneYearPriceChange: bool
    lastTradePrice: bool
    bestBid: bool
    bestAsk: bool
    spread: bool
    makerBaseFee: bool
    takerBaseFee: bool
    createdBy: bool
    updatedBy: bool
    marketGroup: bool
    curationOrder: bool
    score: bool
    line: bool
    customLiveness: bool


MarketAvgAggregateInput = MarketNumberAggregateInput
MarketSumAggregateInput = MarketNumberAggregateInput


MarketCountAggregateInput = TypedDict(
    'MarketCountAggregateInput',
    {
        'id': bool,
        'conditionId': bool,
        'questionID': bool,
        'slug': bool,
        'question': bool,
        'description': bool,
        'category': bool,
        'image': bool,
        'icon': bool,
        'resolutionSource': bool,
        'startDate': bool,
        'endDate': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'closedTime': bool,
        'active': bool,
        'closed': bool,
        'archived': bool,
        'new': bool,
        'marketType': bool,
        'formatType': bool,
        'ammType': bool,
        'volume': bool,
        'volumeNum': bool,
        'volume24hr': bool,
        'volume1wk': bool,
        'volume1mo': bool,
        'volume1yr': bool,
        'volumeAmm': bool,
        'volumeClob': bool,
        'volume24hrAmm': bool,
        'volume1wkAmm': bool,
        'volume1moAmm': bool,
        'volume1yrAmm': bool,
        'volume24hrClob': bool,
        'volume1wkClob': bool,
        'volume1moClob': bool,
        'volume1yrClob': bool,
        'liquidity': bool,
        'liquidityNum': bool,
        'liquidityAmm': bool,
        'liquidityClob': bool,
        'oneDayPriceChange': bool,
        'oneHourPriceChange': bool,
        'oneWeekPriceChange': bool,
        'oneMonthPriceChange': bool,
        'oneYearPriceChange': bool,
        'lastTradePrice': bool,
        'bestBid': bool,
        'bestAsk': bool,
        'spread': bool,
        'enableOrderBook': bool,
        'fee': bool,
        'makerBaseFee': bool,
        'takerBaseFee': bool,
        'denominationToken': bool,
        'marketMakerAddress': bool,
        'clobTokenIds': bool,
        'createdBy': bool,
        'updatedBy': bool,
        'creator': bool,
        'marketGroup': bool,
        'groupItemTitle': bool,
        'groupItemThreshold': bool,
        'groupItemRange': bool,
        'curationOrder': bool,
        'score': bool,
        'mailchimpTag': bool,
        'outcomes': bool,
        'outcomePrices': bool,
        'shortOutcomes': bool,
        'readyTimestamp': bool,
        'fundedTimestamp': bool,
        'acceptingOrdersTimestamp': bool,
        'deployingTimestamp': bool,
        'scheduledDeploymentTimestamp': bool,
        'gameId': bool,
        'teamAID': bool,
        'teamBID': bool,
        'sportsMarketType': bool,
        'line': bool,
        'umaBond': bool,
        'umaReward': bool,
        'customLiveness': bool,
        'scrapedAt': bool,
        'createdInDb': bool,
        '_all': bool,
    },
    total=False,
)

MarketCountAggregateOutput = TypedDict(
    'MarketCountAggregateOutput',
    {
        'id': int,
        'conditionId': int,
        'questionID': int,
        'slug': int,
        'question': int,
        'description': int,
        'category': int,
        'image': int,
        'icon': int,
        'resolutionSource': int,
        'startDate': int,
        'endDate': int,
        'createdAt': int,
        'updatedAt': int,
        'closedTime': int,
        'active': int,
        'closed': int,
        'archived': int,
        'new': int,
        'marketType': int,
        'formatType': int,
        'ammType': int,
        'volume': int,
        'volumeNum': int,
        'volume24hr': int,
        'volume1wk': int,
        'volume1mo': int,
        'volume1yr': int,
        'volumeAmm': int,
        'volumeClob': int,
        'volume24hrAmm': int,
        'volume1wkAmm': int,
        'volume1moAmm': int,
        'volume1yrAmm': int,
        'volume24hrClob': int,
        'volume1wkClob': int,
        'volume1moClob': int,
        'volume1yrClob': int,
        'liquidity': int,
        'liquidityNum': int,
        'liquidityAmm': int,
        'liquidityClob': int,
        'oneDayPriceChange': int,
        'oneHourPriceChange': int,
        'oneWeekPriceChange': int,
        'oneMonthPriceChange': int,
        'oneYearPriceChange': int,
        'lastTradePrice': int,
        'bestBid': int,
        'bestAsk': int,
        'spread': int,
        'enableOrderBook': int,
        'fee': int,
        'makerBaseFee': int,
        'takerBaseFee': int,
        'denominationToken': int,
        'marketMakerAddress': int,
        'clobTokenIds': int,
        'createdBy': int,
        'updatedBy': int,
        'creator': int,
        'marketGroup': int,
        'groupItemTitle': int,
        'groupItemThreshold': int,
        'groupItemRange': int,
        'curationOrder': int,
        'score': int,
        'mailchimpTag': int,
        'outcomes': int,
        'outcomePrices': int,
        'shortOutcomes': int,
        'readyTimestamp': int,
        'fundedTimestamp': int,
        'acceptingOrdersTimestamp': int,
        'deployingTimestamp': int,
        'scheduledDeploymentTimestamp': int,
        'gameId': int,
        'teamAID': int,
        'teamBID': int,
        'sportsMarketType': int,
        'line': int,
        'umaBond': int,
        'umaReward': int,
        'customLiveness': int,
        'scrapedAt': int,
        'createdInDb': int,
        '_all': int,
    },
    total=False,
)


MarketKeys = Literal[
    'id',
    'conditionId',
    'questionID',
    'slug',
    'question',
    'description',
    'category',
    'image',
    'icon',
    'resolutionSource',
    'startDate',
    'endDate',
    'createdAt',
    'updatedAt',
    'closedTime',
    'active',
    'closed',
    'archived',
    'new',
    'marketType',
    'formatType',
    'ammType',
    'volume',
    'volumeNum',
    'volume24hr',
    'volume1wk',
    'volume1mo',
    'volume1yr',
    'volumeAmm',
    'volumeClob',
    'volume24hrAmm',
    'volume1wkAmm',
    'volume1moAmm',
    'volume1yrAmm',
    'volume24hrClob',
    'volume1wkClob',
    'volume1moClob',
    'volume1yrClob',
    'liquidity',
    'liquidityNum',
    'liquidityAmm',
    'liquidityClob',
    'oneDayPriceChange',
    'oneHourPriceChange',
    'oneWeekPriceChange',
    'oneMonthPriceChange',
    'oneYearPriceChange',
    'lastTradePrice',
    'bestBid',
    'bestAsk',
    'spread',
    'enableOrderBook',
    'fee',
    'makerBaseFee',
    'takerBaseFee',
    'denominationToken',
    'marketMakerAddress',
    'clobTokenIds',
    'createdBy',
    'updatedBy',
    'creator',
    'marketGroup',
    'groupItemTitle',
    'groupItemThreshold',
    'groupItemRange',
    'curationOrder',
    'score',
    'mailchimpTag',
    'outcomes',
    'outcomePrices',
    'shortOutcomes',
    'readyTimestamp',
    'fundedTimestamp',
    'acceptingOrdersTimestamp',
    'deployingTimestamp',
    'scheduledDeploymentTimestamp',
    'gameId',
    'teamAID',
    'teamBID',
    'sportsMarketType',
    'line',
    'umaBond',
    'umaReward',
    'customLiveness',
    'scrapedAt',
    'createdInDb',
    'events',
    'tags',
    'marketOutcomes',
]
MarketScalarFieldKeys = Literal[
    'id',
    'conditionId',
    'questionID',
    'slug',
    'question',
    'description',
    'category',
    'image',
    'icon',
    'resolutionSource',
    'startDate',
    'endDate',
    'createdAt',
    'updatedAt',
    'closedTime',
    'active',
    'closed',
    'archived',
    'new',
    'marketType',
    'formatType',
    'ammType',
    'volume',
    'volumeNum',
    'volume24hr',
    'volume1wk',
    'volume1mo',
    'volume1yr',
    'volumeAmm',
    'volumeClob',
    'volume24hrAmm',
    'volume1wkAmm',
    'volume1moAmm',
    'volume1yrAmm',
    'volume24hrClob',
    'volume1wkClob',
    'volume1moClob',
    'volume1yrClob',
    'liquidity',
    'liquidityNum',
    'liquidityAmm',
    'liquidityClob',
    'oneDayPriceChange',
    'oneHourPriceChange',
    'oneWeekPriceChange',
    'oneMonthPriceChange',
    'oneYearPriceChange',
    'lastTradePrice',
    'bestBid',
    'bestAsk',
    'spread',
    'enableOrderBook',
    'fee',
    'makerBaseFee',
    'takerBaseFee',
    'denominationToken',
    'marketMakerAddress',
    'clobTokenIds',
    'createdBy',
    'updatedBy',
    'creator',
    'marketGroup',
    'groupItemTitle',
    'groupItemThreshold',
    'groupItemRange',
    'curationOrder',
    'score',
    'mailchimpTag',
    'outcomes',
    'outcomePrices',
    'shortOutcomes',
    'readyTimestamp',
    'fundedTimestamp',
    'acceptingOrdersTimestamp',
    'deployingTimestamp',
    'scheduledDeploymentTimestamp',
    'gameId',
    'teamAID',
    'teamBID',
    'sportsMarketType',
    'line',
    'umaBond',
    'umaReward',
    'customLiveness',
    'scrapedAt',
    'createdInDb',
]
MarketScalarFieldKeysT = TypeVar('MarketScalarFieldKeysT', bound=MarketScalarFieldKeys)

MarketRelationalFieldKeys = Literal[
        'events',
        'tags',
        'marketOutcomes',
    ]

# MarketOutcome types

class MarketOutcomeOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the MarketOutcome create method"""
    id: _int
    marketId: _str
    market: 'MarketCreateNestedWithoutRelationsInput'
    priceSnapshots: 'TokenPriceCreateManyNestedWithoutRelationsInput'
    pricesScrapedAt: Optional[datetime.datetime]
    pricesCount: _int


class MarketOutcomeCreateInput(MarketOutcomeOptionalCreateInput):
    """Required arguments to the MarketOutcome create method"""
    clobTokenId: _str
    outcomeText: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class MarketOutcomeOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the MarketOutcome create method, without relations"""
    id: _int
    marketId: _str
    pricesScrapedAt: Optional[datetime.datetime]
    pricesCount: _int


class MarketOutcomeCreateWithoutRelationsInput(MarketOutcomeOptionalCreateWithoutRelationsInput):
    """Required arguments to the MarketOutcome create method, without relations"""
    clobTokenId: _str
    outcomeText: _str

class MarketOutcomeConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'MarketOutcomeCreateWithoutRelationsInput'
    where: 'MarketOutcomeWhereUniqueInput'

class MarketOutcomeCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'MarketOutcomeCreateWithoutRelationsInput'
    connect: 'MarketOutcomeWhereUniqueInput'
    connect_or_create: 'MarketOutcomeConnectOrCreateWithoutRelationsInput'


class MarketOutcomeCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['MarketOutcomeCreateWithoutRelationsInput', List['MarketOutcomeCreateWithoutRelationsInput']]
    connect: Union['MarketOutcomeWhereUniqueInput', List['MarketOutcomeWhereUniqueInput']]
    connect_or_create: Union['MarketOutcomeConnectOrCreateWithoutRelationsInput', List['MarketOutcomeConnectOrCreateWithoutRelationsInput']]

_MarketOutcomeWhereUnique_id_Input = TypedDict(
    '_MarketOutcomeWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_MarketOutcomeWhereUnique_clobTokenId_Input = TypedDict(
    '_MarketOutcomeWhereUnique_clobTokenId_Input',
    {
        'clobTokenId': '_str',
    },
    total=True
)

MarketOutcomeWhereUniqueInput = Union[
    '_MarketOutcomeWhereUnique_id_Input',
    '_MarketOutcomeWhereUnique_clobTokenId_Input',
]


class MarketOutcomeUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    clobTokenId: _str
    outcomeText: _str
    market: 'MarketUpdateOneWithoutRelationsInput'
    priceSnapshots: 'TokenPriceUpdateManyWithoutRelationsInput'
    pricesScrapedAt: Optional[datetime.datetime]
    pricesCount: Union[AtomicIntInput, _int]


class MarketOutcomeUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    clobTokenId: _str
    outcomeText: _str
    pricesScrapedAt: Optional[datetime.datetime]
    pricesCount: Union[AtomicIntInput, _int]


class MarketOutcomeUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['MarketOutcomeCreateWithoutRelationsInput']
    connect: List['MarketOutcomeWhereUniqueInput']
    connect_or_create: List['MarketOutcomeConnectOrCreateWithoutRelationsInput']
    set: List['MarketOutcomeWhereUniqueInput']
    disconnect: List['MarketOutcomeWhereUniqueInput']
    delete: List['MarketOutcomeWhereUniqueInput']

    # TODO
    # update: List['MarketOutcomeUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['MarketOutcomeUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['MarketOutcomeScalarWhereInput']
    # upsert: List['MarketOutcomeUpserteWithWhereUniqueWithoutRelationsInput']


class MarketOutcomeUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'MarketOutcomeCreateWithoutRelationsInput'
    connect: 'MarketOutcomeWhereUniqueInput'
    connect_or_create: 'MarketOutcomeConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'MarketOutcomeUpdateInput'
    # upsert: 'MarketOutcomeUpsertWithoutRelationsInput'


class MarketOutcomeUpsertInput(TypedDict):
    create: 'MarketOutcomeCreateInput'
    update: 'MarketOutcomeUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_MarketOutcome_id_OrderByInput = TypedDict(
    '_MarketOutcome_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_MarketOutcome_clobTokenId_OrderByInput = TypedDict(
    '_MarketOutcome_clobTokenId_OrderByInput',
    {
        'clobTokenId': 'SortOrder',
    },
    total=True
)

_MarketOutcome_marketId_OrderByInput = TypedDict(
    '_MarketOutcome_marketId_OrderByInput',
    {
        'marketId': 'SortOrder',
    },
    total=True
)

_MarketOutcome_outcomeText_OrderByInput = TypedDict(
    '_MarketOutcome_outcomeText_OrderByInput',
    {
        'outcomeText': 'SortOrder',
    },
    total=True
)

_MarketOutcome_pricesScrapedAt_OrderByInput = TypedDict(
    '_MarketOutcome_pricesScrapedAt_OrderByInput',
    {
        'pricesScrapedAt': 'SortOrder',
    },
    total=True
)

_MarketOutcome_pricesCount_OrderByInput = TypedDict(
    '_MarketOutcome_pricesCount_OrderByInput',
    {
        'pricesCount': 'SortOrder',
    },
    total=True
)

_MarketOutcome_RelevanceInner = TypedDict(
    '_MarketOutcome_RelevanceInner',
    {
        'fields': 'List[MarketOutcomeScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_MarketOutcome_RelevanceOrderByInput = TypedDict(
    '_MarketOutcome_RelevanceOrderByInput',
    {
        '_relevance': '_MarketOutcome_RelevanceInner',
    },
    total=True
)

MarketOutcomeOrderByInput = Union[
    '_MarketOutcome_id_OrderByInput',
    '_MarketOutcome_clobTokenId_OrderByInput',
    '_MarketOutcome_marketId_OrderByInput',
    '_MarketOutcome_outcomeText_OrderByInput',
    '_MarketOutcome_pricesScrapedAt_OrderByInput',
    '_MarketOutcome_pricesCount_OrderByInput',
    '_MarketOutcome_RelevanceOrderByInput',
]



# recursive MarketOutcome types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

MarketOutcomeRelationFilter = TypedDict(
    'MarketOutcomeRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class MarketOutcomeListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class MarketOutcomeInclude(TypedDict, total=False):
    """MarketOutcome relational arguments"""
    market: Union[bool, 'MarketArgsFromMarketOutcome']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketOutcome']


    

class EventIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketOutcomeRecursive1']


class EventIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketOutcomeRecursive2']


class EventIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketOutcomeRecursive3']


class EventIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromMarketOutcomeRecursive4']


class EventIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class EventArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyEventArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    events: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketOutcomeRecursive1']


class MarketIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    events: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketOutcomeRecursive2']


class MarketIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    events: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketOutcomeRecursive3']


class MarketIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    events: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromMarketOutcomeRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromMarketOutcomeRecursive4']


class MarketIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class MarketArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyMarketArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    market: Union[bool, 'MarketArgsFromMarketOutcomeRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketOutcomeRecursive1']


class MarketOutcomeIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    market: Union[bool, 'MarketArgsFromMarketOutcomeRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketOutcomeRecursive2']


class MarketOutcomeIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    market: Union[bool, 'MarketArgsFromMarketOutcomeRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketOutcomeRecursive3']


class MarketOutcomeIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    market: Union[bool, 'MarketArgsFromMarketOutcomeRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromMarketOutcomeRecursive4']


class MarketOutcomeIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class MarketOutcomeArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyMarketOutcomeArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive1']


class TagIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive2']


class TagIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive3']


class TagIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    markets: Union[bool, 'FindManyMarketArgsFromMarketOutcomeRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromMarketOutcomeRecursive4']


class TagIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class TagArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyTagArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    profile: Union[bool, 'UserProfileArgsFromMarketOutcomeRecursive1']
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive1']
    parentComment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketOutcomeRecursive1']


class CommentIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    profile: Union[bool, 'UserProfileArgsFromMarketOutcomeRecursive2']
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive2']
    parentComment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketOutcomeRecursive2']


class CommentIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    profile: Union[bool, 'UserProfileArgsFromMarketOutcomeRecursive3']
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive3']
    parentComment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketOutcomeRecursive3']


class CommentIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    profile: Union[bool, 'UserProfileArgsFromMarketOutcomeRecursive4']
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive4']
    parentComment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromMarketOutcomeRecursive4']


class CommentIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class CommentArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyCommentArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    comment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive1']


class CommentReactionIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    comment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive2']


class CommentReactionIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    comment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive3']


class CommentReactionIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    comment: Union[bool, 'CommentArgsFromMarketOutcomeRecursive4']


class CommentReactionIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class CommentReactionArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyCommentReactionArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive1']


class UserProfileIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive2']


class UserProfileIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive3']


class UserProfileIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    Comment: Union[bool, 'FindManyCommentArgsFromMarketOutcomeRecursive4']


class UserProfileIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class UserProfileArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyUserProfileArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive1']


class CommentCheckpointIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive2']


class CommentCheckpointIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive3']


class CommentCheckpointIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    event: Union[bool, 'EventArgsFromMarketOutcomeRecursive4']


class CommentCheckpointIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class CommentCheckpointArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyCommentCheckpointArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketOutcomeRecursive1']


class TokenPriceIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketOutcomeRecursive2']


class TokenPriceIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketOutcomeRecursive3']


class TokenPriceIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromMarketOutcomeRecursive4']


class TokenPriceIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class TokenPriceArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyTokenPriceArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromMarketOutcome(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""


class ScraperRunIncludeFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""


class ScraperRunIncludeFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""


class ScraperRunIncludeFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""


class ScraperRunIncludeFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Relational arguments for MarketOutcome"""

    

class ScraperRunArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    
    

class FindManyScraperRunArgsFromMarketOutcome(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromMarketOutcomeRecursive1(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromMarketOutcomeRecursive2(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromMarketOutcomeRecursive3(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromMarketOutcomeRecursive4(TypedDict, total=False):
    """Arguments for MarketOutcome"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyMarketOutcomeArgs = FindManyMarketOutcomeArgsFromMarketOutcome
FindFirstMarketOutcomeArgs = FindManyMarketOutcomeArgsFromMarketOutcome


    

class MarketOutcomeWhereInput(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    clobTokenId: Union[_str, 'types.StringFilter']
    marketId: Union[_str, 'types.StringFilter']
    outcomeText: Union[_str, 'types.StringFilter']
    market: 'MarketRelationFilter'
    priceSnapshots: 'TokenPriceListRelationFilter'
    pricesScrapedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    pricesCount: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MarketOutcomeWhereInputRecursive1', List['MarketOutcomeWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['MarketOutcomeWhereInputRecursive1']
    OR: List['MarketOutcomeWhereInputRecursive1']
    NOT: List['MarketOutcomeWhereInputRecursive1']


class MarketOutcomeWhereInputRecursive1(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    clobTokenId: Union[_str, 'types.StringFilter']
    marketId: Union[_str, 'types.StringFilter']
    outcomeText: Union[_str, 'types.StringFilter']
    market: 'MarketRelationFilter'
    priceSnapshots: 'TokenPriceListRelationFilter'
    pricesScrapedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    pricesCount: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MarketOutcomeWhereInputRecursive2', List['MarketOutcomeWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['MarketOutcomeWhereInputRecursive2']
    OR: List['MarketOutcomeWhereInputRecursive2']
    NOT: List['MarketOutcomeWhereInputRecursive2']


class MarketOutcomeWhereInputRecursive2(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    clobTokenId: Union[_str, 'types.StringFilter']
    marketId: Union[_str, 'types.StringFilter']
    outcomeText: Union[_str, 'types.StringFilter']
    market: 'MarketRelationFilter'
    priceSnapshots: 'TokenPriceListRelationFilter'
    pricesScrapedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    pricesCount: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MarketOutcomeWhereInputRecursive3', List['MarketOutcomeWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['MarketOutcomeWhereInputRecursive3']
    OR: List['MarketOutcomeWhereInputRecursive3']
    NOT: List['MarketOutcomeWhereInputRecursive3']


class MarketOutcomeWhereInputRecursive3(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    clobTokenId: Union[_str, 'types.StringFilter']
    marketId: Union[_str, 'types.StringFilter']
    outcomeText: Union[_str, 'types.StringFilter']
    market: 'MarketRelationFilter'
    priceSnapshots: 'TokenPriceListRelationFilter'
    pricesScrapedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    pricesCount: Union[_int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['MarketOutcomeWhereInputRecursive4', List['MarketOutcomeWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['MarketOutcomeWhereInputRecursive4']
    OR: List['MarketOutcomeWhereInputRecursive4']
    NOT: List['MarketOutcomeWhereInputRecursive4']


class MarketOutcomeWhereInputRecursive4(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    clobTokenId: Union[_str, 'types.StringFilter']
    marketId: Union[_str, 'types.StringFilter']
    outcomeText: Union[_str, 'types.StringFilter']
    market: 'MarketRelationFilter'
    priceSnapshots: 'TokenPriceListRelationFilter'
    pricesScrapedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    pricesCount: Union[_int, 'types.IntFilter']



# aggregate MarketOutcome types


    

class MarketOutcomeScalarWhereWithAggregatesInput(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    clobTokenId: Union[_str, 'types.StringWithAggregatesFilter']
    marketId: Union[_str, 'types.StringWithAggregatesFilter']
    outcomeText: Union[_str, 'types.StringWithAggregatesFilter']
    pricesScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pricesCount: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive1']
    OR: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive1']
    NOT: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive1']


class MarketOutcomeScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    clobTokenId: Union[_str, 'types.StringWithAggregatesFilter']
    marketId: Union[_str, 'types.StringWithAggregatesFilter']
    outcomeText: Union[_str, 'types.StringWithAggregatesFilter']
    pricesScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pricesCount: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive2']
    OR: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive2']
    NOT: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive2']


class MarketOutcomeScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    clobTokenId: Union[_str, 'types.StringWithAggregatesFilter']
    marketId: Union[_str, 'types.StringWithAggregatesFilter']
    outcomeText: Union[_str, 'types.StringWithAggregatesFilter']
    pricesScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pricesCount: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive3']
    OR: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive3']
    NOT: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive3']


class MarketOutcomeScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    clobTokenId: Union[_str, 'types.StringWithAggregatesFilter']
    marketId: Union[_str, 'types.StringWithAggregatesFilter']
    outcomeText: Union[_str, 'types.StringWithAggregatesFilter']
    pricesScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pricesCount: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive4']
    OR: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive4']
    NOT: List['MarketOutcomeScalarWhereWithAggregatesInputRecursive4']


class MarketOutcomeScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """MarketOutcome arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    clobTokenId: Union[_str, 'types.StringWithAggregatesFilter']
    marketId: Union[_str, 'types.StringWithAggregatesFilter']
    outcomeText: Union[_str, 'types.StringWithAggregatesFilter']
    pricesScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    pricesCount: Union[_int, 'types.IntWithAggregatesFilter']



class MarketOutcomeGroupByOutput(TypedDict, total=False):
    id: _int
    clobTokenId: _str
    marketId: _str
    outcomeText: _str
    pricesScrapedAt: datetime.datetime
    pricesCount: _int
    _sum: 'MarketOutcomeSumAggregateOutput'
    _avg: 'MarketOutcomeAvgAggregateOutput'
    _min: 'MarketOutcomeMinAggregateOutput'
    _max: 'MarketOutcomeMaxAggregateOutput'
    _count: 'MarketOutcomeCountAggregateOutput'


class MarketOutcomeAvgAggregateOutput(TypedDict, total=False):
    """MarketOutcome output for aggregating averages"""
    id: float
    pricesCount: float


class MarketOutcomeSumAggregateOutput(TypedDict, total=False):
    """MarketOutcome output for aggregating sums"""
    id: _int
    pricesCount: _int


class MarketOutcomeScalarAggregateOutput(TypedDict, total=False):
    """MarketOutcome output including scalar fields"""
    id: _int
    clobTokenId: _str
    marketId: _str
    outcomeText: _str
    pricesScrapedAt: datetime.datetime
    pricesCount: _int


MarketOutcomeMinAggregateOutput = MarketOutcomeScalarAggregateOutput
MarketOutcomeMaxAggregateOutput = MarketOutcomeScalarAggregateOutput


class MarketOutcomeMaxAggregateInput(TypedDict, total=False):
    """MarketOutcome input for aggregating by max"""
    id: bool
    clobTokenId: bool
    marketId: bool
    outcomeText: bool
    pricesScrapedAt: bool
    pricesCount: bool


class MarketOutcomeMinAggregateInput(TypedDict, total=False):
    """MarketOutcome input for aggregating by min"""
    id: bool
    clobTokenId: bool
    marketId: bool
    outcomeText: bool
    pricesScrapedAt: bool
    pricesCount: bool


class MarketOutcomeNumberAggregateInput(TypedDict, total=False):
    """MarketOutcome input for aggregating numbers"""
    id: bool
    pricesCount: bool


MarketOutcomeAvgAggregateInput = MarketOutcomeNumberAggregateInput
MarketOutcomeSumAggregateInput = MarketOutcomeNumberAggregateInput


MarketOutcomeCountAggregateInput = TypedDict(
    'MarketOutcomeCountAggregateInput',
    {
        'id': bool,
        'clobTokenId': bool,
        'marketId': bool,
        'outcomeText': bool,
        'pricesScrapedAt': bool,
        'pricesCount': bool,
        '_all': bool,
    },
    total=False,
)

MarketOutcomeCountAggregateOutput = TypedDict(
    'MarketOutcomeCountAggregateOutput',
    {
        'id': int,
        'clobTokenId': int,
        'marketId': int,
        'outcomeText': int,
        'pricesScrapedAt': int,
        'pricesCount': int,
        '_all': int,
    },
    total=False,
)


MarketOutcomeKeys = Literal[
    'id',
    'clobTokenId',
    'marketId',
    'outcomeText',
    'market',
    'priceSnapshots',
    'pricesScrapedAt',
    'pricesCount',
]
MarketOutcomeScalarFieldKeys = Literal[
    'id',
    'clobTokenId',
    'marketId',
    'outcomeText',
    'pricesScrapedAt',
    'pricesCount',
]
MarketOutcomeScalarFieldKeysT = TypeVar('MarketOutcomeScalarFieldKeysT', bound=MarketOutcomeScalarFieldKeys)

MarketOutcomeRelationalFieldKeys = Literal[
        'market',
        'priceSnapshots',
    ]

# Tag types

class TagOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tag create method"""
    label: Optional[_str]
    slug: Optional[_str]
    forceShow: Optional[_bool]
    forceHide: Optional[_bool]
    isCarousel: Optional[_bool]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_int]
    updatedBy: Optional[_int]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    markets: 'MarketCreateManyNestedWithoutRelationsInput'
    Event: 'EventCreateManyNestedWithoutRelationsInput'


class TagCreateInput(TagOptionalCreateInput):
    """Required arguments to the Tag create method"""
    id: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TagOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tag create method, without relations"""
    label: Optional[_str]
    slug: Optional[_str]
    forceShow: Optional[_bool]
    forceHide: Optional[_bool]
    isCarousel: Optional[_bool]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[_int]
    updatedBy: Optional[_int]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class TagCreateWithoutRelationsInput(TagOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tag create method, without relations"""
    id: _str

class TagConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TagCreateWithoutRelationsInput'
    where: 'TagWhereUniqueInput'

class TagCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TagCreateWithoutRelationsInput'
    connect: 'TagWhereUniqueInput'
    connect_or_create: 'TagConnectOrCreateWithoutRelationsInput'


class TagCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TagCreateWithoutRelationsInput', List['TagCreateWithoutRelationsInput']]
    connect: Union['TagWhereUniqueInput', List['TagWhereUniqueInput']]
    connect_or_create: Union['TagConnectOrCreateWithoutRelationsInput', List['TagConnectOrCreateWithoutRelationsInput']]

_TagWhereUnique_id_Input = TypedDict(
    '_TagWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_TagWhereUnique_slug_Input = TypedDict(
    '_TagWhereUnique_slug_Input',
    {
        'slug': '_str',
    },
    total=True
)

TagWhereUniqueInput = Union[
    '_TagWhereUnique_id_Input',
    '_TagWhereUnique_slug_Input',
]


class TagUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    label: Optional[_str]
    slug: Optional[_str]
    forceShow: Optional[_bool]
    forceHide: Optional[_bool]
    isCarousel: Optional[_bool]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[Union[AtomicIntInput, _int]]
    updatedBy: Optional[Union[AtomicIntInput, _int]]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    markets: 'MarketUpdateManyWithoutRelationsInput'
    Event: 'EventUpdateManyWithoutRelationsInput'


class TagUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    label: Optional[_str]
    slug: Optional[_str]
    forceShow: Optional[_bool]
    forceHide: Optional[_bool]
    isCarousel: Optional[_bool]
    publishedAt: Optional[datetime.datetime]
    createdBy: Optional[Union[AtomicIntInput, _int]]
    updatedBy: Optional[Union[AtomicIntInput, _int]]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


class TagUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TagCreateWithoutRelationsInput']
    connect: List['TagWhereUniqueInput']
    connect_or_create: List['TagConnectOrCreateWithoutRelationsInput']
    set: List['TagWhereUniqueInput']
    disconnect: List['TagWhereUniqueInput']
    delete: List['TagWhereUniqueInput']

    # TODO
    # update: List['TagUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TagUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TagScalarWhereInput']
    # upsert: List['TagUpserteWithWhereUniqueWithoutRelationsInput']


class TagUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TagCreateWithoutRelationsInput'
    connect: 'TagWhereUniqueInput'
    connect_or_create: 'TagConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TagUpdateInput'
    # upsert: 'TagUpsertWithoutRelationsInput'


class TagUpsertInput(TypedDict):
    create: 'TagCreateInput'
    update: 'TagUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tag_id_OrderByInput = TypedDict(
    '_Tag_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tag_label_OrderByInput = TypedDict(
    '_Tag_label_OrderByInput',
    {
        'label': 'SortOrder',
    },
    total=True
)

_Tag_slug_OrderByInput = TypedDict(
    '_Tag_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Tag_forceShow_OrderByInput = TypedDict(
    '_Tag_forceShow_OrderByInput',
    {
        'forceShow': 'SortOrder',
    },
    total=True
)

_Tag_forceHide_OrderByInput = TypedDict(
    '_Tag_forceHide_OrderByInput',
    {
        'forceHide': 'SortOrder',
    },
    total=True
)

_Tag_isCarousel_OrderByInput = TypedDict(
    '_Tag_isCarousel_OrderByInput',
    {
        'isCarousel': 'SortOrder',
    },
    total=True
)

_Tag_publishedAt_OrderByInput = TypedDict(
    '_Tag_publishedAt_OrderByInput',
    {
        'publishedAt': 'SortOrder',
    },
    total=True
)

_Tag_createdBy_OrderByInput = TypedDict(
    '_Tag_createdBy_OrderByInput',
    {
        'createdBy': 'SortOrder',
    },
    total=True
)

_Tag_updatedBy_OrderByInput = TypedDict(
    '_Tag_updatedBy_OrderByInput',
    {
        'updatedBy': 'SortOrder',
    },
    total=True
)

_Tag_createdAt_OrderByInput = TypedDict(
    '_Tag_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tag_updatedAt_OrderByInput = TypedDict(
    '_Tag_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tag_scrapedAt_OrderByInput = TypedDict(
    '_Tag_scrapedAt_OrderByInput',
    {
        'scrapedAt': 'SortOrder',
    },
    total=True
)

_Tag_createdInDb_OrderByInput = TypedDict(
    '_Tag_createdInDb_OrderByInput',
    {
        'createdInDb': 'SortOrder',
    },
    total=True
)

_Tag_RelevanceInner = TypedDict(
    '_Tag_RelevanceInner',
    {
        'fields': 'List[TagScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tag_RelevanceOrderByInput = TypedDict(
    '_Tag_RelevanceOrderByInput',
    {
        '_relevance': '_Tag_RelevanceInner',
    },
    total=True
)

TagOrderByInput = Union[
    '_Tag_id_OrderByInput',
    '_Tag_label_OrderByInput',
    '_Tag_slug_OrderByInput',
    '_Tag_forceShow_OrderByInput',
    '_Tag_forceHide_OrderByInput',
    '_Tag_isCarousel_OrderByInput',
    '_Tag_publishedAt_OrderByInput',
    '_Tag_createdBy_OrderByInput',
    '_Tag_updatedBy_OrderByInput',
    '_Tag_createdAt_OrderByInput',
    '_Tag_updatedAt_OrderByInput',
    '_Tag_scrapedAt_OrderByInput',
    '_Tag_createdInDb_OrderByInput',
    '_Tag_RelevanceOrderByInput',
]



# recursive Tag types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TagRelationFilter = TypedDict(
    'TagRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TagListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TagInclude(TypedDict, total=False):
    """Tag relational arguments"""
    markets: Union[bool, 'FindManyMarketArgsFromTag']
    Event: Union[bool, 'FindManyEventArgsFromTag']


    

class EventIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTagRecursive1']


class EventIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTagRecursive2']


class EventIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTagRecursive3']


class EventIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTagRecursive4']


class EventIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class EventArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyEventArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    events: Union[bool, 'FindManyEventArgsFromTagRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTagRecursive1']


class MarketIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    events: Union[bool, 'FindManyEventArgsFromTagRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTagRecursive2']


class MarketIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    events: Union[bool, 'FindManyEventArgsFromTagRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTagRecursive3']


class MarketIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    events: Union[bool, 'FindManyEventArgsFromTagRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromTagRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTagRecursive4']


class MarketIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class MarketArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyMarketArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    market: Union[bool, 'MarketArgsFromTagRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTagRecursive1']


class MarketOutcomeIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    market: Union[bool, 'MarketArgsFromTagRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTagRecursive2']


class MarketOutcomeIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    market: Union[bool, 'MarketArgsFromTagRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTagRecursive3']


class MarketOutcomeIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    market: Union[bool, 'MarketArgsFromTagRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTagRecursive4']


class MarketOutcomeIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class MarketOutcomeArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyMarketOutcomeArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromTagRecursive1']


class TagIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromTagRecursive2']


class TagIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromTagRecursive3']


class TagIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    markets: Union[bool, 'FindManyMarketArgsFromTagRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromTagRecursive4']


class TagIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class TagArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyTagArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    profile: Union[bool, 'UserProfileArgsFromTagRecursive1']
    event: Union[bool, 'EventArgsFromTagRecursive1']
    parentComment: Union[bool, 'CommentArgsFromTagRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromTagRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTagRecursive1']


class CommentIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    profile: Union[bool, 'UserProfileArgsFromTagRecursive2']
    event: Union[bool, 'EventArgsFromTagRecursive2']
    parentComment: Union[bool, 'CommentArgsFromTagRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromTagRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTagRecursive2']


class CommentIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    profile: Union[bool, 'UserProfileArgsFromTagRecursive3']
    event: Union[bool, 'EventArgsFromTagRecursive3']
    parentComment: Union[bool, 'CommentArgsFromTagRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromTagRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTagRecursive3']


class CommentIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    profile: Union[bool, 'UserProfileArgsFromTagRecursive4']
    event: Union[bool, 'EventArgsFromTagRecursive4']
    parentComment: Union[bool, 'CommentArgsFromTagRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromTagRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTagRecursive4']


class CommentIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class CommentArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyCommentArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    comment: Union[bool, 'CommentArgsFromTagRecursive1']


class CommentReactionIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    comment: Union[bool, 'CommentArgsFromTagRecursive2']


class CommentReactionIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    comment: Union[bool, 'CommentArgsFromTagRecursive3']


class CommentReactionIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    comment: Union[bool, 'CommentArgsFromTagRecursive4']


class CommentReactionIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class CommentReactionArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyCommentReactionArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive1']


class UserProfileIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive2']


class UserProfileIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive3']


class UserProfileIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    Comment: Union[bool, 'FindManyCommentArgsFromTagRecursive4']


class UserProfileIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class UserProfileArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyUserProfileArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    event: Union[bool, 'EventArgsFromTagRecursive1']


class CommentCheckpointIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    event: Union[bool, 'EventArgsFromTagRecursive2']


class CommentCheckpointIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    event: Union[bool, 'EventArgsFromTagRecursive3']


class CommentCheckpointIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    event: Union[bool, 'EventArgsFromTagRecursive4']


class CommentCheckpointIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class CommentCheckpointArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyCommentCheckpointArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTagRecursive1']


class TokenPriceIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTagRecursive2']


class TokenPriceIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTagRecursive3']


class TokenPriceIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTagRecursive4']


class TokenPriceIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class TokenPriceArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyTokenPriceArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromTag(TypedDict, total=False):
    """Relational arguments for Tag"""


class ScraperRunIncludeFromTagRecursive1(TypedDict, total=False):
    """Relational arguments for Tag"""


class ScraperRunIncludeFromTagRecursive2(TypedDict, total=False):
    """Relational arguments for Tag"""


class ScraperRunIncludeFromTagRecursive3(TypedDict, total=False):
    """Relational arguments for Tag"""


class ScraperRunIncludeFromTagRecursive4(TypedDict, total=False):
    """Relational arguments for Tag"""

    

class ScraperRunArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    
    

class FindManyScraperRunArgsFromTag(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromTagRecursive1(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromTagRecursive2(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromTagRecursive3(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromTagRecursive4(TypedDict, total=False):
    """Arguments for Tag"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyTagArgs = FindManyTagArgsFromTag
FindFirstTagArgs = FindManyTagArgsFromTag


    

class TagWhereInput(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    forceShow: Union[None, _bool, 'types.BooleanFilter']
    forceHide: Union[None, _bool, 'types.BooleanFilter']
    isCarousel: Union[None, _bool, 'types.BooleanFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    Event: 'EventListRelationFilter'

    # should be noted that AND and NOT should be Union['TagWhereInputRecursive1', List['TagWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TagWhereInputRecursive1']
    OR: List['TagWhereInputRecursive1']
    NOT: List['TagWhereInputRecursive1']


class TagWhereInputRecursive1(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    forceShow: Union[None, _bool, 'types.BooleanFilter']
    forceHide: Union[None, _bool, 'types.BooleanFilter']
    isCarousel: Union[None, _bool, 'types.BooleanFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    Event: 'EventListRelationFilter'

    # should be noted that AND and NOT should be Union['TagWhereInputRecursive2', List['TagWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TagWhereInputRecursive2']
    OR: List['TagWhereInputRecursive2']
    NOT: List['TagWhereInputRecursive2']


class TagWhereInputRecursive2(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    forceShow: Union[None, _bool, 'types.BooleanFilter']
    forceHide: Union[None, _bool, 'types.BooleanFilter']
    isCarousel: Union[None, _bool, 'types.BooleanFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    Event: 'EventListRelationFilter'

    # should be noted that AND and NOT should be Union['TagWhereInputRecursive3', List['TagWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TagWhereInputRecursive3']
    OR: List['TagWhereInputRecursive3']
    NOT: List['TagWhereInputRecursive3']


class TagWhereInputRecursive3(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    forceShow: Union[None, _bool, 'types.BooleanFilter']
    forceHide: Union[None, _bool, 'types.BooleanFilter']
    isCarousel: Union[None, _bool, 'types.BooleanFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    Event: 'EventListRelationFilter'

    # should be noted that AND and NOT should be Union['TagWhereInputRecursive4', List['TagWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TagWhereInputRecursive4']
    OR: List['TagWhereInputRecursive4']
    NOT: List['TagWhereInputRecursive4']


class TagWhereInputRecursive4(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    label: Union[None, _str, 'types.StringFilter']
    slug: Union[None, _str, 'types.StringFilter']
    forceShow: Union[None, _bool, 'types.BooleanFilter']
    forceHide: Union[None, _bool, 'types.BooleanFilter']
    isCarousel: Union[None, _bool, 'types.BooleanFilter']
    publishedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdBy: Union[None, _int, 'types.IntFilter']
    updatedBy: Union[None, _int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeFilter']
    markets: 'MarketListRelationFilter'
    Event: 'EventListRelationFilter'



# aggregate Tag types


    

class TagScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    forceShow: Union[_bool, 'types.BooleanWithAggregatesFilter']
    forceHide: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCarousel: Union[_bool, 'types.BooleanWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TagScalarWhereWithAggregatesInputRecursive1']
    OR: List['TagScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TagScalarWhereWithAggregatesInputRecursive1']


class TagScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    forceShow: Union[_bool, 'types.BooleanWithAggregatesFilter']
    forceHide: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCarousel: Union[_bool, 'types.BooleanWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TagScalarWhereWithAggregatesInputRecursive2']
    OR: List['TagScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TagScalarWhereWithAggregatesInputRecursive2']


class TagScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    forceShow: Union[_bool, 'types.BooleanWithAggregatesFilter']
    forceHide: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCarousel: Union[_bool, 'types.BooleanWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TagScalarWhereWithAggregatesInputRecursive3']
    OR: List['TagScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TagScalarWhereWithAggregatesInputRecursive3']


class TagScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    forceShow: Union[_bool, 'types.BooleanWithAggregatesFilter']
    forceHide: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCarousel: Union[_bool, 'types.BooleanWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TagScalarWhereWithAggregatesInputRecursive4']
    OR: List['TagScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TagScalarWhereWithAggregatesInputRecursive4']


class TagScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Tag arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    label: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    forceShow: Union[_bool, 'types.BooleanWithAggregatesFilter']
    forceHide: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCarousel: Union[_bool, 'types.BooleanWithAggregatesFilter']
    publishedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdBy: Union[_int, 'types.IntWithAggregatesFilter']
    updatedBy: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdInDb: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class TagGroupByOutput(TypedDict, total=False):
    id: _str
    label: _str
    slug: _str
    forceShow: _bool
    forceHide: _bool
    isCarousel: _bool
    publishedAt: datetime.datetime
    createdBy: _int
    updatedBy: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime
    _sum: 'TagSumAggregateOutput'
    _avg: 'TagAvgAggregateOutput'
    _min: 'TagMinAggregateOutput'
    _max: 'TagMaxAggregateOutput'
    _count: 'TagCountAggregateOutput'


class TagAvgAggregateOutput(TypedDict, total=False):
    """Tag output for aggregating averages"""
    createdBy: float
    updatedBy: float


class TagSumAggregateOutput(TypedDict, total=False):
    """Tag output for aggregating sums"""
    createdBy: _int
    updatedBy: _int


class TagScalarAggregateOutput(TypedDict, total=False):
    """Tag output including scalar fields"""
    id: _str
    label: _str
    slug: _str
    forceShow: _bool
    forceHide: _bool
    isCarousel: _bool
    publishedAt: datetime.datetime
    createdBy: _int
    updatedBy: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    scrapedAt: datetime.datetime
    createdInDb: datetime.datetime


TagMinAggregateOutput = TagScalarAggregateOutput
TagMaxAggregateOutput = TagScalarAggregateOutput


class TagMaxAggregateInput(TypedDict, total=False):
    """Tag input for aggregating by max"""
    id: bool
    label: bool
    slug: bool
    forceShow: bool
    forceHide: bool
    isCarousel: bool
    publishedAt: bool
    createdBy: bool
    updatedBy: bool
    createdAt: bool
    updatedAt: bool
    scrapedAt: bool
    createdInDb: bool


class TagMinAggregateInput(TypedDict, total=False):
    """Tag input for aggregating by min"""
    id: bool
    label: bool
    slug: bool
    forceShow: bool
    forceHide: bool
    isCarousel: bool
    publishedAt: bool
    createdBy: bool
    updatedBy: bool
    createdAt: bool
    updatedAt: bool
    scrapedAt: bool
    createdInDb: bool


class TagNumberAggregateInput(TypedDict, total=False):
    """Tag input for aggregating numbers"""
    createdBy: bool
    updatedBy: bool


TagAvgAggregateInput = TagNumberAggregateInput
TagSumAggregateInput = TagNumberAggregateInput


TagCountAggregateInput = TypedDict(
    'TagCountAggregateInput',
    {
        'id': bool,
        'label': bool,
        'slug': bool,
        'forceShow': bool,
        'forceHide': bool,
        'isCarousel': bool,
        'publishedAt': bool,
        'createdBy': bool,
        'updatedBy': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'scrapedAt': bool,
        'createdInDb': bool,
        '_all': bool,
    },
    total=False,
)

TagCountAggregateOutput = TypedDict(
    'TagCountAggregateOutput',
    {
        'id': int,
        'label': int,
        'slug': int,
        'forceShow': int,
        'forceHide': int,
        'isCarousel': int,
        'publishedAt': int,
        'createdBy': int,
        'updatedBy': int,
        'createdAt': int,
        'updatedAt': int,
        'scrapedAt': int,
        'createdInDb': int,
        '_all': int,
    },
    total=False,
)


TagKeys = Literal[
    'id',
    'label',
    'slug',
    'forceShow',
    'forceHide',
    'isCarousel',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'scrapedAt',
    'createdInDb',
    'markets',
    'Event',
]
TagScalarFieldKeys = Literal[
    'id',
    'label',
    'slug',
    'forceShow',
    'forceHide',
    'isCarousel',
    'publishedAt',
    'createdBy',
    'updatedBy',
    'createdAt',
    'updatedAt',
    'scrapedAt',
    'createdInDb',
]
TagScalarFieldKeysT = TypeVar('TagScalarFieldKeysT', bound=TagScalarFieldKeys)

TagRelationalFieldKeys = Literal[
        'markets',
        'Event',
    ]

# Comment types

class CommentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Comment create method"""
    userAddress: _str
    replyAddress: Optional[_str]
    parentEntityID: _str
    reactionCount: _int
    reportCount: _int
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    profile: 'UserProfileCreateNestedWithoutRelationsInput'
    event: 'EventCreateNestedWithoutRelationsInput'
    parentCommentID: Optional[_str]
    parentComment: 'CommentCreateNestedWithoutRelationsInput'
    childComments: 'CommentCreateManyNestedWithoutRelationsInput'
    reactions: 'CommentReactionCreateManyNestedWithoutRelationsInput'


class CommentCreateInput(CommentOptionalCreateInput):
    """Required arguments to the Comment create method"""
    id: _str
    body: _str
    parentEntityType: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Comment create method, without relations"""
    userAddress: _str
    replyAddress: Optional[_str]
    parentEntityID: _str
    reactionCount: _int
    reportCount: _int
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    parentCommentID: Optional[_str]


class CommentCreateWithoutRelationsInput(CommentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Comment create method, without relations"""
    id: _str
    body: _str
    parentEntityType: _str

class CommentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CommentCreateWithoutRelationsInput'
    where: 'CommentWhereUniqueInput'

class CommentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCreateWithoutRelationsInput'
    connect: 'CommentWhereUniqueInput'
    connect_or_create: 'CommentConnectOrCreateWithoutRelationsInput'


class CommentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommentCreateWithoutRelationsInput', List['CommentCreateWithoutRelationsInput']]
    connect: Union['CommentWhereUniqueInput', List['CommentWhereUniqueInput']]
    connect_or_create: Union['CommentConnectOrCreateWithoutRelationsInput', List['CommentConnectOrCreateWithoutRelationsInput']]

_CommentWhereUnique_id_Input = TypedDict(
    '_CommentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CommentWhereUniqueInput = _CommentWhereUnique_id_Input


class CommentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    body: _str
    replyAddress: Optional[_str]
    parentEntityType: _str
    reactionCount: Union[AtomicIntInput, _int]
    reportCount: Union[AtomicIntInput, _int]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime
    profile: 'UserProfileUpdateOneWithoutRelationsInput'
    event: 'EventUpdateOneWithoutRelationsInput'
    parentComment: 'CommentUpdateOneWithoutRelationsInput'
    childComments: 'CommentUpdateManyWithoutRelationsInput'
    reactions: 'CommentReactionUpdateManyWithoutRelationsInput'


class CommentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    body: _str
    replyAddress: Optional[_str]
    parentEntityType: _str
    reactionCount: Union[AtomicIntInput, _int]
    reportCount: Union[AtomicIntInput, _int]
    createdAt: Optional[datetime.datetime]
    updatedAt: Optional[datetime.datetime]
    scrapedAt: datetime.datetime


class CommentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommentCreateWithoutRelationsInput']
    connect: List['CommentWhereUniqueInput']
    connect_or_create: List['CommentConnectOrCreateWithoutRelationsInput']
    set: List['CommentWhereUniqueInput']
    disconnect: List['CommentWhereUniqueInput']
    delete: List['CommentWhereUniqueInput']

    # TODO
    # update: List['CommentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommentScalarWhereInput']
    # upsert: List['CommentUpserteWithWhereUniqueWithoutRelationsInput']


class CommentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCreateWithoutRelationsInput'
    connect: 'CommentWhereUniqueInput'
    connect_or_create: 'CommentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommentUpdateInput'
    # upsert: 'CommentUpsertWithoutRelationsInput'


class CommentUpsertInput(TypedDict):
    create: 'CommentCreateInput'
    update: 'CommentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Comment_id_OrderByInput = TypedDict(
    '_Comment_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Comment_body_OrderByInput = TypedDict(
    '_Comment_body_OrderByInput',
    {
        'body': 'SortOrder',
    },
    total=True
)

_Comment_userAddress_OrderByInput = TypedDict(
    '_Comment_userAddress_OrderByInput',
    {
        'userAddress': 'SortOrder',
    },
    total=True
)

_Comment_replyAddress_OrderByInput = TypedDict(
    '_Comment_replyAddress_OrderByInput',
    {
        'replyAddress': 'SortOrder',
    },
    total=True
)

_Comment_parentEntityType_OrderByInput = TypedDict(
    '_Comment_parentEntityType_OrderByInput',
    {
        'parentEntityType': 'SortOrder',
    },
    total=True
)

_Comment_parentEntityID_OrderByInput = TypedDict(
    '_Comment_parentEntityID_OrderByInput',
    {
        'parentEntityID': 'SortOrder',
    },
    total=True
)

_Comment_reactionCount_OrderByInput = TypedDict(
    '_Comment_reactionCount_OrderByInput',
    {
        'reactionCount': 'SortOrder',
    },
    total=True
)

_Comment_reportCount_OrderByInput = TypedDict(
    '_Comment_reportCount_OrderByInput',
    {
        'reportCount': 'SortOrder',
    },
    total=True
)

_Comment_createdAt_OrderByInput = TypedDict(
    '_Comment_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Comment_updatedAt_OrderByInput = TypedDict(
    '_Comment_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Comment_scrapedAt_OrderByInput = TypedDict(
    '_Comment_scrapedAt_OrderByInput',
    {
        'scrapedAt': 'SortOrder',
    },
    total=True
)

_Comment_parentCommentID_OrderByInput = TypedDict(
    '_Comment_parentCommentID_OrderByInput',
    {
        'parentCommentID': 'SortOrder',
    },
    total=True
)

_Comment_RelevanceInner = TypedDict(
    '_Comment_RelevanceInner',
    {
        'fields': 'List[CommentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Comment_RelevanceOrderByInput = TypedDict(
    '_Comment_RelevanceOrderByInput',
    {
        '_relevance': '_Comment_RelevanceInner',
    },
    total=True
)

CommentOrderByInput = Union[
    '_Comment_id_OrderByInput',
    '_Comment_body_OrderByInput',
    '_Comment_userAddress_OrderByInput',
    '_Comment_replyAddress_OrderByInput',
    '_Comment_parentEntityType_OrderByInput',
    '_Comment_parentEntityID_OrderByInput',
    '_Comment_reactionCount_OrderByInput',
    '_Comment_reportCount_OrderByInput',
    '_Comment_createdAt_OrderByInput',
    '_Comment_updatedAt_OrderByInput',
    '_Comment_scrapedAt_OrderByInput',
    '_Comment_parentCommentID_OrderByInput',
    '_Comment_RelevanceOrderByInput',
]



# recursive Comment types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CommentRelationFilter = TypedDict(
    'CommentRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CommentListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CommentInclude(TypedDict, total=False):
    """Comment relational arguments"""
    profile: Union[bool, 'UserProfileArgsFromComment']
    event: Union[bool, 'EventArgsFromComment']
    parentComment: Union[bool, 'CommentArgsFromComment']
    childComments: Union[bool, 'FindManyCommentArgsFromComment']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromComment']


    

class EventIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentRecursive1']


class EventIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentRecursive2']


class EventIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentRecursive3']


class EventIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentRecursive4']


class EventIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class EventArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyEventArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    events: Union[bool, 'FindManyEventArgsFromCommentRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentRecursive1']


class MarketIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    events: Union[bool, 'FindManyEventArgsFromCommentRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentRecursive2']


class MarketIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    events: Union[bool, 'FindManyEventArgsFromCommentRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentRecursive3']


class MarketIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    events: Union[bool, 'FindManyEventArgsFromCommentRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentRecursive4']


class MarketIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class MarketArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyMarketArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    market: Union[bool, 'MarketArgsFromCommentRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentRecursive1']


class MarketOutcomeIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    market: Union[bool, 'MarketArgsFromCommentRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentRecursive2']


class MarketOutcomeIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    market: Union[bool, 'MarketArgsFromCommentRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentRecursive3']


class MarketOutcomeIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    market: Union[bool, 'MarketArgsFromCommentRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentRecursive4']


class MarketOutcomeIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class MarketOutcomeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyMarketOutcomeArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromCommentRecursive1']


class TagIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromCommentRecursive2']


class TagIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromCommentRecursive3']


class TagIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromCommentRecursive4']


class TagIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class TagArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyTagArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    profile: Union[bool, 'UserProfileArgsFromCommentRecursive1']
    event: Union[bool, 'EventArgsFromCommentRecursive1']
    parentComment: Union[bool, 'CommentArgsFromCommentRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentRecursive1']


class CommentIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    profile: Union[bool, 'UserProfileArgsFromCommentRecursive2']
    event: Union[bool, 'EventArgsFromCommentRecursive2']
    parentComment: Union[bool, 'CommentArgsFromCommentRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentRecursive2']


class CommentIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    profile: Union[bool, 'UserProfileArgsFromCommentRecursive3']
    event: Union[bool, 'EventArgsFromCommentRecursive3']
    parentComment: Union[bool, 'CommentArgsFromCommentRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentRecursive3']


class CommentIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    profile: Union[bool, 'UserProfileArgsFromCommentRecursive4']
    event: Union[bool, 'EventArgsFromCommentRecursive4']
    parentComment: Union[bool, 'CommentArgsFromCommentRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentRecursive4']


class CommentIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class CommentArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyCommentArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    comment: Union[bool, 'CommentArgsFromCommentRecursive1']


class CommentReactionIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    comment: Union[bool, 'CommentArgsFromCommentRecursive2']


class CommentReactionIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    comment: Union[bool, 'CommentArgsFromCommentRecursive3']


class CommentReactionIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    comment: Union[bool, 'CommentArgsFromCommentRecursive4']


class CommentReactionIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class CommentReactionArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyCommentReactionArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive1']


class UserProfileIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive2']


class UserProfileIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive3']


class UserProfileIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentRecursive4']


class UserProfileIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class UserProfileArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyUserProfileArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    event: Union[bool, 'EventArgsFromCommentRecursive1']


class CommentCheckpointIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    event: Union[bool, 'EventArgsFromCommentRecursive2']


class CommentCheckpointIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    event: Union[bool, 'EventArgsFromCommentRecursive3']


class CommentCheckpointIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    event: Union[bool, 'EventArgsFromCommentRecursive4']


class CommentCheckpointIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class CommentCheckpointArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyCommentCheckpointArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentRecursive1']


class TokenPriceIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentRecursive2']


class TokenPriceIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentRecursive3']


class TokenPriceIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentRecursive4']


class TokenPriceIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class TokenPriceArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyTokenPriceArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromComment(TypedDict, total=False):
    """Relational arguments for Comment"""


class ScraperRunIncludeFromCommentRecursive1(TypedDict, total=False):
    """Relational arguments for Comment"""


class ScraperRunIncludeFromCommentRecursive2(TypedDict, total=False):
    """Relational arguments for Comment"""


class ScraperRunIncludeFromCommentRecursive3(TypedDict, total=False):
    """Relational arguments for Comment"""


class ScraperRunIncludeFromCommentRecursive4(TypedDict, total=False):
    """Relational arguments for Comment"""

    

class ScraperRunArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    
    

class FindManyScraperRunArgsFromComment(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromCommentRecursive1(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromCommentRecursive2(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromCommentRecursive3(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromCommentRecursive4(TypedDict, total=False):
    """Arguments for Comment"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyCommentArgs = FindManyCommentArgsFromComment
FindFirstCommentArgs = FindManyCommentArgsFromComment


    

class CommentWhereInput(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    body: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    replyAddress: Union[None, _str, 'types.StringFilter']
    parentEntityType: Union[_str, 'types.StringFilter']
    parentEntityID: Union[_str, 'types.StringFilter']
    reactionCount: Union[_int, 'types.IntFilter']
    reportCount: Union[_int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    profile: 'UserProfileRelationFilter'
    event: 'EventRelationFilter'
    parentCommentID: Union[None, _str, 'types.StringFilter']
    parentComment: 'CommentRelationFilter'
    childComments: 'CommentListRelationFilter'
    reactions: 'CommentReactionListRelationFilter'

    # should be noted that AND and NOT should be Union['CommentWhereInputRecursive1', List['CommentWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CommentWhereInputRecursive1']
    OR: List['CommentWhereInputRecursive1']
    NOT: List['CommentWhereInputRecursive1']


class CommentWhereInputRecursive1(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    body: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    replyAddress: Union[None, _str, 'types.StringFilter']
    parentEntityType: Union[_str, 'types.StringFilter']
    parentEntityID: Union[_str, 'types.StringFilter']
    reactionCount: Union[_int, 'types.IntFilter']
    reportCount: Union[_int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    profile: 'UserProfileRelationFilter'
    event: 'EventRelationFilter'
    parentCommentID: Union[None, _str, 'types.StringFilter']
    parentComment: 'CommentRelationFilter'
    childComments: 'CommentListRelationFilter'
    reactions: 'CommentReactionListRelationFilter'

    # should be noted that AND and NOT should be Union['CommentWhereInputRecursive2', List['CommentWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CommentWhereInputRecursive2']
    OR: List['CommentWhereInputRecursive2']
    NOT: List['CommentWhereInputRecursive2']


class CommentWhereInputRecursive2(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    body: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    replyAddress: Union[None, _str, 'types.StringFilter']
    parentEntityType: Union[_str, 'types.StringFilter']
    parentEntityID: Union[_str, 'types.StringFilter']
    reactionCount: Union[_int, 'types.IntFilter']
    reportCount: Union[_int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    profile: 'UserProfileRelationFilter'
    event: 'EventRelationFilter'
    parentCommentID: Union[None, _str, 'types.StringFilter']
    parentComment: 'CommentRelationFilter'
    childComments: 'CommentListRelationFilter'
    reactions: 'CommentReactionListRelationFilter'

    # should be noted that AND and NOT should be Union['CommentWhereInputRecursive3', List['CommentWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CommentWhereInputRecursive3']
    OR: List['CommentWhereInputRecursive3']
    NOT: List['CommentWhereInputRecursive3']


class CommentWhereInputRecursive3(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    body: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    replyAddress: Union[None, _str, 'types.StringFilter']
    parentEntityType: Union[_str, 'types.StringFilter']
    parentEntityID: Union[_str, 'types.StringFilter']
    reactionCount: Union[_int, 'types.IntFilter']
    reportCount: Union[_int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    profile: 'UserProfileRelationFilter'
    event: 'EventRelationFilter'
    parentCommentID: Union[None, _str, 'types.StringFilter']
    parentComment: 'CommentRelationFilter'
    childComments: 'CommentListRelationFilter'
    reactions: 'CommentReactionListRelationFilter'

    # should be noted that AND and NOT should be Union['CommentWhereInputRecursive4', List['CommentWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CommentWhereInputRecursive4']
    OR: List['CommentWhereInputRecursive4']
    NOT: List['CommentWhereInputRecursive4']


class CommentWhereInputRecursive4(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    body: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    replyAddress: Union[None, _str, 'types.StringFilter']
    parentEntityType: Union[_str, 'types.StringFilter']
    parentEntityID: Union[_str, 'types.StringFilter']
    reactionCount: Union[_int, 'types.IntFilter']
    reportCount: Union[_int, 'types.IntFilter']
    createdAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    profile: 'UserProfileRelationFilter'
    event: 'EventRelationFilter'
    parentCommentID: Union[None, _str, 'types.StringFilter']
    parentComment: 'CommentRelationFilter'
    childComments: 'CommentListRelationFilter'
    reactions: 'CommentReactionListRelationFilter'



# aggregate Comment types


    

class CommentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    replyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityType: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityID: Union[_str, 'types.StringWithAggregatesFilter']
    reactionCount: Union[_int, 'types.IntWithAggregatesFilter']
    reportCount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentCommentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentScalarWhereWithAggregatesInputRecursive1']
    OR: List['CommentScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CommentScalarWhereWithAggregatesInputRecursive1']


class CommentScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    replyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityType: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityID: Union[_str, 'types.StringWithAggregatesFilter']
    reactionCount: Union[_int, 'types.IntWithAggregatesFilter']
    reportCount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentCommentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentScalarWhereWithAggregatesInputRecursive2']
    OR: List['CommentScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CommentScalarWhereWithAggregatesInputRecursive2']


class CommentScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    replyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityType: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityID: Union[_str, 'types.StringWithAggregatesFilter']
    reactionCount: Union[_int, 'types.IntWithAggregatesFilter']
    reportCount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentCommentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentScalarWhereWithAggregatesInputRecursive3']
    OR: List['CommentScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CommentScalarWhereWithAggregatesInputRecursive3']


class CommentScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    replyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityType: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityID: Union[_str, 'types.StringWithAggregatesFilter']
    reactionCount: Union[_int, 'types.IntWithAggregatesFilter']
    reportCount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentCommentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentScalarWhereWithAggregatesInputRecursive4']
    OR: List['CommentScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CommentScalarWhereWithAggregatesInputRecursive4']


class CommentScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Comment arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    body: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    replyAddress: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityType: Union[_str, 'types.StringWithAggregatesFilter']
    parentEntityID: Union[_str, 'types.StringWithAggregatesFilter']
    reactionCount: Union[_int, 'types.IntWithAggregatesFilter']
    reportCount: Union[_int, 'types.IntWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    scrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    parentCommentID: Union[_str, 'types.StringWithAggregatesFilter']



class CommentGroupByOutput(TypedDict, total=False):
    id: _str
    body: _str
    userAddress: _str
    replyAddress: _str
    parentEntityType: _str
    parentEntityID: _str
    reactionCount: _int
    reportCount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    scrapedAt: datetime.datetime
    parentCommentID: _str
    _sum: 'CommentSumAggregateOutput'
    _avg: 'CommentAvgAggregateOutput'
    _min: 'CommentMinAggregateOutput'
    _max: 'CommentMaxAggregateOutput'
    _count: 'CommentCountAggregateOutput'


class CommentAvgAggregateOutput(TypedDict, total=False):
    """Comment output for aggregating averages"""
    reactionCount: float
    reportCount: float


class CommentSumAggregateOutput(TypedDict, total=False):
    """Comment output for aggregating sums"""
    reactionCount: _int
    reportCount: _int


class CommentScalarAggregateOutput(TypedDict, total=False):
    """Comment output including scalar fields"""
    id: _str
    body: _str
    userAddress: _str
    replyAddress: _str
    parentEntityType: _str
    parentEntityID: _str
    reactionCount: _int
    reportCount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    scrapedAt: datetime.datetime
    parentCommentID: _str


CommentMinAggregateOutput = CommentScalarAggregateOutput
CommentMaxAggregateOutput = CommentScalarAggregateOutput


class CommentMaxAggregateInput(TypedDict, total=False):
    """Comment input for aggregating by max"""
    id: bool
    body: bool
    userAddress: bool
    replyAddress: bool
    parentEntityType: bool
    parentEntityID: bool
    reactionCount: bool
    reportCount: bool
    createdAt: bool
    updatedAt: bool
    scrapedAt: bool
    parentCommentID: bool


class CommentMinAggregateInput(TypedDict, total=False):
    """Comment input for aggregating by min"""
    id: bool
    body: bool
    userAddress: bool
    replyAddress: bool
    parentEntityType: bool
    parentEntityID: bool
    reactionCount: bool
    reportCount: bool
    createdAt: bool
    updatedAt: bool
    scrapedAt: bool
    parentCommentID: bool


class CommentNumberAggregateInput(TypedDict, total=False):
    """Comment input for aggregating numbers"""
    reactionCount: bool
    reportCount: bool


CommentAvgAggregateInput = CommentNumberAggregateInput
CommentSumAggregateInput = CommentNumberAggregateInput


CommentCountAggregateInput = TypedDict(
    'CommentCountAggregateInput',
    {
        'id': bool,
        'body': bool,
        'userAddress': bool,
        'replyAddress': bool,
        'parentEntityType': bool,
        'parentEntityID': bool,
        'reactionCount': bool,
        'reportCount': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'scrapedAt': bool,
        'parentCommentID': bool,
        '_all': bool,
    },
    total=False,
)

CommentCountAggregateOutput = TypedDict(
    'CommentCountAggregateOutput',
    {
        'id': int,
        'body': int,
        'userAddress': int,
        'replyAddress': int,
        'parentEntityType': int,
        'parentEntityID': int,
        'reactionCount': int,
        'reportCount': int,
        'createdAt': int,
        'updatedAt': int,
        'scrapedAt': int,
        'parentCommentID': int,
        '_all': int,
    },
    total=False,
)


CommentKeys = Literal[
    'id',
    'body',
    'userAddress',
    'replyAddress',
    'parentEntityType',
    'parentEntityID',
    'reactionCount',
    'reportCount',
    'createdAt',
    'updatedAt',
    'scrapedAt',
    'profile',
    'event',
    'parentCommentID',
    'parentComment',
    'childComments',
    'reactions',
]
CommentScalarFieldKeys = Literal[
    'id',
    'body',
    'userAddress',
    'replyAddress',
    'parentEntityType',
    'parentEntityID',
    'reactionCount',
    'reportCount',
    'createdAt',
    'updatedAt',
    'scrapedAt',
    'parentCommentID',
]
CommentScalarFieldKeysT = TypeVar('CommentScalarFieldKeysT', bound=CommentScalarFieldKeys)

CommentRelationalFieldKeys = Literal[
        'profile',
        'event',
        'parentComment',
        'childComments',
        'reactions',
    ]

# CommentReaction types

class CommentReactionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CommentReaction create method"""
    commentID: _str
    comment: 'CommentCreateNestedWithoutRelationsInput'


class CommentReactionCreateInput(CommentReactionOptionalCreateInput):
    """Required arguments to the CommentReaction create method"""
    id: _str
    reactionType: _str
    userAddress: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommentReactionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CommentReaction create method, without relations"""
    commentID: _str


class CommentReactionCreateWithoutRelationsInput(CommentReactionOptionalCreateWithoutRelationsInput):
    """Required arguments to the CommentReaction create method, without relations"""
    id: _str
    reactionType: _str
    userAddress: _str

class CommentReactionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CommentReactionCreateWithoutRelationsInput'
    where: 'CommentReactionWhereUniqueInput'

class CommentReactionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentReactionCreateWithoutRelationsInput'
    connect: 'CommentReactionWhereUniqueInput'
    connect_or_create: 'CommentReactionConnectOrCreateWithoutRelationsInput'


class CommentReactionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommentReactionCreateWithoutRelationsInput', List['CommentReactionCreateWithoutRelationsInput']]
    connect: Union['CommentReactionWhereUniqueInput', List['CommentReactionWhereUniqueInput']]
    connect_or_create: Union['CommentReactionConnectOrCreateWithoutRelationsInput', List['CommentReactionConnectOrCreateWithoutRelationsInput']]

_CommentReactionWhereUnique_id_Input = TypedDict(
    '_CommentReactionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CommentReactionWhereUniqueInput = _CommentReactionWhereUnique_id_Input


class CommentReactionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    reactionType: _str
    userAddress: _str
    comment: 'CommentUpdateOneWithoutRelationsInput'


class CommentReactionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    reactionType: _str
    userAddress: _str


class CommentReactionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommentReactionCreateWithoutRelationsInput']
    connect: List['CommentReactionWhereUniqueInput']
    connect_or_create: List['CommentReactionConnectOrCreateWithoutRelationsInput']
    set: List['CommentReactionWhereUniqueInput']
    disconnect: List['CommentReactionWhereUniqueInput']
    delete: List['CommentReactionWhereUniqueInput']

    # TODO
    # update: List['CommentReactionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommentReactionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommentReactionScalarWhereInput']
    # upsert: List['CommentReactionUpserteWithWhereUniqueWithoutRelationsInput']


class CommentReactionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentReactionCreateWithoutRelationsInput'
    connect: 'CommentReactionWhereUniqueInput'
    connect_or_create: 'CommentReactionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommentReactionUpdateInput'
    # upsert: 'CommentReactionUpsertWithoutRelationsInput'


class CommentReactionUpsertInput(TypedDict):
    create: 'CommentReactionCreateInput'
    update: 'CommentReactionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CommentReaction_id_OrderByInput = TypedDict(
    '_CommentReaction_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CommentReaction_reactionType_OrderByInput = TypedDict(
    '_CommentReaction_reactionType_OrderByInput',
    {
        'reactionType': 'SortOrder',
    },
    total=True
)

_CommentReaction_userAddress_OrderByInput = TypedDict(
    '_CommentReaction_userAddress_OrderByInput',
    {
        'userAddress': 'SortOrder',
    },
    total=True
)

_CommentReaction_commentID_OrderByInput = TypedDict(
    '_CommentReaction_commentID_OrderByInput',
    {
        'commentID': 'SortOrder',
    },
    total=True
)

_CommentReaction_RelevanceInner = TypedDict(
    '_CommentReaction_RelevanceInner',
    {
        'fields': 'List[CommentReactionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_CommentReaction_RelevanceOrderByInput = TypedDict(
    '_CommentReaction_RelevanceOrderByInput',
    {
        '_relevance': '_CommentReaction_RelevanceInner',
    },
    total=True
)

CommentReactionOrderByInput = Union[
    '_CommentReaction_id_OrderByInput',
    '_CommentReaction_reactionType_OrderByInput',
    '_CommentReaction_userAddress_OrderByInput',
    '_CommentReaction_commentID_OrderByInput',
    '_CommentReaction_RelevanceOrderByInput',
]



# recursive CommentReaction types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CommentReactionRelationFilter = TypedDict(
    'CommentReactionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CommentReactionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CommentReactionInclude(TypedDict, total=False):
    """CommentReaction relational arguments"""
    comment: Union[bool, 'CommentArgsFromCommentReaction']


    

class EventIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentReactionRecursive1']


class EventIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentReactionRecursive2']


class EventIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentReactionRecursive3']


class EventIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentReactionRecursive4']


class EventIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class EventArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyEventArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    events: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentReactionRecursive1']


class MarketIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    events: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentReactionRecursive2']


class MarketIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    events: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentReactionRecursive3']


class MarketIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    events: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentReactionRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentReactionRecursive4']


class MarketIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class MarketArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyMarketArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    market: Union[bool, 'MarketArgsFromCommentReactionRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentReactionRecursive1']


class MarketOutcomeIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    market: Union[bool, 'MarketArgsFromCommentReactionRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentReactionRecursive2']


class MarketOutcomeIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    market: Union[bool, 'MarketArgsFromCommentReactionRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentReactionRecursive3']


class MarketOutcomeIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    market: Union[bool, 'MarketArgsFromCommentReactionRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentReactionRecursive4']


class MarketOutcomeIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class MarketOutcomeArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyMarketOutcomeArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive1']


class TagIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive2']


class TagIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive3']


class TagIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentReactionRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromCommentReactionRecursive4']


class TagIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class TagArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyTagArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    profile: Union[bool, 'UserProfileArgsFromCommentReactionRecursive1']
    event: Union[bool, 'EventArgsFromCommentReactionRecursive1']
    parentComment: Union[bool, 'CommentArgsFromCommentReactionRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentReactionRecursive1']


class CommentIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    profile: Union[bool, 'UserProfileArgsFromCommentReactionRecursive2']
    event: Union[bool, 'EventArgsFromCommentReactionRecursive2']
    parentComment: Union[bool, 'CommentArgsFromCommentReactionRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentReactionRecursive2']


class CommentIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    profile: Union[bool, 'UserProfileArgsFromCommentReactionRecursive3']
    event: Union[bool, 'EventArgsFromCommentReactionRecursive3']
    parentComment: Union[bool, 'CommentArgsFromCommentReactionRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentReactionRecursive3']


class CommentIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    profile: Union[bool, 'UserProfileArgsFromCommentReactionRecursive4']
    event: Union[bool, 'EventArgsFromCommentReactionRecursive4']
    parentComment: Union[bool, 'CommentArgsFromCommentReactionRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentReactionRecursive4']


class CommentIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class CommentArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyCommentArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    comment: Union[bool, 'CommentArgsFromCommentReactionRecursive1']


class CommentReactionIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    comment: Union[bool, 'CommentArgsFromCommentReactionRecursive2']


class CommentReactionIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    comment: Union[bool, 'CommentArgsFromCommentReactionRecursive3']


class CommentReactionIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    comment: Union[bool, 'CommentArgsFromCommentReactionRecursive4']


class CommentReactionIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class CommentReactionArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyCommentReactionArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive1']


class UserProfileIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive2']


class UserProfileIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive3']


class UserProfileIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentReactionRecursive4']


class UserProfileIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class UserProfileArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyUserProfileArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    event: Union[bool, 'EventArgsFromCommentReactionRecursive1']


class CommentCheckpointIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    event: Union[bool, 'EventArgsFromCommentReactionRecursive2']


class CommentCheckpointIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    event: Union[bool, 'EventArgsFromCommentReactionRecursive3']


class CommentCheckpointIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    event: Union[bool, 'EventArgsFromCommentReactionRecursive4']


class CommentCheckpointIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class CommentCheckpointArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyCommentCheckpointArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentReactionRecursive1']


class TokenPriceIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentReactionRecursive2']


class TokenPriceIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentReactionRecursive3']


class TokenPriceIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentReactionRecursive4']


class TokenPriceIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class TokenPriceArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyTokenPriceArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromCommentReaction(TypedDict, total=False):
    """Relational arguments for CommentReaction"""


class ScraperRunIncludeFromCommentReactionRecursive1(TypedDict, total=False):
    """Relational arguments for CommentReaction"""


class ScraperRunIncludeFromCommentReactionRecursive2(TypedDict, total=False):
    """Relational arguments for CommentReaction"""


class ScraperRunIncludeFromCommentReactionRecursive3(TypedDict, total=False):
    """Relational arguments for CommentReaction"""


class ScraperRunIncludeFromCommentReactionRecursive4(TypedDict, total=False):
    """Relational arguments for CommentReaction"""

    

class ScraperRunArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    
    

class FindManyScraperRunArgsFromCommentReaction(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromCommentReactionRecursive1(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromCommentReactionRecursive2(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromCommentReactionRecursive3(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromCommentReactionRecursive4(TypedDict, total=False):
    """Arguments for CommentReaction"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyCommentReactionArgs = FindManyCommentReactionArgsFromCommentReaction
FindFirstCommentReactionArgs = FindManyCommentReactionArgsFromCommentReaction


    

class CommentReactionWhereInput(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reactionType: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    commentID: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'

    # should be noted that AND and NOT should be Union['CommentReactionWhereInputRecursive1', List['CommentReactionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CommentReactionWhereInputRecursive1']
    OR: List['CommentReactionWhereInputRecursive1']
    NOT: List['CommentReactionWhereInputRecursive1']


class CommentReactionWhereInputRecursive1(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reactionType: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    commentID: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'

    # should be noted that AND and NOT should be Union['CommentReactionWhereInputRecursive2', List['CommentReactionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CommentReactionWhereInputRecursive2']
    OR: List['CommentReactionWhereInputRecursive2']
    NOT: List['CommentReactionWhereInputRecursive2']


class CommentReactionWhereInputRecursive2(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reactionType: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    commentID: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'

    # should be noted that AND and NOT should be Union['CommentReactionWhereInputRecursive3', List['CommentReactionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CommentReactionWhereInputRecursive3']
    OR: List['CommentReactionWhereInputRecursive3']
    NOT: List['CommentReactionWhereInputRecursive3']


class CommentReactionWhereInputRecursive3(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reactionType: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    commentID: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'

    # should be noted that AND and NOT should be Union['CommentReactionWhereInputRecursive4', List['CommentReactionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CommentReactionWhereInputRecursive4']
    OR: List['CommentReactionWhereInputRecursive4']
    NOT: List['CommentReactionWhereInputRecursive4']


class CommentReactionWhereInputRecursive4(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    reactionType: Union[_str, 'types.StringFilter']
    userAddress: Union[_str, 'types.StringFilter']
    commentID: Union[_str, 'types.StringFilter']
    comment: 'CommentRelationFilter'



# aggregate CommentReaction types


    

class CommentReactionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reactionType: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    commentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentReactionScalarWhereWithAggregatesInputRecursive1']
    OR: List['CommentReactionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CommentReactionScalarWhereWithAggregatesInputRecursive1']


class CommentReactionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reactionType: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    commentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentReactionScalarWhereWithAggregatesInputRecursive2']
    OR: List['CommentReactionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CommentReactionScalarWhereWithAggregatesInputRecursive2']


class CommentReactionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reactionType: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    commentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentReactionScalarWhereWithAggregatesInputRecursive3']
    OR: List['CommentReactionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CommentReactionScalarWhereWithAggregatesInputRecursive3']


class CommentReactionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reactionType: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    commentID: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['CommentReactionScalarWhereWithAggregatesInputRecursive4']
    OR: List['CommentReactionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CommentReactionScalarWhereWithAggregatesInputRecursive4']


class CommentReactionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CommentReaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    reactionType: Union[_str, 'types.StringWithAggregatesFilter']
    userAddress: Union[_str, 'types.StringWithAggregatesFilter']
    commentID: Union[_str, 'types.StringWithAggregatesFilter']



class CommentReactionGroupByOutput(TypedDict, total=False):
    id: _str
    reactionType: _str
    userAddress: _str
    commentID: _str
    _sum: 'CommentReactionSumAggregateOutput'
    _avg: 'CommentReactionAvgAggregateOutput'
    _min: 'CommentReactionMinAggregateOutput'
    _max: 'CommentReactionMaxAggregateOutput'
    _count: 'CommentReactionCountAggregateOutput'


class CommentReactionAvgAggregateOutput(TypedDict, total=False):
    """CommentReaction output for aggregating averages"""


class CommentReactionSumAggregateOutput(TypedDict, total=False):
    """CommentReaction output for aggregating sums"""


class CommentReactionScalarAggregateOutput(TypedDict, total=False):
    """CommentReaction output including scalar fields"""
    id: _str
    reactionType: _str
    userAddress: _str
    commentID: _str


CommentReactionMinAggregateOutput = CommentReactionScalarAggregateOutput
CommentReactionMaxAggregateOutput = CommentReactionScalarAggregateOutput


class CommentReactionMaxAggregateInput(TypedDict, total=False):
    """CommentReaction input for aggregating by max"""
    id: bool
    reactionType: bool
    userAddress: bool
    commentID: bool


class CommentReactionMinAggregateInput(TypedDict, total=False):
    """CommentReaction input for aggregating by min"""
    id: bool
    reactionType: bool
    userAddress: bool
    commentID: bool


class CommentReactionNumberAggregateInput(TypedDict, total=False):
    """CommentReaction input for aggregating numbers"""


CommentReactionAvgAggregateInput = CommentReactionNumberAggregateInput
CommentReactionSumAggregateInput = CommentReactionNumberAggregateInput


CommentReactionCountAggregateInput = TypedDict(
    'CommentReactionCountAggregateInput',
    {
        'id': bool,
        'reactionType': bool,
        'userAddress': bool,
        'commentID': bool,
        '_all': bool,
    },
    total=False,
)

CommentReactionCountAggregateOutput = TypedDict(
    'CommentReactionCountAggregateOutput',
    {
        'id': int,
        'reactionType': int,
        'userAddress': int,
        'commentID': int,
        '_all': int,
    },
    total=False,
)


CommentReactionKeys = Literal[
    'id',
    'reactionType',
    'userAddress',
    'commentID',
    'comment',
]
CommentReactionScalarFieldKeys = Literal[
    'id',
    'reactionType',
    'userAddress',
    'commentID',
]
CommentReactionScalarFieldKeysT = TypeVar('CommentReactionScalarFieldKeysT', bound=CommentReactionScalarFieldKeys)

CommentReactionRelationalFieldKeys = Literal[
        'comment',
    ]

# UserProfile types

class UserProfileOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserProfile create method"""
    name: Optional[_str]
    pseudonym: Optional[_str]
    displayUsernamePublic: _bool
    bio: Optional[_str]
    isMod: _bool
    isCreator: _bool
    proxyWallet: Optional[_str]
    baseAddress: Optional[_str]
    profileImage: Optional[_str]
    Comment: 'CommentCreateManyNestedWithoutRelationsInput'


class UserProfileCreateInput(UserProfileOptionalCreateInput):
    """Required arguments to the UserProfile create method"""
    address: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserProfileOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserProfile create method, without relations"""
    name: Optional[_str]
    pseudonym: Optional[_str]
    displayUsernamePublic: _bool
    bio: Optional[_str]
    isMod: _bool
    isCreator: _bool
    proxyWallet: Optional[_str]
    baseAddress: Optional[_str]
    profileImage: Optional[_str]


class UserProfileCreateWithoutRelationsInput(UserProfileOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserProfile create method, without relations"""
    address: _str

class UserProfileConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserProfileCreateWithoutRelationsInput'
    where: 'UserProfileWhereUniqueInput'

class UserProfileCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserProfileCreateWithoutRelationsInput'
    connect: 'UserProfileWhereUniqueInput'
    connect_or_create: 'UserProfileConnectOrCreateWithoutRelationsInput'


class UserProfileCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserProfileCreateWithoutRelationsInput', List['UserProfileCreateWithoutRelationsInput']]
    connect: Union['UserProfileWhereUniqueInput', List['UserProfileWhereUniqueInput']]
    connect_or_create: Union['UserProfileConnectOrCreateWithoutRelationsInput', List['UserProfileConnectOrCreateWithoutRelationsInput']]

_UserProfileWhereUnique_address_Input = TypedDict(
    '_UserProfileWhereUnique_address_Input',
    {
        'address': '_str',
    },
    total=True
)

UserProfileWhereUniqueInput = _UserProfileWhereUnique_address_Input


class UserProfileUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    address: _str
    name: Optional[_str]
    pseudonym: Optional[_str]
    displayUsernamePublic: _bool
    bio: Optional[_str]
    isMod: _bool
    isCreator: _bool
    proxyWallet: Optional[_str]
    baseAddress: Optional[_str]
    profileImage: Optional[_str]
    Comment: 'CommentUpdateManyWithoutRelationsInput'


class UserProfileUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    address: _str
    name: Optional[_str]
    pseudonym: Optional[_str]
    displayUsernamePublic: _bool
    bio: Optional[_str]
    isMod: _bool
    isCreator: _bool
    proxyWallet: Optional[_str]
    baseAddress: Optional[_str]
    profileImage: Optional[_str]


class UserProfileUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserProfileCreateWithoutRelationsInput']
    connect: List['UserProfileWhereUniqueInput']
    connect_or_create: List['UserProfileConnectOrCreateWithoutRelationsInput']
    set: List['UserProfileWhereUniqueInput']
    disconnect: List['UserProfileWhereUniqueInput']
    delete: List['UserProfileWhereUniqueInput']

    # TODO
    # update: List['UserProfileUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserProfileUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserProfileScalarWhereInput']
    # upsert: List['UserProfileUpserteWithWhereUniqueWithoutRelationsInput']


class UserProfileUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserProfileCreateWithoutRelationsInput'
    connect: 'UserProfileWhereUniqueInput'
    connect_or_create: 'UserProfileConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserProfileUpdateInput'
    # upsert: 'UserProfileUpsertWithoutRelationsInput'


class UserProfileUpsertInput(TypedDict):
    create: 'UserProfileCreateInput'
    update: 'UserProfileUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserProfile_address_OrderByInput = TypedDict(
    '_UserProfile_address_OrderByInput',
    {
        'address': 'SortOrder',
    },
    total=True
)

_UserProfile_name_OrderByInput = TypedDict(
    '_UserProfile_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_UserProfile_pseudonym_OrderByInput = TypedDict(
    '_UserProfile_pseudonym_OrderByInput',
    {
        'pseudonym': 'SortOrder',
    },
    total=True
)

_UserProfile_displayUsernamePublic_OrderByInput = TypedDict(
    '_UserProfile_displayUsernamePublic_OrderByInput',
    {
        'displayUsernamePublic': 'SortOrder',
    },
    total=True
)

_UserProfile_bio_OrderByInput = TypedDict(
    '_UserProfile_bio_OrderByInput',
    {
        'bio': 'SortOrder',
    },
    total=True
)

_UserProfile_isMod_OrderByInput = TypedDict(
    '_UserProfile_isMod_OrderByInput',
    {
        'isMod': 'SortOrder',
    },
    total=True
)

_UserProfile_isCreator_OrderByInput = TypedDict(
    '_UserProfile_isCreator_OrderByInput',
    {
        'isCreator': 'SortOrder',
    },
    total=True
)

_UserProfile_proxyWallet_OrderByInput = TypedDict(
    '_UserProfile_proxyWallet_OrderByInput',
    {
        'proxyWallet': 'SortOrder',
    },
    total=True
)

_UserProfile_baseAddress_OrderByInput = TypedDict(
    '_UserProfile_baseAddress_OrderByInput',
    {
        'baseAddress': 'SortOrder',
    },
    total=True
)

_UserProfile_profileImage_OrderByInput = TypedDict(
    '_UserProfile_profileImage_OrderByInput',
    {
        'profileImage': 'SortOrder',
    },
    total=True
)

_UserProfile_RelevanceInner = TypedDict(
    '_UserProfile_RelevanceInner',
    {
        'fields': 'List[UserProfileScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_UserProfile_RelevanceOrderByInput = TypedDict(
    '_UserProfile_RelevanceOrderByInput',
    {
        '_relevance': '_UserProfile_RelevanceInner',
    },
    total=True
)

UserProfileOrderByInput = Union[
    '_UserProfile_address_OrderByInput',
    '_UserProfile_name_OrderByInput',
    '_UserProfile_pseudonym_OrderByInput',
    '_UserProfile_displayUsernamePublic_OrderByInput',
    '_UserProfile_bio_OrderByInput',
    '_UserProfile_isMod_OrderByInput',
    '_UserProfile_isCreator_OrderByInput',
    '_UserProfile_proxyWallet_OrderByInput',
    '_UserProfile_baseAddress_OrderByInput',
    '_UserProfile_profileImage_OrderByInput',
    '_UserProfile_RelevanceOrderByInput',
]



# recursive UserProfile types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserProfileRelationFilter = TypedDict(
    'UserProfileRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserProfileListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserProfileInclude(TypedDict, total=False):
    """UserProfile relational arguments"""
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfile']


    

class EventIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromUserProfileRecursive1']


class EventIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromUserProfileRecursive2']


class EventIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromUserProfileRecursive3']


class EventIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromUserProfileRecursive4']


class EventIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class EventArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyEventArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    events: Union[bool, 'FindManyEventArgsFromUserProfileRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromUserProfileRecursive1']


class MarketIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    events: Union[bool, 'FindManyEventArgsFromUserProfileRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromUserProfileRecursive2']


class MarketIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    events: Union[bool, 'FindManyEventArgsFromUserProfileRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromUserProfileRecursive3']


class MarketIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    events: Union[bool, 'FindManyEventArgsFromUserProfileRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromUserProfileRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromUserProfileRecursive4']


class MarketIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class MarketArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyMarketArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    market: Union[bool, 'MarketArgsFromUserProfileRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromUserProfileRecursive1']


class MarketOutcomeIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    market: Union[bool, 'MarketArgsFromUserProfileRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromUserProfileRecursive2']


class MarketOutcomeIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    market: Union[bool, 'MarketArgsFromUserProfileRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromUserProfileRecursive3']


class MarketOutcomeIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    market: Union[bool, 'MarketArgsFromUserProfileRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromUserProfileRecursive4']


class MarketOutcomeIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class MarketOutcomeArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyMarketOutcomeArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromUserProfileRecursive1']


class TagIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromUserProfileRecursive2']


class TagIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromUserProfileRecursive3']


class TagIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    markets: Union[bool, 'FindManyMarketArgsFromUserProfileRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromUserProfileRecursive4']


class TagIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class TagArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyTagArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    profile: Union[bool, 'UserProfileArgsFromUserProfileRecursive1']
    event: Union[bool, 'EventArgsFromUserProfileRecursive1']
    parentComment: Union[bool, 'CommentArgsFromUserProfileRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromUserProfileRecursive1']


class CommentIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    profile: Union[bool, 'UserProfileArgsFromUserProfileRecursive2']
    event: Union[bool, 'EventArgsFromUserProfileRecursive2']
    parentComment: Union[bool, 'CommentArgsFromUserProfileRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromUserProfileRecursive2']


class CommentIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    profile: Union[bool, 'UserProfileArgsFromUserProfileRecursive3']
    event: Union[bool, 'EventArgsFromUserProfileRecursive3']
    parentComment: Union[bool, 'CommentArgsFromUserProfileRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromUserProfileRecursive3']


class CommentIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    profile: Union[bool, 'UserProfileArgsFromUserProfileRecursive4']
    event: Union[bool, 'EventArgsFromUserProfileRecursive4']
    parentComment: Union[bool, 'CommentArgsFromUserProfileRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromUserProfileRecursive4']


class CommentIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class CommentArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyCommentArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    comment: Union[bool, 'CommentArgsFromUserProfileRecursive1']


class CommentReactionIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    comment: Union[bool, 'CommentArgsFromUserProfileRecursive2']


class CommentReactionIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    comment: Union[bool, 'CommentArgsFromUserProfileRecursive3']


class CommentReactionIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    comment: Union[bool, 'CommentArgsFromUserProfileRecursive4']


class CommentReactionIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class CommentReactionArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyCommentReactionArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive1']


class UserProfileIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive2']


class UserProfileIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive3']


class UserProfileIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    Comment: Union[bool, 'FindManyCommentArgsFromUserProfileRecursive4']


class UserProfileIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class UserProfileArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyUserProfileArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    event: Union[bool, 'EventArgsFromUserProfileRecursive1']


class CommentCheckpointIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    event: Union[bool, 'EventArgsFromUserProfileRecursive2']


class CommentCheckpointIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    event: Union[bool, 'EventArgsFromUserProfileRecursive3']


class CommentCheckpointIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    event: Union[bool, 'EventArgsFromUserProfileRecursive4']


class CommentCheckpointIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class CommentCheckpointArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyCommentCheckpointArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromUserProfileRecursive1']


class TokenPriceIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromUserProfileRecursive2']


class TokenPriceIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromUserProfileRecursive3']


class TokenPriceIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromUserProfileRecursive4']


class TokenPriceIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class TokenPriceArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyTokenPriceArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromUserProfile(TypedDict, total=False):
    """Relational arguments for UserProfile"""


class ScraperRunIncludeFromUserProfileRecursive1(TypedDict, total=False):
    """Relational arguments for UserProfile"""


class ScraperRunIncludeFromUserProfileRecursive2(TypedDict, total=False):
    """Relational arguments for UserProfile"""


class ScraperRunIncludeFromUserProfileRecursive3(TypedDict, total=False):
    """Relational arguments for UserProfile"""


class ScraperRunIncludeFromUserProfileRecursive4(TypedDict, total=False):
    """Relational arguments for UserProfile"""

    

class ScraperRunArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    
    

class FindManyScraperRunArgsFromUserProfile(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromUserProfileRecursive1(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromUserProfileRecursive2(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromUserProfileRecursive3(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromUserProfileRecursive4(TypedDict, total=False):
    """Arguments for UserProfile"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyUserProfileArgs = FindManyUserProfileArgsFromUserProfile
FindFirstUserProfileArgs = FindManyUserProfileArgsFromUserProfile


    

class UserProfileWhereInput(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    pseudonym: Union[None, _str, 'types.StringFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanFilter']
    bio: Union[None, _str, 'types.StringFilter']
    isMod: Union[_bool, 'types.BooleanFilter']
    isCreator: Union[_bool, 'types.BooleanFilter']
    proxyWallet: Union[None, _str, 'types.StringFilter']
    baseAddress: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    Comment: 'CommentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserProfileWhereInputRecursive1', List['UserProfileWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserProfileWhereInputRecursive1']
    OR: List['UserProfileWhereInputRecursive1']
    NOT: List['UserProfileWhereInputRecursive1']


class UserProfileWhereInputRecursive1(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    pseudonym: Union[None, _str, 'types.StringFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanFilter']
    bio: Union[None, _str, 'types.StringFilter']
    isMod: Union[_bool, 'types.BooleanFilter']
    isCreator: Union[_bool, 'types.BooleanFilter']
    proxyWallet: Union[None, _str, 'types.StringFilter']
    baseAddress: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    Comment: 'CommentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserProfileWhereInputRecursive2', List['UserProfileWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserProfileWhereInputRecursive2']
    OR: List['UserProfileWhereInputRecursive2']
    NOT: List['UserProfileWhereInputRecursive2']


class UserProfileWhereInputRecursive2(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    pseudonym: Union[None, _str, 'types.StringFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanFilter']
    bio: Union[None, _str, 'types.StringFilter']
    isMod: Union[_bool, 'types.BooleanFilter']
    isCreator: Union[_bool, 'types.BooleanFilter']
    proxyWallet: Union[None, _str, 'types.StringFilter']
    baseAddress: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    Comment: 'CommentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserProfileWhereInputRecursive3', List['UserProfileWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserProfileWhereInputRecursive3']
    OR: List['UserProfileWhereInputRecursive3']
    NOT: List['UserProfileWhereInputRecursive3']


class UserProfileWhereInputRecursive3(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    pseudonym: Union[None, _str, 'types.StringFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanFilter']
    bio: Union[None, _str, 'types.StringFilter']
    isMod: Union[_bool, 'types.BooleanFilter']
    isCreator: Union[_bool, 'types.BooleanFilter']
    proxyWallet: Union[None, _str, 'types.StringFilter']
    baseAddress: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    Comment: 'CommentListRelationFilter'

    # should be noted that AND and NOT should be Union['UserProfileWhereInputRecursive4', List['UserProfileWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserProfileWhereInputRecursive4']
    OR: List['UserProfileWhereInputRecursive4']
    NOT: List['UserProfileWhereInputRecursive4']


class UserProfileWhereInputRecursive4(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringFilter']
    name: Union[None, _str, 'types.StringFilter']
    pseudonym: Union[None, _str, 'types.StringFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanFilter']
    bio: Union[None, _str, 'types.StringFilter']
    isMod: Union[_bool, 'types.BooleanFilter']
    isCreator: Union[_bool, 'types.BooleanFilter']
    proxyWallet: Union[None, _str, 'types.StringFilter']
    baseAddress: Union[None, _str, 'types.StringFilter']
    profileImage: Union[None, _str, 'types.StringFilter']
    Comment: 'CommentListRelationFilter'



# aggregate UserProfile types


    

class UserProfileScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    pseudonym: Union[_str, 'types.StringWithAggregatesFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanWithAggregatesFilter']
    bio: Union[_str, 'types.StringWithAggregatesFilter']
    isMod: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCreator: Union[_bool, 'types.BooleanWithAggregatesFilter']
    proxyWallet: Union[_str, 'types.StringWithAggregatesFilter']
    baseAddress: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserProfileScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserProfileScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserProfileScalarWhereWithAggregatesInputRecursive1']


class UserProfileScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    pseudonym: Union[_str, 'types.StringWithAggregatesFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanWithAggregatesFilter']
    bio: Union[_str, 'types.StringWithAggregatesFilter']
    isMod: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCreator: Union[_bool, 'types.BooleanWithAggregatesFilter']
    proxyWallet: Union[_str, 'types.StringWithAggregatesFilter']
    baseAddress: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserProfileScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserProfileScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserProfileScalarWhereWithAggregatesInputRecursive2']


class UserProfileScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    pseudonym: Union[_str, 'types.StringWithAggregatesFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanWithAggregatesFilter']
    bio: Union[_str, 'types.StringWithAggregatesFilter']
    isMod: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCreator: Union[_bool, 'types.BooleanWithAggregatesFilter']
    proxyWallet: Union[_str, 'types.StringWithAggregatesFilter']
    baseAddress: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserProfileScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserProfileScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserProfileScalarWhereWithAggregatesInputRecursive3']


class UserProfileScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    pseudonym: Union[_str, 'types.StringWithAggregatesFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanWithAggregatesFilter']
    bio: Union[_str, 'types.StringWithAggregatesFilter']
    isMod: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCreator: Union[_bool, 'types.BooleanWithAggregatesFilter']
    proxyWallet: Union[_str, 'types.StringWithAggregatesFilter']
    baseAddress: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserProfileScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserProfileScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserProfileScalarWhereWithAggregatesInputRecursive4']


class UserProfileScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """UserProfile arguments for searching"""
    address: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    pseudonym: Union[_str, 'types.StringWithAggregatesFilter']
    displayUsernamePublic: Union[_bool, 'types.BooleanWithAggregatesFilter']
    bio: Union[_str, 'types.StringWithAggregatesFilter']
    isMod: Union[_bool, 'types.BooleanWithAggregatesFilter']
    isCreator: Union[_bool, 'types.BooleanWithAggregatesFilter']
    proxyWallet: Union[_str, 'types.StringWithAggregatesFilter']
    baseAddress: Union[_str, 'types.StringWithAggregatesFilter']
    profileImage: Union[_str, 'types.StringWithAggregatesFilter']



class UserProfileGroupByOutput(TypedDict, total=False):
    address: _str
    name: _str
    pseudonym: _str
    displayUsernamePublic: _bool
    bio: _str
    isMod: _bool
    isCreator: _bool
    proxyWallet: _str
    baseAddress: _str
    profileImage: _str
    _sum: 'UserProfileSumAggregateOutput'
    _avg: 'UserProfileAvgAggregateOutput'
    _min: 'UserProfileMinAggregateOutput'
    _max: 'UserProfileMaxAggregateOutput'
    _count: 'UserProfileCountAggregateOutput'


class UserProfileAvgAggregateOutput(TypedDict, total=False):
    """UserProfile output for aggregating averages"""


class UserProfileSumAggregateOutput(TypedDict, total=False):
    """UserProfile output for aggregating sums"""


class UserProfileScalarAggregateOutput(TypedDict, total=False):
    """UserProfile output including scalar fields"""
    address: _str
    name: _str
    pseudonym: _str
    displayUsernamePublic: _bool
    bio: _str
    isMod: _bool
    isCreator: _bool
    proxyWallet: _str
    baseAddress: _str
    profileImage: _str


UserProfileMinAggregateOutput = UserProfileScalarAggregateOutput
UserProfileMaxAggregateOutput = UserProfileScalarAggregateOutput


class UserProfileMaxAggregateInput(TypedDict, total=False):
    """UserProfile input for aggregating by max"""
    address: bool
    name: bool
    pseudonym: bool
    displayUsernamePublic: bool
    bio: bool
    isMod: bool
    isCreator: bool
    proxyWallet: bool
    baseAddress: bool
    profileImage: bool


class UserProfileMinAggregateInput(TypedDict, total=False):
    """UserProfile input for aggregating by min"""
    address: bool
    name: bool
    pseudonym: bool
    displayUsernamePublic: bool
    bio: bool
    isMod: bool
    isCreator: bool
    proxyWallet: bool
    baseAddress: bool
    profileImage: bool


class UserProfileNumberAggregateInput(TypedDict, total=False):
    """UserProfile input for aggregating numbers"""


UserProfileAvgAggregateInput = UserProfileNumberAggregateInput
UserProfileSumAggregateInput = UserProfileNumberAggregateInput


UserProfileCountAggregateInput = TypedDict(
    'UserProfileCountAggregateInput',
    {
        'address': bool,
        'name': bool,
        'pseudonym': bool,
        'displayUsernamePublic': bool,
        'bio': bool,
        'isMod': bool,
        'isCreator': bool,
        'proxyWallet': bool,
        'baseAddress': bool,
        'profileImage': bool,
        '_all': bool,
    },
    total=False,
)

UserProfileCountAggregateOutput = TypedDict(
    'UserProfileCountAggregateOutput',
    {
        'address': int,
        'name': int,
        'pseudonym': int,
        'displayUsernamePublic': int,
        'bio': int,
        'isMod': int,
        'isCreator': int,
        'proxyWallet': int,
        'baseAddress': int,
        'profileImage': int,
        '_all': int,
    },
    total=False,
)


UserProfileKeys = Literal[
    'address',
    'name',
    'pseudonym',
    'displayUsernamePublic',
    'bio',
    'isMod',
    'isCreator',
    'proxyWallet',
    'baseAddress',
    'profileImage',
    'Comment',
]
UserProfileScalarFieldKeys = Literal[
    'address',
    'name',
    'pseudonym',
    'displayUsernamePublic',
    'bio',
    'isMod',
    'isCreator',
    'proxyWallet',
    'baseAddress',
    'profileImage',
]
UserProfileScalarFieldKeysT = TypeVar('UserProfileScalarFieldKeysT', bound=UserProfileScalarFieldKeys)

UserProfileRelationalFieldKeys = Literal[
        'Comment',
    ]

# CommentCheckpoint types

class CommentCheckpointOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CommentCheckpoint create method"""
    id: _int
    eventId: _str
    lastOffset: _int
    totalFetched: _int
    lastScrapedAt: datetime.datetime
    event: 'EventCreateNestedWithoutRelationsInput'


class CommentCheckpointCreateInput(CommentCheckpointOptionalCreateInput):
    """Required arguments to the CommentCheckpoint create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CommentCheckpointOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CommentCheckpoint create method, without relations"""
    id: _int
    eventId: _str
    lastOffset: _int
    totalFetched: _int
    lastScrapedAt: datetime.datetime


class CommentCheckpointCreateWithoutRelationsInput(CommentCheckpointOptionalCreateWithoutRelationsInput):
    """Required arguments to the CommentCheckpoint create method, without relations"""

class CommentCheckpointConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CommentCheckpointCreateWithoutRelationsInput'
    where: 'CommentCheckpointWhereUniqueInput'

class CommentCheckpointCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCheckpointCreateWithoutRelationsInput'
    connect: 'CommentCheckpointWhereUniqueInput'
    connect_or_create: 'CommentCheckpointConnectOrCreateWithoutRelationsInput'


class CommentCheckpointCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CommentCheckpointCreateWithoutRelationsInput', List['CommentCheckpointCreateWithoutRelationsInput']]
    connect: Union['CommentCheckpointWhereUniqueInput', List['CommentCheckpointWhereUniqueInput']]
    connect_or_create: Union['CommentCheckpointConnectOrCreateWithoutRelationsInput', List['CommentCheckpointConnectOrCreateWithoutRelationsInput']]

_CommentCheckpointWhereUnique_id_Input = TypedDict(
    '_CommentCheckpointWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_CommentCheckpointWhereUnique_eventId_Input = TypedDict(
    '_CommentCheckpointWhereUnique_eventId_Input',
    {
        'eventId': '_str',
    },
    total=True
)

CommentCheckpointWhereUniqueInput = Union[
    '_CommentCheckpointWhereUnique_id_Input',
    '_CommentCheckpointWhereUnique_eventId_Input',
]


class CommentCheckpointUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    lastOffset: Union[AtomicIntInput, _int]
    totalFetched: Union[AtomicIntInput, _int]
    lastScrapedAt: datetime.datetime
    event: 'EventUpdateOneWithoutRelationsInput'


class CommentCheckpointUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    lastOffset: Union[AtomicIntInput, _int]
    totalFetched: Union[AtomicIntInput, _int]
    lastScrapedAt: datetime.datetime


class CommentCheckpointUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CommentCheckpointCreateWithoutRelationsInput']
    connect: List['CommentCheckpointWhereUniqueInput']
    connect_or_create: List['CommentCheckpointConnectOrCreateWithoutRelationsInput']
    set: List['CommentCheckpointWhereUniqueInput']
    disconnect: List['CommentCheckpointWhereUniqueInput']
    delete: List['CommentCheckpointWhereUniqueInput']

    # TODO
    # update: List['CommentCheckpointUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CommentCheckpointUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CommentCheckpointScalarWhereInput']
    # upsert: List['CommentCheckpointUpserteWithWhereUniqueWithoutRelationsInput']


class CommentCheckpointUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CommentCheckpointCreateWithoutRelationsInput'
    connect: 'CommentCheckpointWhereUniqueInput'
    connect_or_create: 'CommentCheckpointConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CommentCheckpointUpdateInput'
    # upsert: 'CommentCheckpointUpsertWithoutRelationsInput'


class CommentCheckpointUpsertInput(TypedDict):
    create: 'CommentCheckpointCreateInput'
    update: 'CommentCheckpointUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CommentCheckpoint_id_OrderByInput = TypedDict(
    '_CommentCheckpoint_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_eventId_OrderByInput = TypedDict(
    '_CommentCheckpoint_eventId_OrderByInput',
    {
        'eventId': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_lastOffset_OrderByInput = TypedDict(
    '_CommentCheckpoint_lastOffset_OrderByInput',
    {
        'lastOffset': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_totalFetched_OrderByInput = TypedDict(
    '_CommentCheckpoint_totalFetched_OrderByInput',
    {
        'totalFetched': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_lastScrapedAt_OrderByInput = TypedDict(
    '_CommentCheckpoint_lastScrapedAt_OrderByInput',
    {
        'lastScrapedAt': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_RelevanceInner = TypedDict(
    '_CommentCheckpoint_RelevanceInner',
    {
        'fields': 'List[CommentCheckpointScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_CommentCheckpoint_RelevanceOrderByInput = TypedDict(
    '_CommentCheckpoint_RelevanceOrderByInput',
    {
        '_relevance': '_CommentCheckpoint_RelevanceInner',
    },
    total=True
)

CommentCheckpointOrderByInput = Union[
    '_CommentCheckpoint_id_OrderByInput',
    '_CommentCheckpoint_eventId_OrderByInput',
    '_CommentCheckpoint_lastOffset_OrderByInput',
    '_CommentCheckpoint_totalFetched_OrderByInput',
    '_CommentCheckpoint_lastScrapedAt_OrderByInput',
    '_CommentCheckpoint_RelevanceOrderByInput',
]



# recursive CommentCheckpoint types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CommentCheckpointRelationFilter = TypedDict(
    'CommentCheckpointRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CommentCheckpointListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CommentCheckpointInclude(TypedDict, total=False):
    """CommentCheckpoint relational arguments"""
    event: Union[bool, 'EventArgsFromCommentCheckpoint']


    

class EventIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentCheckpointRecursive1']


class EventIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentCheckpointRecursive2']


class EventIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentCheckpointRecursive3']


class EventIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromCommentCheckpointRecursive4']


class EventIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class EventArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyEventArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    events: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentCheckpointRecursive1']


class MarketIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    events: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentCheckpointRecursive2']


class MarketIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    events: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentCheckpointRecursive3']


class MarketIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    events: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromCommentCheckpointRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromCommentCheckpointRecursive4']


class MarketIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class MarketArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyMarketArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    market: Union[bool, 'MarketArgsFromCommentCheckpointRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentCheckpointRecursive1']


class MarketOutcomeIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    market: Union[bool, 'MarketArgsFromCommentCheckpointRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentCheckpointRecursive2']


class MarketOutcomeIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    market: Union[bool, 'MarketArgsFromCommentCheckpointRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentCheckpointRecursive3']


class MarketOutcomeIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    market: Union[bool, 'MarketArgsFromCommentCheckpointRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromCommentCheckpointRecursive4']


class MarketOutcomeIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class MarketOutcomeArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyMarketOutcomeArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive1']


class TagIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive2']


class TagIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive3']


class TagIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    markets: Union[bool, 'FindManyMarketArgsFromCommentCheckpointRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromCommentCheckpointRecursive4']


class TagIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class TagArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyTagArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    profile: Union[bool, 'UserProfileArgsFromCommentCheckpointRecursive1']
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive1']
    parentComment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentCheckpointRecursive1']


class CommentIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    profile: Union[bool, 'UserProfileArgsFromCommentCheckpointRecursive2']
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive2']
    parentComment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentCheckpointRecursive2']


class CommentIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    profile: Union[bool, 'UserProfileArgsFromCommentCheckpointRecursive3']
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive3']
    parentComment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentCheckpointRecursive3']


class CommentIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    profile: Union[bool, 'UserProfileArgsFromCommentCheckpointRecursive4']
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive4']
    parentComment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromCommentCheckpointRecursive4']


class CommentIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class CommentArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyCommentArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    comment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive1']


class CommentReactionIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    comment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive2']


class CommentReactionIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    comment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive3']


class CommentReactionIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    comment: Union[bool, 'CommentArgsFromCommentCheckpointRecursive4']


class CommentReactionIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class CommentReactionArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyCommentReactionArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive1']


class UserProfileIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive2']


class UserProfileIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive3']


class UserProfileIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    Comment: Union[bool, 'FindManyCommentArgsFromCommentCheckpointRecursive4']


class UserProfileIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class UserProfileArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyUserProfileArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive1']


class CommentCheckpointIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive2']


class CommentCheckpointIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive3']


class CommentCheckpointIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    event: Union[bool, 'EventArgsFromCommentCheckpointRecursive4']


class CommentCheckpointIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class CommentCheckpointArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyCommentCheckpointArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentCheckpointRecursive1']


class TokenPriceIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentCheckpointRecursive2']


class TokenPriceIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentCheckpointRecursive3']


class TokenPriceIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromCommentCheckpointRecursive4']


class TokenPriceIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class TokenPriceArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyTokenPriceArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromCommentCheckpoint(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""


class ScraperRunIncludeFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""


class ScraperRunIncludeFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""


class ScraperRunIncludeFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""


class ScraperRunIncludeFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Relational arguments for CommentCheckpoint"""

    

class ScraperRunArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    
    

class FindManyScraperRunArgsFromCommentCheckpoint(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromCommentCheckpointRecursive1(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromCommentCheckpointRecursive2(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromCommentCheckpointRecursive3(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromCommentCheckpointRecursive4(TypedDict, total=False):
    """Arguments for CommentCheckpoint"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyCommentCheckpointArgs = FindManyCommentCheckpointArgsFromCommentCheckpoint
FindFirstCommentCheckpointArgs = FindManyCommentCheckpointArgsFromCommentCheckpoint


    

class CommentCheckpointWhereInput(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    eventId: Union[_str, 'types.StringFilter']
    lastOffset: Union[_int, 'types.IntFilter']
    totalFetched: Union[_int, 'types.IntFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    event: 'EventRelationFilter'

    # should be noted that AND and NOT should be Union['CommentCheckpointWhereInputRecursive1', List['CommentCheckpointWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CommentCheckpointWhereInputRecursive1']
    OR: List['CommentCheckpointWhereInputRecursive1']
    NOT: List['CommentCheckpointWhereInputRecursive1']


class CommentCheckpointWhereInputRecursive1(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    eventId: Union[_str, 'types.StringFilter']
    lastOffset: Union[_int, 'types.IntFilter']
    totalFetched: Union[_int, 'types.IntFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    event: 'EventRelationFilter'

    # should be noted that AND and NOT should be Union['CommentCheckpointWhereInputRecursive2', List['CommentCheckpointWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CommentCheckpointWhereInputRecursive2']
    OR: List['CommentCheckpointWhereInputRecursive2']
    NOT: List['CommentCheckpointWhereInputRecursive2']


class CommentCheckpointWhereInputRecursive2(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    eventId: Union[_str, 'types.StringFilter']
    lastOffset: Union[_int, 'types.IntFilter']
    totalFetched: Union[_int, 'types.IntFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    event: 'EventRelationFilter'

    # should be noted that AND and NOT should be Union['CommentCheckpointWhereInputRecursive3', List['CommentCheckpointWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CommentCheckpointWhereInputRecursive3']
    OR: List['CommentCheckpointWhereInputRecursive3']
    NOT: List['CommentCheckpointWhereInputRecursive3']


class CommentCheckpointWhereInputRecursive3(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    eventId: Union[_str, 'types.StringFilter']
    lastOffset: Union[_int, 'types.IntFilter']
    totalFetched: Union[_int, 'types.IntFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    event: 'EventRelationFilter'

    # should be noted that AND and NOT should be Union['CommentCheckpointWhereInputRecursive4', List['CommentCheckpointWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CommentCheckpointWhereInputRecursive4']
    OR: List['CommentCheckpointWhereInputRecursive4']
    NOT: List['CommentCheckpointWhereInputRecursive4']


class CommentCheckpointWhereInputRecursive4(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    eventId: Union[_str, 'types.StringFilter']
    lastOffset: Union[_int, 'types.IntFilter']
    totalFetched: Union[_int, 'types.IntFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    event: 'EventRelationFilter'



# aggregate CommentCheckpoint types


    

class CommentCheckpointScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    eventId: Union[_str, 'types.StringWithAggregatesFilter']
    lastOffset: Union[_int, 'types.IntWithAggregatesFilter']
    totalFetched: Union[_int, 'types.IntWithAggregatesFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive1']
    OR: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive1']


class CommentCheckpointScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    eventId: Union[_str, 'types.StringWithAggregatesFilter']
    lastOffset: Union[_int, 'types.IntWithAggregatesFilter']
    totalFetched: Union[_int, 'types.IntWithAggregatesFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive2']
    OR: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive2']


class CommentCheckpointScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    eventId: Union[_str, 'types.StringWithAggregatesFilter']
    lastOffset: Union[_int, 'types.IntWithAggregatesFilter']
    totalFetched: Union[_int, 'types.IntWithAggregatesFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive3']
    OR: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive3']


class CommentCheckpointScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    eventId: Union[_str, 'types.StringWithAggregatesFilter']
    lastOffset: Union[_int, 'types.IntWithAggregatesFilter']
    totalFetched: Union[_int, 'types.IntWithAggregatesFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive4']
    OR: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CommentCheckpointScalarWhereWithAggregatesInputRecursive4']


class CommentCheckpointScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CommentCheckpoint arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    eventId: Union[_str, 'types.StringWithAggregatesFilter']
    lastOffset: Union[_int, 'types.IntWithAggregatesFilter']
    totalFetched: Union[_int, 'types.IntWithAggregatesFilter']
    lastScrapedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class CommentCheckpointGroupByOutput(TypedDict, total=False):
    id: _int
    eventId: _str
    lastOffset: _int
    totalFetched: _int
    lastScrapedAt: datetime.datetime
    _sum: 'CommentCheckpointSumAggregateOutput'
    _avg: 'CommentCheckpointAvgAggregateOutput'
    _min: 'CommentCheckpointMinAggregateOutput'
    _max: 'CommentCheckpointMaxAggregateOutput'
    _count: 'CommentCheckpointCountAggregateOutput'


class CommentCheckpointAvgAggregateOutput(TypedDict, total=False):
    """CommentCheckpoint output for aggregating averages"""
    id: float
    lastOffset: float
    totalFetched: float


class CommentCheckpointSumAggregateOutput(TypedDict, total=False):
    """CommentCheckpoint output for aggregating sums"""
    id: _int
    lastOffset: _int
    totalFetched: _int


class CommentCheckpointScalarAggregateOutput(TypedDict, total=False):
    """CommentCheckpoint output including scalar fields"""
    id: _int
    eventId: _str
    lastOffset: _int
    totalFetched: _int
    lastScrapedAt: datetime.datetime


CommentCheckpointMinAggregateOutput = CommentCheckpointScalarAggregateOutput
CommentCheckpointMaxAggregateOutput = CommentCheckpointScalarAggregateOutput


class CommentCheckpointMaxAggregateInput(TypedDict, total=False):
    """CommentCheckpoint input for aggregating by max"""
    id: bool
    eventId: bool
    lastOffset: bool
    totalFetched: bool
    lastScrapedAt: bool


class CommentCheckpointMinAggregateInput(TypedDict, total=False):
    """CommentCheckpoint input for aggregating by min"""
    id: bool
    eventId: bool
    lastOffset: bool
    totalFetched: bool
    lastScrapedAt: bool


class CommentCheckpointNumberAggregateInput(TypedDict, total=False):
    """CommentCheckpoint input for aggregating numbers"""
    id: bool
    lastOffset: bool
    totalFetched: bool


CommentCheckpointAvgAggregateInput = CommentCheckpointNumberAggregateInput
CommentCheckpointSumAggregateInput = CommentCheckpointNumberAggregateInput


CommentCheckpointCountAggregateInput = TypedDict(
    'CommentCheckpointCountAggregateInput',
    {
        'id': bool,
        'eventId': bool,
        'lastOffset': bool,
        'totalFetched': bool,
        'lastScrapedAt': bool,
        '_all': bool,
    },
    total=False,
)

CommentCheckpointCountAggregateOutput = TypedDict(
    'CommentCheckpointCountAggregateOutput',
    {
        'id': int,
        'eventId': int,
        'lastOffset': int,
        'totalFetched': int,
        'lastScrapedAt': int,
        '_all': int,
    },
    total=False,
)


CommentCheckpointKeys = Literal[
    'id',
    'eventId',
    'lastOffset',
    'totalFetched',
    'lastScrapedAt',
    'event',
]
CommentCheckpointScalarFieldKeys = Literal[
    'id',
    'eventId',
    'lastOffset',
    'totalFetched',
    'lastScrapedAt',
]
CommentCheckpointScalarFieldKeysT = TypeVar('CommentCheckpointScalarFieldKeysT', bound=CommentCheckpointScalarFieldKeys)

CommentCheckpointRelationalFieldKeys = Literal[
        'event',
    ]

# TokenPrice types

class TokenPriceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the TokenPrice create method"""
    id: _int
    marketOutcomeId: _int
    marketOutcome: 'MarketOutcomeCreateNestedWithoutRelationsInput'


class TokenPriceCreateInput(TokenPriceOptionalCreateInput):
    """Required arguments to the TokenPrice create method"""
    timestamp: datetime.datetime
    price: _float


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TokenPriceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the TokenPrice create method, without relations"""
    id: _int
    marketOutcomeId: _int


class TokenPriceCreateWithoutRelationsInput(TokenPriceOptionalCreateWithoutRelationsInput):
    """Required arguments to the TokenPrice create method, without relations"""
    timestamp: datetime.datetime
    price: _float

class TokenPriceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TokenPriceCreateWithoutRelationsInput'
    where: 'TokenPriceWhereUniqueInput'

class TokenPriceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TokenPriceCreateWithoutRelationsInput'
    connect: 'TokenPriceWhereUniqueInput'
    connect_or_create: 'TokenPriceConnectOrCreateWithoutRelationsInput'


class TokenPriceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TokenPriceCreateWithoutRelationsInput', List['TokenPriceCreateWithoutRelationsInput']]
    connect: Union['TokenPriceWhereUniqueInput', List['TokenPriceWhereUniqueInput']]
    connect_or_create: Union['TokenPriceConnectOrCreateWithoutRelationsInput', List['TokenPriceConnectOrCreateWithoutRelationsInput']]

_TokenPriceWhereUnique_id_Input = TypedDict(
    '_TokenPriceWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_TokenPriceCompoundmarketOutcomeId_timestampKeyInner = TypedDict(
    '_TokenPriceCompoundmarketOutcomeId_timestampKeyInner',
    {
        'marketOutcomeId': '_int',
        'timestamp': 'datetime.datetime',
    },
    total=True
)

_TokenPriceCompoundmarketOutcomeId_timestampKey = TypedDict(
    '_TokenPriceCompoundmarketOutcomeId_timestampKey',
    {
        'marketOutcomeId_timestamp': '_TokenPriceCompoundmarketOutcomeId_timestampKeyInner',
    },
    total=True
)

TokenPriceWhereUniqueInput = Union[
    '_TokenPriceWhereUnique_id_Input',
    '_TokenPriceCompoundmarketOutcomeId_timestampKey',
]


class TokenPriceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    price: Union[AtomicFloatInput, _float]
    marketOutcome: 'MarketOutcomeUpdateOneWithoutRelationsInput'


class TokenPriceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    timestamp: datetime.datetime
    price: Union[AtomicFloatInput, _float]


class TokenPriceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TokenPriceCreateWithoutRelationsInput']
    connect: List['TokenPriceWhereUniqueInput']
    connect_or_create: List['TokenPriceConnectOrCreateWithoutRelationsInput']
    set: List['TokenPriceWhereUniqueInput']
    disconnect: List['TokenPriceWhereUniqueInput']
    delete: List['TokenPriceWhereUniqueInput']

    # TODO
    # update: List['TokenPriceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TokenPriceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TokenPriceScalarWhereInput']
    # upsert: List['TokenPriceUpserteWithWhereUniqueWithoutRelationsInput']


class TokenPriceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TokenPriceCreateWithoutRelationsInput'
    connect: 'TokenPriceWhereUniqueInput'
    connect_or_create: 'TokenPriceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TokenPriceUpdateInput'
    # upsert: 'TokenPriceUpsertWithoutRelationsInput'


class TokenPriceUpsertInput(TypedDict):
    create: 'TokenPriceCreateInput'
    update: 'TokenPriceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_TokenPrice_id_OrderByInput = TypedDict(
    '_TokenPrice_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_TokenPrice_marketOutcomeId_OrderByInput = TypedDict(
    '_TokenPrice_marketOutcomeId_OrderByInput',
    {
        'marketOutcomeId': 'SortOrder',
    },
    total=True
)

_TokenPrice_timestamp_OrderByInput = TypedDict(
    '_TokenPrice_timestamp_OrderByInput',
    {
        'timestamp': 'SortOrder',
    },
    total=True
)

_TokenPrice_price_OrderByInput = TypedDict(
    '_TokenPrice_price_OrderByInput',
    {
        'price': 'SortOrder',
    },
    total=True
)

_TokenPrice_RelevanceInner = TypedDict(
    '_TokenPrice_RelevanceInner',
    {
        'fields': 'List[TokenPriceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_TokenPrice_RelevanceOrderByInput = TypedDict(
    '_TokenPrice_RelevanceOrderByInput',
    {
        '_relevance': '_TokenPrice_RelevanceInner',
    },
    total=True
)

TokenPriceOrderByInput = Union[
    '_TokenPrice_id_OrderByInput',
    '_TokenPrice_marketOutcomeId_OrderByInput',
    '_TokenPrice_timestamp_OrderByInput',
    '_TokenPrice_price_OrderByInput',
    '_TokenPrice_RelevanceOrderByInput',
]



# recursive TokenPrice types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TokenPriceRelationFilter = TypedDict(
    'TokenPriceRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TokenPriceListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TokenPriceInclude(TypedDict, total=False):
    """TokenPrice relational arguments"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTokenPrice']


    

class EventIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTokenPriceRecursive1']


class EventIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTokenPriceRecursive2']


class EventIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTokenPriceRecursive3']


class EventIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromTokenPriceRecursive4']


class EventIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class EventArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyEventArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    events: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTokenPriceRecursive1']


class MarketIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    events: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTokenPriceRecursive2']


class MarketIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    events: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTokenPriceRecursive3']


class MarketIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    events: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromTokenPriceRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromTokenPriceRecursive4']


class MarketIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class MarketArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyMarketArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    market: Union[bool, 'MarketArgsFromTokenPriceRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTokenPriceRecursive1']


class MarketOutcomeIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    market: Union[bool, 'MarketArgsFromTokenPriceRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTokenPriceRecursive2']


class MarketOutcomeIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    market: Union[bool, 'MarketArgsFromTokenPriceRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTokenPriceRecursive3']


class MarketOutcomeIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    market: Union[bool, 'MarketArgsFromTokenPriceRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromTokenPriceRecursive4']


class MarketOutcomeIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class MarketOutcomeArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyMarketOutcomeArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive1']


class TagIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive2']


class TagIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive3']


class TagIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    markets: Union[bool, 'FindManyMarketArgsFromTokenPriceRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromTokenPriceRecursive4']


class TagIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class TagArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyTagArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    profile: Union[bool, 'UserProfileArgsFromTokenPriceRecursive1']
    event: Union[bool, 'EventArgsFromTokenPriceRecursive1']
    parentComment: Union[bool, 'CommentArgsFromTokenPriceRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTokenPriceRecursive1']


class CommentIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    profile: Union[bool, 'UserProfileArgsFromTokenPriceRecursive2']
    event: Union[bool, 'EventArgsFromTokenPriceRecursive2']
    parentComment: Union[bool, 'CommentArgsFromTokenPriceRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTokenPriceRecursive2']


class CommentIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    profile: Union[bool, 'UserProfileArgsFromTokenPriceRecursive3']
    event: Union[bool, 'EventArgsFromTokenPriceRecursive3']
    parentComment: Union[bool, 'CommentArgsFromTokenPriceRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTokenPriceRecursive3']


class CommentIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    profile: Union[bool, 'UserProfileArgsFromTokenPriceRecursive4']
    event: Union[bool, 'EventArgsFromTokenPriceRecursive4']
    parentComment: Union[bool, 'CommentArgsFromTokenPriceRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromTokenPriceRecursive4']


class CommentIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class CommentArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyCommentArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    comment: Union[bool, 'CommentArgsFromTokenPriceRecursive1']


class CommentReactionIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    comment: Union[bool, 'CommentArgsFromTokenPriceRecursive2']


class CommentReactionIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    comment: Union[bool, 'CommentArgsFromTokenPriceRecursive3']


class CommentReactionIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    comment: Union[bool, 'CommentArgsFromTokenPriceRecursive4']


class CommentReactionIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class CommentReactionArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyCommentReactionArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive1']


class UserProfileIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive2']


class UserProfileIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive3']


class UserProfileIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    Comment: Union[bool, 'FindManyCommentArgsFromTokenPriceRecursive4']


class UserProfileIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class UserProfileArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyUserProfileArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    event: Union[bool, 'EventArgsFromTokenPriceRecursive1']


class CommentCheckpointIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    event: Union[bool, 'EventArgsFromTokenPriceRecursive2']


class CommentCheckpointIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    event: Union[bool, 'EventArgsFromTokenPriceRecursive3']


class CommentCheckpointIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    event: Union[bool, 'EventArgsFromTokenPriceRecursive4']


class CommentCheckpointIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class CommentCheckpointArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyCommentCheckpointArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTokenPriceRecursive1']


class TokenPriceIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTokenPriceRecursive2']


class TokenPriceIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTokenPriceRecursive3']


class TokenPriceIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromTokenPriceRecursive4']


class TokenPriceIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class TokenPriceArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyTokenPriceArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromTokenPrice(TypedDict, total=False):
    """Relational arguments for TokenPrice"""


class ScraperRunIncludeFromTokenPriceRecursive1(TypedDict, total=False):
    """Relational arguments for TokenPrice"""


class ScraperRunIncludeFromTokenPriceRecursive2(TypedDict, total=False):
    """Relational arguments for TokenPrice"""


class ScraperRunIncludeFromTokenPriceRecursive3(TypedDict, total=False):
    """Relational arguments for TokenPrice"""


class ScraperRunIncludeFromTokenPriceRecursive4(TypedDict, total=False):
    """Relational arguments for TokenPrice"""

    

class ScraperRunArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    
    

class FindManyScraperRunArgsFromTokenPrice(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromTokenPriceRecursive1(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromTokenPriceRecursive2(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromTokenPriceRecursive3(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromTokenPriceRecursive4(TypedDict, total=False):
    """Arguments for TokenPrice"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyTokenPriceArgs = FindManyTokenPriceArgsFromTokenPrice
FindFirstTokenPriceArgs = FindManyTokenPriceArgsFromTokenPrice


    

class TokenPriceWhereInput(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    marketOutcomeId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    price: Union[_float, 'types.FloatFilter']
    marketOutcome: 'MarketOutcomeRelationFilter'

    # should be noted that AND and NOT should be Union['TokenPriceWhereInputRecursive1', List['TokenPriceWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TokenPriceWhereInputRecursive1']
    OR: List['TokenPriceWhereInputRecursive1']
    NOT: List['TokenPriceWhereInputRecursive1']


class TokenPriceWhereInputRecursive1(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    marketOutcomeId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    price: Union[_float, 'types.FloatFilter']
    marketOutcome: 'MarketOutcomeRelationFilter'

    # should be noted that AND and NOT should be Union['TokenPriceWhereInputRecursive2', List['TokenPriceWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TokenPriceWhereInputRecursive2']
    OR: List['TokenPriceWhereInputRecursive2']
    NOT: List['TokenPriceWhereInputRecursive2']


class TokenPriceWhereInputRecursive2(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    marketOutcomeId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    price: Union[_float, 'types.FloatFilter']
    marketOutcome: 'MarketOutcomeRelationFilter'

    # should be noted that AND and NOT should be Union['TokenPriceWhereInputRecursive3', List['TokenPriceWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TokenPriceWhereInputRecursive3']
    OR: List['TokenPriceWhereInputRecursive3']
    NOT: List['TokenPriceWhereInputRecursive3']


class TokenPriceWhereInputRecursive3(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    marketOutcomeId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    price: Union[_float, 'types.FloatFilter']
    marketOutcome: 'MarketOutcomeRelationFilter'

    # should be noted that AND and NOT should be Union['TokenPriceWhereInputRecursive4', List['TokenPriceWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TokenPriceWhereInputRecursive4']
    OR: List['TokenPriceWhereInputRecursive4']
    NOT: List['TokenPriceWhereInputRecursive4']


class TokenPriceWhereInputRecursive4(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    marketOutcomeId: Union[_int, 'types.IntFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    price: Union[_float, 'types.FloatFilter']
    marketOutcome: 'MarketOutcomeRelationFilter'



# aggregate TokenPrice types


    

class TokenPriceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomeId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TokenPriceScalarWhereWithAggregatesInputRecursive1']
    OR: List['TokenPriceScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TokenPriceScalarWhereWithAggregatesInputRecursive1']


class TokenPriceScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomeId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TokenPriceScalarWhereWithAggregatesInputRecursive2']
    OR: List['TokenPriceScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TokenPriceScalarWhereWithAggregatesInputRecursive2']


class TokenPriceScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomeId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TokenPriceScalarWhereWithAggregatesInputRecursive3']
    OR: List['TokenPriceScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TokenPriceScalarWhereWithAggregatesInputRecursive3']


class TokenPriceScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomeId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']

    AND: List['TokenPriceScalarWhereWithAggregatesInputRecursive4']
    OR: List['TokenPriceScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TokenPriceScalarWhereWithAggregatesInputRecursive4']


class TokenPriceScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """TokenPrice arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomeId: Union[_int, 'types.IntWithAggregatesFilter']
    timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    price: Union[_float, 'types.FloatWithAggregatesFilter']



class TokenPriceGroupByOutput(TypedDict, total=False):
    id: _int
    marketOutcomeId: _int
    timestamp: datetime.datetime
    price: _float
    _sum: 'TokenPriceSumAggregateOutput'
    _avg: 'TokenPriceAvgAggregateOutput'
    _min: 'TokenPriceMinAggregateOutput'
    _max: 'TokenPriceMaxAggregateOutput'
    _count: 'TokenPriceCountAggregateOutput'


class TokenPriceAvgAggregateOutput(TypedDict, total=False):
    """TokenPrice output for aggregating averages"""
    id: float
    marketOutcomeId: float
    price: float


class TokenPriceSumAggregateOutput(TypedDict, total=False):
    """TokenPrice output for aggregating sums"""
    id: _int
    marketOutcomeId: _int
    price: _float


class TokenPriceScalarAggregateOutput(TypedDict, total=False):
    """TokenPrice output including scalar fields"""
    id: _int
    marketOutcomeId: _int
    timestamp: datetime.datetime
    price: _float


TokenPriceMinAggregateOutput = TokenPriceScalarAggregateOutput
TokenPriceMaxAggregateOutput = TokenPriceScalarAggregateOutput


class TokenPriceMaxAggregateInput(TypedDict, total=False):
    """TokenPrice input for aggregating by max"""
    id: bool
    marketOutcomeId: bool
    timestamp: bool
    price: bool


class TokenPriceMinAggregateInput(TypedDict, total=False):
    """TokenPrice input for aggregating by min"""
    id: bool
    marketOutcomeId: bool
    timestamp: bool
    price: bool


class TokenPriceNumberAggregateInput(TypedDict, total=False):
    """TokenPrice input for aggregating numbers"""
    id: bool
    marketOutcomeId: bool
    price: bool


TokenPriceAvgAggregateInput = TokenPriceNumberAggregateInput
TokenPriceSumAggregateInput = TokenPriceNumberAggregateInput


TokenPriceCountAggregateInput = TypedDict(
    'TokenPriceCountAggregateInput',
    {
        'id': bool,
        'marketOutcomeId': bool,
        'timestamp': bool,
        'price': bool,
        '_all': bool,
    },
    total=False,
)

TokenPriceCountAggregateOutput = TypedDict(
    'TokenPriceCountAggregateOutput',
    {
        'id': int,
        'marketOutcomeId': int,
        'timestamp': int,
        'price': int,
        '_all': int,
    },
    total=False,
)


TokenPriceKeys = Literal[
    'id',
    'marketOutcomeId',
    'timestamp',
    'price',
    'marketOutcome',
]
TokenPriceScalarFieldKeys = Literal[
    'id',
    'marketOutcomeId',
    'timestamp',
    'price',
]
TokenPriceScalarFieldKeysT = TypeVar('TokenPriceScalarFieldKeysT', bound=TokenPriceScalarFieldKeys)

TokenPriceRelationalFieldKeys = Literal[
        'marketOutcome',
    ]

# ScraperRun types

class ScraperRunOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ScraperRun create method"""
    id: _int
    status: _str
    marketsScraped: _int
    marketOutcomesScraped: _int
    commentsScraped: _int
    priceSnapshotsTaken: _int
    tokensProcessed: _int
    priceDataPointsStored: _int
    errors: Optional[_str]
    errorCount: _int
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    durationMs: Optional[_int]


class ScraperRunCreateInput(ScraperRunOptionalCreateInput):
    """Required arguments to the ScraperRun create method"""
    runType: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ScraperRunOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ScraperRun create method, without relations"""
    id: _int
    status: _str
    marketsScraped: _int
    marketOutcomesScraped: _int
    commentsScraped: _int
    priceSnapshotsTaken: _int
    tokensProcessed: _int
    priceDataPointsStored: _int
    errors: Optional[_str]
    errorCount: _int
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    durationMs: Optional[_int]


class ScraperRunCreateWithoutRelationsInput(ScraperRunOptionalCreateWithoutRelationsInput):
    """Required arguments to the ScraperRun create method, without relations"""
    runType: _str

class ScraperRunConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ScraperRunCreateWithoutRelationsInput'
    where: 'ScraperRunWhereUniqueInput'

class ScraperRunCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ScraperRunCreateWithoutRelationsInput'
    connect: 'ScraperRunWhereUniqueInput'
    connect_or_create: 'ScraperRunConnectOrCreateWithoutRelationsInput'


class ScraperRunCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ScraperRunCreateWithoutRelationsInput', List['ScraperRunCreateWithoutRelationsInput']]
    connect: Union['ScraperRunWhereUniqueInput', List['ScraperRunWhereUniqueInput']]
    connect_or_create: Union['ScraperRunConnectOrCreateWithoutRelationsInput', List['ScraperRunConnectOrCreateWithoutRelationsInput']]

_ScraperRunWhereUnique_id_Input = TypedDict(
    '_ScraperRunWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

ScraperRunWhereUniqueInput = _ScraperRunWhereUnique_id_Input


class ScraperRunUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    runType: _str
    status: _str
    marketsScraped: Union[AtomicIntInput, _int]
    marketOutcomesScraped: Union[AtomicIntInput, _int]
    commentsScraped: Union[AtomicIntInput, _int]
    priceSnapshotsTaken: Union[AtomicIntInput, _int]
    tokensProcessed: Union[AtomicIntInput, _int]
    priceDataPointsStored: Union[AtomicIntInput, _int]
    errors: Optional[_str]
    errorCount: Union[AtomicIntInput, _int]
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    durationMs: Optional[Union[AtomicIntInput, _int]]


class ScraperRunUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    runType: _str
    status: _str
    marketsScraped: Union[AtomicIntInput, _int]
    marketOutcomesScraped: Union[AtomicIntInput, _int]
    commentsScraped: Union[AtomicIntInput, _int]
    priceSnapshotsTaken: Union[AtomicIntInput, _int]
    tokensProcessed: Union[AtomicIntInput, _int]
    priceDataPointsStored: Union[AtomicIntInput, _int]
    errors: Optional[_str]
    errorCount: Union[AtomicIntInput, _int]
    startTime: datetime.datetime
    endTime: Optional[datetime.datetime]
    durationMs: Optional[Union[AtomicIntInput, _int]]


class ScraperRunUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ScraperRunCreateWithoutRelationsInput']
    connect: List['ScraperRunWhereUniqueInput']
    connect_or_create: List['ScraperRunConnectOrCreateWithoutRelationsInput']
    set: List['ScraperRunWhereUniqueInput']
    disconnect: List['ScraperRunWhereUniqueInput']
    delete: List['ScraperRunWhereUniqueInput']

    # TODO
    # update: List['ScraperRunUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ScraperRunUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ScraperRunScalarWhereInput']
    # upsert: List['ScraperRunUpserteWithWhereUniqueWithoutRelationsInput']


class ScraperRunUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ScraperRunCreateWithoutRelationsInput'
    connect: 'ScraperRunWhereUniqueInput'
    connect_or_create: 'ScraperRunConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ScraperRunUpdateInput'
    # upsert: 'ScraperRunUpsertWithoutRelationsInput'


class ScraperRunUpsertInput(TypedDict):
    create: 'ScraperRunCreateInput'
    update: 'ScraperRunUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ScraperRun_id_OrderByInput = TypedDict(
    '_ScraperRun_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ScraperRun_runType_OrderByInput = TypedDict(
    '_ScraperRun_runType_OrderByInput',
    {
        'runType': 'SortOrder',
    },
    total=True
)

_ScraperRun_status_OrderByInput = TypedDict(
    '_ScraperRun_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_ScraperRun_marketsScraped_OrderByInput = TypedDict(
    '_ScraperRun_marketsScraped_OrderByInput',
    {
        'marketsScraped': 'SortOrder',
    },
    total=True
)

_ScraperRun_marketOutcomesScraped_OrderByInput = TypedDict(
    '_ScraperRun_marketOutcomesScraped_OrderByInput',
    {
        'marketOutcomesScraped': 'SortOrder',
    },
    total=True
)

_ScraperRun_commentsScraped_OrderByInput = TypedDict(
    '_ScraperRun_commentsScraped_OrderByInput',
    {
        'commentsScraped': 'SortOrder',
    },
    total=True
)

_ScraperRun_priceSnapshotsTaken_OrderByInput = TypedDict(
    '_ScraperRun_priceSnapshotsTaken_OrderByInput',
    {
        'priceSnapshotsTaken': 'SortOrder',
    },
    total=True
)

_ScraperRun_tokensProcessed_OrderByInput = TypedDict(
    '_ScraperRun_tokensProcessed_OrderByInput',
    {
        'tokensProcessed': 'SortOrder',
    },
    total=True
)

_ScraperRun_priceDataPointsStored_OrderByInput = TypedDict(
    '_ScraperRun_priceDataPointsStored_OrderByInput',
    {
        'priceDataPointsStored': 'SortOrder',
    },
    total=True
)

_ScraperRun_errors_OrderByInput = TypedDict(
    '_ScraperRun_errors_OrderByInput',
    {
        'errors': 'SortOrder',
    },
    total=True
)

_ScraperRun_errorCount_OrderByInput = TypedDict(
    '_ScraperRun_errorCount_OrderByInput',
    {
        'errorCount': 'SortOrder',
    },
    total=True
)

_ScraperRun_startTime_OrderByInput = TypedDict(
    '_ScraperRun_startTime_OrderByInput',
    {
        'startTime': 'SortOrder',
    },
    total=True
)

_ScraperRun_endTime_OrderByInput = TypedDict(
    '_ScraperRun_endTime_OrderByInput',
    {
        'endTime': 'SortOrder',
    },
    total=True
)

_ScraperRun_durationMs_OrderByInput = TypedDict(
    '_ScraperRun_durationMs_OrderByInput',
    {
        'durationMs': 'SortOrder',
    },
    total=True
)

_ScraperRun_RelevanceInner = TypedDict(
    '_ScraperRun_RelevanceInner',
    {
        'fields': 'List[ScraperRunScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ScraperRun_RelevanceOrderByInput = TypedDict(
    '_ScraperRun_RelevanceOrderByInput',
    {
        '_relevance': '_ScraperRun_RelevanceInner',
    },
    total=True
)

ScraperRunOrderByInput = Union[
    '_ScraperRun_id_OrderByInput',
    '_ScraperRun_runType_OrderByInput',
    '_ScraperRun_status_OrderByInput',
    '_ScraperRun_marketsScraped_OrderByInput',
    '_ScraperRun_marketOutcomesScraped_OrderByInput',
    '_ScraperRun_commentsScraped_OrderByInput',
    '_ScraperRun_priceSnapshotsTaken_OrderByInput',
    '_ScraperRun_tokensProcessed_OrderByInput',
    '_ScraperRun_priceDataPointsStored_OrderByInput',
    '_ScraperRun_errors_OrderByInput',
    '_ScraperRun_errorCount_OrderByInput',
    '_ScraperRun_startTime_OrderByInput',
    '_ScraperRun_endTime_OrderByInput',
    '_ScraperRun_durationMs_OrderByInput',
    '_ScraperRun_RelevanceOrderByInput',
]



# recursive ScraperRun types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ScraperRunRelationFilter = TypedDict(
    'ScraperRunRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ScraperRunListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ScraperRunInclude(TypedDict, total=False):
    """ScraperRun relational arguments"""


    

class EventIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive1']
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive1']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromScraperRunRecursive1']


class EventIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive2']
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive2']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromScraperRunRecursive2']


class EventIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive3']
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive3']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromScraperRunRecursive3']


class EventIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive4']
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive4']
    CommentCheckpoint: Union[bool, 'FindManyCommentCheckpointArgsFromScraperRunRecursive4']


class EventIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class EventArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'EventIncludeFromEventRecursive1'


class EventArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'EventIncludeFromEventRecursive2'


class EventArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'EventIncludeFromEventRecursive3'


class EventArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'EventIncludeFromEventRecursive4'


class EventArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyEventArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive1'


class FindManyEventArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive2'


class FindManyEventArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive3'


class FindManyEventArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    include: 'EventIncludeFromEventRecursive4'


class FindManyEventArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['EventOrderByInput', List['EventOrderByInput']]
    where: 'EventWhereInput'
    cursor: 'EventWhereUniqueInput'
    distinct: List['EventScalarFieldKeys']
    
    

class MarketIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    events: Union[bool, 'FindManyEventArgsFromScraperRunRecursive1']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive1']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromScraperRunRecursive1']


class MarketIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    events: Union[bool, 'FindManyEventArgsFromScraperRunRecursive2']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive2']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromScraperRunRecursive2']


class MarketIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    events: Union[bool, 'FindManyEventArgsFromScraperRunRecursive3']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive3']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromScraperRunRecursive3']


class MarketIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    events: Union[bool, 'FindManyEventArgsFromScraperRunRecursive4']
    tags: Union[bool, 'FindManyTagArgsFromScraperRunRecursive4']
    marketOutcomes: Union[bool, 'FindManyMarketOutcomeArgsFromScraperRunRecursive4']


class MarketIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class MarketArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketIncludeFromMarketRecursive1'


class MarketArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketIncludeFromMarketRecursive2'


class MarketArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketIncludeFromMarketRecursive3'


class MarketArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketIncludeFromMarketRecursive4'


class MarketArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyMarketArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive1'


class FindManyMarketArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive2'


class FindManyMarketArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive3'


class FindManyMarketArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    include: 'MarketIncludeFromMarketRecursive4'


class FindManyMarketArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOrderByInput', List['MarketOrderByInput']]
    where: 'MarketWhereInput'
    cursor: 'MarketWhereUniqueInput'
    distinct: List['MarketScalarFieldKeys']
    
    

class MarketOutcomeIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    market: Union[bool, 'MarketArgsFromScraperRunRecursive1']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromScraperRunRecursive1']


class MarketOutcomeIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    market: Union[bool, 'MarketArgsFromScraperRunRecursive2']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromScraperRunRecursive2']


class MarketOutcomeIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    market: Union[bool, 'MarketArgsFromScraperRunRecursive3']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromScraperRunRecursive3']


class MarketOutcomeIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    market: Union[bool, 'MarketArgsFromScraperRunRecursive4']
    priceSnapshots: Union[bool, 'FindManyTokenPriceArgsFromScraperRunRecursive4']


class MarketOutcomeIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class MarketOutcomeArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class MarketOutcomeArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class MarketOutcomeArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class MarketOutcomeArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class MarketOutcomeArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyMarketOutcomeArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive1'


class FindManyMarketOutcomeArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive2'


class FindManyMarketOutcomeArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive3'


class FindManyMarketOutcomeArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    include: 'MarketOutcomeIncludeFromMarketOutcomeRecursive4'


class FindManyMarketOutcomeArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['MarketOutcomeOrderByInput', List['MarketOutcomeOrderByInput']]
    where: 'MarketOutcomeWhereInput'
    cursor: 'MarketOutcomeWhereUniqueInput'
    distinct: List['MarketOutcomeScalarFieldKeys']
    
    

class TagIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive1']
    Event: Union[bool, 'FindManyEventArgsFromScraperRunRecursive1']


class TagIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive2']
    Event: Union[bool, 'FindManyEventArgsFromScraperRunRecursive2']


class TagIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive3']
    Event: Union[bool, 'FindManyEventArgsFromScraperRunRecursive3']


class TagIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    markets: Union[bool, 'FindManyMarketArgsFromScraperRunRecursive4']
    Event: Union[bool, 'FindManyEventArgsFromScraperRunRecursive4']


class TagIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class TagArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TagIncludeFromTagRecursive1'


class TagArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TagIncludeFromTagRecursive2'


class TagArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TagIncludeFromTagRecursive3'


class TagArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TagIncludeFromTagRecursive4'


class TagArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyTagArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive1'


class FindManyTagArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive2'


class FindManyTagArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive3'


class FindManyTagArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    include: 'TagIncludeFromTagRecursive4'


class FindManyTagArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TagOrderByInput', List['TagOrderByInput']]
    where: 'TagWhereInput'
    cursor: 'TagWhereUniqueInput'
    distinct: List['TagScalarFieldKeys']
    
    

class CommentIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    profile: Union[bool, 'UserProfileArgsFromScraperRunRecursive1']
    event: Union[bool, 'EventArgsFromScraperRunRecursive1']
    parentComment: Union[bool, 'CommentArgsFromScraperRunRecursive1']
    childComments: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive1']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromScraperRunRecursive1']


class CommentIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    profile: Union[bool, 'UserProfileArgsFromScraperRunRecursive2']
    event: Union[bool, 'EventArgsFromScraperRunRecursive2']
    parentComment: Union[bool, 'CommentArgsFromScraperRunRecursive2']
    childComments: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive2']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromScraperRunRecursive2']


class CommentIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    profile: Union[bool, 'UserProfileArgsFromScraperRunRecursive3']
    event: Union[bool, 'EventArgsFromScraperRunRecursive3']
    parentComment: Union[bool, 'CommentArgsFromScraperRunRecursive3']
    childComments: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive3']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromScraperRunRecursive3']


class CommentIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    profile: Union[bool, 'UserProfileArgsFromScraperRunRecursive4']
    event: Union[bool, 'EventArgsFromScraperRunRecursive4']
    parentComment: Union[bool, 'CommentArgsFromScraperRunRecursive4']
    childComments: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive4']
    reactions: Union[bool, 'FindManyCommentReactionArgsFromScraperRunRecursive4']


class CommentIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class CommentArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentIncludeFromCommentRecursive1'


class CommentArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentIncludeFromCommentRecursive2'


class CommentArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentIncludeFromCommentRecursive3'


class CommentArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentIncludeFromCommentRecursive4'


class CommentArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyCommentArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive1'


class FindManyCommentArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive2'


class FindManyCommentArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive3'


class FindManyCommentArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    include: 'CommentIncludeFromCommentRecursive4'


class FindManyCommentArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentOrderByInput', List['CommentOrderByInput']]
    where: 'CommentWhereInput'
    cursor: 'CommentWhereUniqueInput'
    distinct: List['CommentScalarFieldKeys']
    
    

class CommentReactionIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    comment: Union[bool, 'CommentArgsFromScraperRunRecursive1']


class CommentReactionIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    comment: Union[bool, 'CommentArgsFromScraperRunRecursive2']


class CommentReactionIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    comment: Union[bool, 'CommentArgsFromScraperRunRecursive3']


class CommentReactionIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    comment: Union[bool, 'CommentArgsFromScraperRunRecursive4']


class CommentReactionIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class CommentReactionArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class CommentReactionArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class CommentReactionArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class CommentReactionArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class CommentReactionArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyCommentReactionArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive1'


class FindManyCommentReactionArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive2'


class FindManyCommentReactionArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive3'


class FindManyCommentReactionArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    include: 'CommentReactionIncludeFromCommentReactionRecursive4'


class FindManyCommentReactionArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentReactionOrderByInput', List['CommentReactionOrderByInput']]
    where: 'CommentReactionWhereInput'
    cursor: 'CommentReactionWhereUniqueInput'
    distinct: List['CommentReactionScalarFieldKeys']
    
    

class UserProfileIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive1']


class UserProfileIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive2']


class UserProfileIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive3']


class UserProfileIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    Comment: Union[bool, 'FindManyCommentArgsFromScraperRunRecursive4']


class UserProfileIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class UserProfileArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class UserProfileArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class UserProfileArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class UserProfileArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class UserProfileArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyUserProfileArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive1'


class FindManyUserProfileArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive2'


class FindManyUserProfileArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive3'


class FindManyUserProfileArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    include: 'UserProfileIncludeFromUserProfileRecursive4'


class FindManyUserProfileArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['UserProfileOrderByInput', List['UserProfileOrderByInput']]
    where: 'UserProfileWhereInput'
    cursor: 'UserProfileWhereUniqueInput'
    distinct: List['UserProfileScalarFieldKeys']
    
    

class CommentCheckpointIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    event: Union[bool, 'EventArgsFromScraperRunRecursive1']


class CommentCheckpointIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    event: Union[bool, 'EventArgsFromScraperRunRecursive2']


class CommentCheckpointIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    event: Union[bool, 'EventArgsFromScraperRunRecursive3']


class CommentCheckpointIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    event: Union[bool, 'EventArgsFromScraperRunRecursive4']


class CommentCheckpointIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class CommentCheckpointArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class CommentCheckpointArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class CommentCheckpointArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class CommentCheckpointArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class CommentCheckpointArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyCommentCheckpointArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive1'


class FindManyCommentCheckpointArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive2'


class FindManyCommentCheckpointArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive3'


class FindManyCommentCheckpointArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    include: 'CommentCheckpointIncludeFromCommentCheckpointRecursive4'


class FindManyCommentCheckpointArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['CommentCheckpointOrderByInput', List['CommentCheckpointOrderByInput']]
    where: 'CommentCheckpointWhereInput'
    cursor: 'CommentCheckpointWhereUniqueInput'
    distinct: List['CommentCheckpointScalarFieldKeys']
    
    

class TokenPriceIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromScraperRunRecursive1']


class TokenPriceIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromScraperRunRecursive2']


class TokenPriceIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromScraperRunRecursive3']


class TokenPriceIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""
    marketOutcome: Union[bool, 'MarketOutcomeArgsFromScraperRunRecursive4']


class TokenPriceIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class TokenPriceArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class TokenPriceArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class TokenPriceArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class TokenPriceArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class TokenPriceArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyTokenPriceArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive1'


class FindManyTokenPriceArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive2'


class FindManyTokenPriceArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive3'


class FindManyTokenPriceArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    include: 'TokenPriceIncludeFromTokenPriceRecursive4'


class FindManyTokenPriceArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['TokenPriceOrderByInput', List['TokenPriceOrderByInput']]
    where: 'TokenPriceWhereInput'
    cursor: 'TokenPriceWhereUniqueInput'
    distinct: List['TokenPriceScalarFieldKeys']
    
    

class ScraperRunIncludeFromScraperRun(TypedDict, total=False):
    """Relational arguments for ScraperRun"""


class ScraperRunIncludeFromScraperRunRecursive1(TypedDict, total=False):
    """Relational arguments for ScraperRun"""


class ScraperRunIncludeFromScraperRunRecursive2(TypedDict, total=False):
    """Relational arguments for ScraperRun"""


class ScraperRunIncludeFromScraperRunRecursive3(TypedDict, total=False):
    """Relational arguments for ScraperRun"""


class ScraperRunIncludeFromScraperRunRecursive4(TypedDict, total=False):
    """Relational arguments for ScraperRun"""

    

class ScraperRunArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class ScraperRunArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class ScraperRunArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class ScraperRunArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class ScraperRunArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    
    

class FindManyScraperRunArgsFromScraperRun(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive1'


class FindManyScraperRunArgsFromScraperRunRecursive1(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive2'


class FindManyScraperRunArgsFromScraperRunRecursive2(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive3'


class FindManyScraperRunArgsFromScraperRunRecursive3(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    include: 'ScraperRunIncludeFromScraperRunRecursive4'


class FindManyScraperRunArgsFromScraperRunRecursive4(TypedDict, total=False):
    """Arguments for ScraperRun"""
    take: int
    skip: int
    order_by: Union['ScraperRunOrderByInput', List['ScraperRunOrderByInput']]
    where: 'ScraperRunWhereInput'
    cursor: 'ScraperRunWhereUniqueInput'
    distinct: List['ScraperRunScalarFieldKeys']
    


FindManyScraperRunArgs = FindManyScraperRunArgsFromScraperRun
FindFirstScraperRunArgs = FindManyScraperRunArgsFromScraperRun


    

class ScraperRunWhereInput(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    runType: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    marketsScraped: Union[_int, 'types.IntFilter']
    marketOutcomesScraped: Union[_int, 'types.IntFilter']
    commentsScraped: Union[_int, 'types.IntFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntFilter']
    tokensProcessed: Union[_int, 'types.IntFilter']
    priceDataPointsStored: Union[_int, 'types.IntFilter']
    errors: Union[None, _str, 'types.StringFilter']
    errorCount: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    durationMs: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['ScraperRunWhereInputRecursive1', List['ScraperRunWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ScraperRunWhereInputRecursive1']
    OR: List['ScraperRunWhereInputRecursive1']
    NOT: List['ScraperRunWhereInputRecursive1']


class ScraperRunWhereInputRecursive1(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    runType: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    marketsScraped: Union[_int, 'types.IntFilter']
    marketOutcomesScraped: Union[_int, 'types.IntFilter']
    commentsScraped: Union[_int, 'types.IntFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntFilter']
    tokensProcessed: Union[_int, 'types.IntFilter']
    priceDataPointsStored: Union[_int, 'types.IntFilter']
    errors: Union[None, _str, 'types.StringFilter']
    errorCount: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    durationMs: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['ScraperRunWhereInputRecursive2', List['ScraperRunWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ScraperRunWhereInputRecursive2']
    OR: List['ScraperRunWhereInputRecursive2']
    NOT: List['ScraperRunWhereInputRecursive2']


class ScraperRunWhereInputRecursive2(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    runType: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    marketsScraped: Union[_int, 'types.IntFilter']
    marketOutcomesScraped: Union[_int, 'types.IntFilter']
    commentsScraped: Union[_int, 'types.IntFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntFilter']
    tokensProcessed: Union[_int, 'types.IntFilter']
    priceDataPointsStored: Union[_int, 'types.IntFilter']
    errors: Union[None, _str, 'types.StringFilter']
    errorCount: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    durationMs: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['ScraperRunWhereInputRecursive3', List['ScraperRunWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ScraperRunWhereInputRecursive3']
    OR: List['ScraperRunWhereInputRecursive3']
    NOT: List['ScraperRunWhereInputRecursive3']


class ScraperRunWhereInputRecursive3(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    runType: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    marketsScraped: Union[_int, 'types.IntFilter']
    marketOutcomesScraped: Union[_int, 'types.IntFilter']
    commentsScraped: Union[_int, 'types.IntFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntFilter']
    tokensProcessed: Union[_int, 'types.IntFilter']
    priceDataPointsStored: Union[_int, 'types.IntFilter']
    errors: Union[None, _str, 'types.StringFilter']
    errorCount: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    durationMs: Union[None, _int, 'types.IntFilter']

    # should be noted that AND and NOT should be Union['ScraperRunWhereInputRecursive4', List['ScraperRunWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ScraperRunWhereInputRecursive4']
    OR: List['ScraperRunWhereInputRecursive4']
    NOT: List['ScraperRunWhereInputRecursive4']


class ScraperRunWhereInputRecursive4(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    runType: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    marketsScraped: Union[_int, 'types.IntFilter']
    marketOutcomesScraped: Union[_int, 'types.IntFilter']
    commentsScraped: Union[_int, 'types.IntFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntFilter']
    tokensProcessed: Union[_int, 'types.IntFilter']
    priceDataPointsStored: Union[_int, 'types.IntFilter']
    errors: Union[None, _str, 'types.StringFilter']
    errorCount: Union[_int, 'types.IntFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeFilter']
    endTime: Union[None, datetime.datetime, 'types.DateTimeFilter']
    durationMs: Union[None, _int, 'types.IntFilter']



# aggregate ScraperRun types


    

class ScraperRunScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    runType: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    marketsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomesScraped: Union[_int, 'types.IntWithAggregatesFilter']
    commentsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntWithAggregatesFilter']
    tokensProcessed: Union[_int, 'types.IntWithAggregatesFilter']
    priceDataPointsStored: Union[_int, 'types.IntWithAggregatesFilter']
    errors: Union[_str, 'types.StringWithAggregatesFilter']
    errorCount: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    durationMs: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ScraperRunScalarWhereWithAggregatesInputRecursive1']
    OR: List['ScraperRunScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ScraperRunScalarWhereWithAggregatesInputRecursive1']


class ScraperRunScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    runType: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    marketsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomesScraped: Union[_int, 'types.IntWithAggregatesFilter']
    commentsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntWithAggregatesFilter']
    tokensProcessed: Union[_int, 'types.IntWithAggregatesFilter']
    priceDataPointsStored: Union[_int, 'types.IntWithAggregatesFilter']
    errors: Union[_str, 'types.StringWithAggregatesFilter']
    errorCount: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    durationMs: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ScraperRunScalarWhereWithAggregatesInputRecursive2']
    OR: List['ScraperRunScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ScraperRunScalarWhereWithAggregatesInputRecursive2']


class ScraperRunScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    runType: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    marketsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomesScraped: Union[_int, 'types.IntWithAggregatesFilter']
    commentsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntWithAggregatesFilter']
    tokensProcessed: Union[_int, 'types.IntWithAggregatesFilter']
    priceDataPointsStored: Union[_int, 'types.IntWithAggregatesFilter']
    errors: Union[_str, 'types.StringWithAggregatesFilter']
    errorCount: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    durationMs: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ScraperRunScalarWhereWithAggregatesInputRecursive3']
    OR: List['ScraperRunScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ScraperRunScalarWhereWithAggregatesInputRecursive3']


class ScraperRunScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    runType: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    marketsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomesScraped: Union[_int, 'types.IntWithAggregatesFilter']
    commentsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntWithAggregatesFilter']
    tokensProcessed: Union[_int, 'types.IntWithAggregatesFilter']
    priceDataPointsStored: Union[_int, 'types.IntWithAggregatesFilter']
    errors: Union[_str, 'types.StringWithAggregatesFilter']
    errorCount: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    durationMs: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['ScraperRunScalarWhereWithAggregatesInputRecursive4']
    OR: List['ScraperRunScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ScraperRunScalarWhereWithAggregatesInputRecursive4']


class ScraperRunScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """ScraperRun arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    runType: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    marketsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    marketOutcomesScraped: Union[_int, 'types.IntWithAggregatesFilter']
    commentsScraped: Union[_int, 'types.IntWithAggregatesFilter']
    priceSnapshotsTaken: Union[_int, 'types.IntWithAggregatesFilter']
    tokensProcessed: Union[_int, 'types.IntWithAggregatesFilter']
    priceDataPointsStored: Union[_int, 'types.IntWithAggregatesFilter']
    errors: Union[_str, 'types.StringWithAggregatesFilter']
    errorCount: Union[_int, 'types.IntWithAggregatesFilter']
    startTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    endTime: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    durationMs: Union[_int, 'types.IntWithAggregatesFilter']



class ScraperRunGroupByOutput(TypedDict, total=False):
    id: _int
    runType: _str
    status: _str
    marketsScraped: _int
    marketOutcomesScraped: _int
    commentsScraped: _int
    priceSnapshotsTaken: _int
    tokensProcessed: _int
    priceDataPointsStored: _int
    errors: _str
    errorCount: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    durationMs: _int
    _sum: 'ScraperRunSumAggregateOutput'
    _avg: 'ScraperRunAvgAggregateOutput'
    _min: 'ScraperRunMinAggregateOutput'
    _max: 'ScraperRunMaxAggregateOutput'
    _count: 'ScraperRunCountAggregateOutput'


class ScraperRunAvgAggregateOutput(TypedDict, total=False):
    """ScraperRun output for aggregating averages"""
    id: float
    marketsScraped: float
    marketOutcomesScraped: float
    commentsScraped: float
    priceSnapshotsTaken: float
    tokensProcessed: float
    priceDataPointsStored: float
    errorCount: float
    durationMs: float


class ScraperRunSumAggregateOutput(TypedDict, total=False):
    """ScraperRun output for aggregating sums"""
    id: _int
    marketsScraped: _int
    marketOutcomesScraped: _int
    commentsScraped: _int
    priceSnapshotsTaken: _int
    tokensProcessed: _int
    priceDataPointsStored: _int
    errorCount: _int
    durationMs: _int


class ScraperRunScalarAggregateOutput(TypedDict, total=False):
    """ScraperRun output including scalar fields"""
    id: _int
    runType: _str
    status: _str
    marketsScraped: _int
    marketOutcomesScraped: _int
    commentsScraped: _int
    priceSnapshotsTaken: _int
    tokensProcessed: _int
    priceDataPointsStored: _int
    errors: _str
    errorCount: _int
    startTime: datetime.datetime
    endTime: datetime.datetime
    durationMs: _int


ScraperRunMinAggregateOutput = ScraperRunScalarAggregateOutput
ScraperRunMaxAggregateOutput = ScraperRunScalarAggregateOutput


class ScraperRunMaxAggregateInput(TypedDict, total=False):
    """ScraperRun input for aggregating by max"""
    id: bool
    runType: bool
    status: bool
    marketsScraped: bool
    marketOutcomesScraped: bool
    commentsScraped: bool
    priceSnapshotsTaken: bool
    tokensProcessed: bool
    priceDataPointsStored: bool
    errors: bool
    errorCount: bool
    startTime: bool
    endTime: bool
    durationMs: bool


class ScraperRunMinAggregateInput(TypedDict, total=False):
    """ScraperRun input for aggregating by min"""
    id: bool
    runType: bool
    status: bool
    marketsScraped: bool
    marketOutcomesScraped: bool
    commentsScraped: bool
    priceSnapshotsTaken: bool
    tokensProcessed: bool
    priceDataPointsStored: bool
    errors: bool
    errorCount: bool
    startTime: bool
    endTime: bool
    durationMs: bool


class ScraperRunNumberAggregateInput(TypedDict, total=False):
    """ScraperRun input for aggregating numbers"""
    id: bool
    marketsScraped: bool
    marketOutcomesScraped: bool
    commentsScraped: bool
    priceSnapshotsTaken: bool
    tokensProcessed: bool
    priceDataPointsStored: bool
    errorCount: bool
    durationMs: bool


ScraperRunAvgAggregateInput = ScraperRunNumberAggregateInput
ScraperRunSumAggregateInput = ScraperRunNumberAggregateInput


ScraperRunCountAggregateInput = TypedDict(
    'ScraperRunCountAggregateInput',
    {
        'id': bool,
        'runType': bool,
        'status': bool,
        'marketsScraped': bool,
        'marketOutcomesScraped': bool,
        'commentsScraped': bool,
        'priceSnapshotsTaken': bool,
        'tokensProcessed': bool,
        'priceDataPointsStored': bool,
        'errors': bool,
        'errorCount': bool,
        'startTime': bool,
        'endTime': bool,
        'durationMs': bool,
        '_all': bool,
    },
    total=False,
)

ScraperRunCountAggregateOutput = TypedDict(
    'ScraperRunCountAggregateOutput',
    {
        'id': int,
        'runType': int,
        'status': int,
        'marketsScraped': int,
        'marketOutcomesScraped': int,
        'commentsScraped': int,
        'priceSnapshotsTaken': int,
        'tokensProcessed': int,
        'priceDataPointsStored': int,
        'errors': int,
        'errorCount': int,
        'startTime': int,
        'endTime': int,
        'durationMs': int,
        '_all': int,
    },
    total=False,
)


ScraperRunKeys = Literal[
    'id',
    'runType',
    'status',
    'marketsScraped',
    'marketOutcomesScraped',
    'commentsScraped',
    'priceSnapshotsTaken',
    'tokensProcessed',
    'priceDataPointsStored',
    'errors',
    'errorCount',
    'startTime',
    'endTime',
    'durationMs',
]
ScraperRunScalarFieldKeys = Literal[
    'id',
    'runType',
    'status',
    'marketsScraped',
    'marketOutcomesScraped',
    'commentsScraped',
    'priceSnapshotsTaken',
    'tokensProcessed',
    'priceDataPointsStored',
    'errors',
    'errorCount',
    'startTime',
    'endTime',
    'durationMs',
]
ScraperRunScalarFieldKeysT = TypeVar('ScraperRunScalarFieldKeysT', bound=ScraperRunScalarFieldKeys)

ScraperRunRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields