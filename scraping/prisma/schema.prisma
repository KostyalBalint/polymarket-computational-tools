// Prisma schema for Polymarket Scraper
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// EVENT TABLES
// ============================================================================

model Event {
  id               String  @id
  ticker           String?
  slug             String? @unique
  title            String?
  description      String? @db.Text
  resolutionSource String? @db.Text

  // Dates
  startDate         String?
  creationDate      String?
  endDate           String?
  closedTime        DateTime?
  eventDate         DateTime?
  startTime         DateTime?
  finishedTimestamp DateTime?

  // Images
  image String? @db.Text
  icon  String? @db.Text

  // State
  active                Boolean? @default(false)
  closed                Boolean? @default(false)
  archived              Boolean? @default(false)
  new                   Boolean? @default(false)
  featured              Boolean? @default(false)
  restricted            Boolean? @default(false)
  isTemplate            Boolean? @default(false)
  commentsEnabled       Boolean? @default(false)
  enableOrderBook       Boolean? @default(false)
  automaticallyResolved Boolean? @default(false)
  automaticallyActive   Boolean? @default(false)
  showAllOutcomes       Boolean? @default(false)
  showMarketImages      Boolean? @default(false)
  enableNegRisk         Boolean? @default(false)
  live                  Boolean? @default(false)
  ended                 Boolean? @default(false)
  pendingDeployment     Boolean? @default(false)
  deploying             Boolean? @default(false)
  estimateValue         Boolean? @default(false)
  cantEstimate          Boolean? @default(false)

  // Financial metrics
  liquidity     Float?
  volume        Float?
  openInterest  Float?
  volume24hr    Float?
  volume1wk     Float?
  volume1mo     Float?
  volume1yr     Float?
  liquidityAmm  Float?
  liquidityClob Float?
  competitive   Float?

  // Categorization
  category String?
  sortBy   String?

  // User info
  publishedAt DateTime?
  createdBy   String?
  updatedBy   String?
  createdAt   DateTime?
  updatedAt   DateTime?

  // Related entities
  parentEvent String?
  seriesSlug  String?

  // Misc
  disqusThread                 String?
  commentCount                 Int?
  tweetCount                   Int?
  featuredOrder                Int?
  eventWeek                    Int?
  templateVariables            String?   @db.Text
  score                        String?
  elapsed                      String?
  period                       String?
  gmpChartMode                 String?
  estimatedValue               String?
  spreadsMainLine              Float?
  totalsMainLine               Float?
  carouselMap                  String?
  deployingTimestamp           DateTime?
  scheduledDeploymentTimestamp DateTime?
  gameStatus                   String?

  // Neg risk
  negRisk         Boolean? @default(false)
  negRiskMarketID String?
  negRiskFeeBips  Float?

  // Scraper metadata
  scrapedAt   DateTime @default(now()) @updatedAt
  createdInDb DateTime @default(now())

  // Relations
  // The primary relationship between events and markets is one-to-many, but the api allows many to many. (Usally one event has many markets.)
  markets           Market[]
  tags              Tag[]
  Comment           Comment[]
  CommentCheckpoint CommentCheckpoint[]

  @@index([slug])
  @@index([active])
  @@index([featured])
  @@index([closed])
}

// ============================================================================
// MARKET TABLES
// ============================================================================

model Market {
  // Primary identifiers
  id          String  @id
  conditionId String?
  questionID  String?
  slug        String? @unique

  // Market content
  question    String?
  description String? @db.Text
  category    String?

  // Images
  image String? @db.Text
  icon  String? @db.Text

  // Resolution
  resolutionSource String? @db.Text

  // Dates and timing
  startDate  DateTime?
  endDate    DateTime?
  createdAt  DateTime?
  updatedAt  DateTime?
  closedTime DateTime?

  // Market state
  active   Boolean? @default(false)
  closed   Boolean? @default(false)
  archived Boolean? @default(false)
  new      Boolean? @default(false)

  // Market type and format
  marketType String?
  formatType String?
  ammType    String?

  // Financial metrics - volume
  volume         String?
  volumeNum      Float?
  volume24hr     Float?
  volume1wk      Float?
  volume1mo      Float?
  volume1yr      Float?
  volumeAmm      Float?
  volumeClob     Float?
  volume24hrAmm  Float?
  volume1wkAmm   Float?
  volume1moAmm   Float?
  volume1yrAmm   Float?
  volume24hrClob Float?
  volume1wkClob  Float?
  volume1moClob  Float?
  volume1yrClob  Float?

  // Financial metrics - liquidity
  liquidity     String?
  liquidityNum  Float?
  liquidityAmm  Float?
  liquidityClob Float?

  // Price changes
  oneDayPriceChange   Float?
  oneHourPriceChange  Float?
  oneWeekPriceChange  Float?
  oneMonthPriceChange Float?
  oneYearPriceChange  Float?
  lastTradePrice      Float?
  bestBid             Float?
  bestAsk             Float?
  spread              Float?

  // Order book settings
  enableOrderBook Boolean? @default(false)

  // Fees
  fee          String?
  makerBaseFee Float?
  takerBaseFee Float?

  // Token and contract info
  denominationToken  String?
  marketMakerAddress String?
  clobTokenIds       String[]

  // User IDs
  createdBy Int?
  updatedBy Int?
  creator   String?

  // Grouping and series
  marketGroup        Int?
  groupItemTitle     String?
  groupItemThreshold String?
  groupItemRange     String?

  // Display and sorting
  curationOrder Int?
  score         Float?
  mailchimpTag  String?

  // Outcomes (stored as strings in API)
  outcomes      String?
  outcomePrices String?
  shortOutcomes String?

  // Timestamps
  readyTimestamp               DateTime?
  fundedTimestamp              DateTime?
  acceptingOrdersTimestamp     DateTime?
  deployingTimestamp           DateTime?
  scheduledDeploymentTimestamp DateTime?

  // Sports-specific
  gameId           String?
  teamAID          String?
  teamBID          String?
  sportsMarketType String?
  line             Float?

  // UMA specific
  umaBond        String?
  umaReward      String?
  customLiveness Int?

  // Scraper metadata
  scrapedAt   DateTime @default(now()) @updatedAt
  createdInDb DateTime @default(now())

  // Relations
  events         Event[]
  tags           Tag[]
  //Merge of the clobTokenIds and the outcomes arrays
  marketOutcomes MarketOutcome[]

  @@index([closed])
  @@index([category])
  @@index([scrapedAt])
  @@index([slug])
  @@index([active])
}

model MarketOutcome {
  id          Int    @id @default(autoincrement())
  clobTokenId String @unique // Keep as unique identifier for API references
  marketId    String

  outcomeText String

  // Relations
  market          Market       @relation(fields: [marketId], references: [id])
  priceSnapshots  TokenPrice[]
  pricesScrapedAt DateTime?
  pricesCount     Int          @default(0)

  @@index([marketId])
  @@index([clobTokenId])
}

//End of MARKET TABLES

// ============================================================================
// TAG TABLES
// ============================================================================

model Tag {
  id         String   @id
  label      String?
  slug       String?  @unique
  forceShow  Boolean? @default(false)
  forceHide  Boolean? @default(false)
  isCarousel Boolean? @default(false)

  publishedAt DateTime?
  createdBy   Int?
  updatedBy   Int?
  createdAt   DateTime?
  updatedAt   DateTime?

  // Scraper metadata
  scrapedAt   DateTime @default(now()) @updatedAt
  createdInDb DateTime @default(now())

  // Relations
  markets Market[]
  Event   Event[]

  @@index([slug])
}

// ============================================================================
// COMMENT TABLES
// ============================================================================

model Comment {
  id String @id

  // Comment content
  body String @db.Text

  // User information
  userAddress  String
  replyAddress String?

  // Parent entity (market, event, or series)
  parentEntityType String // "market", "Event", "Series"
  parentEntityID   String

  // Engagement metrics
  reactionCount Int @default(0)
  reportCount   Int @default(0)

  // Timestamps
  createdAt DateTime?
  updatedAt DateTime?
  scrapedAt DateTime  @default(now())

  // Relations
  profile UserProfile? @relation(fields: [userAddress], references: [address])
  event   Event?       @relation(fields: [parentEntityID], references: [id])

  // Threading: regular comment replies
  parentCommentID String?
  parentComment   Comment?  @relation("CommentThread", fields: [parentCommentID], references: [id])
  childComments   Comment[] @relation("CommentThread")

  reactions CommentReaction[] @relation("CommentReactions")

  @@index([userAddress])
  @@index([parentEntityType, parentEntityID])
  @@index([parentCommentID])
  @@index([createdAt])
}

model CommentReaction {
  id           String @id
  reactionType String // e.g., "HEART"
  userAddress  String

  //TODO: Maybe we could make a profile relation here, but it's currently not needed.
  //profile      UserProfile @relation(fields: [userAddress], references: [address])

  commentID String
  comment   Comment @relation("CommentReactions", fields: [commentID], references: [id])
}

model UserProfile {
  address String @id

  name                  String?
  pseudonym             String?
  displayUsernamePublic Boolean @default(false)
  bio                   String?
  isMod                 Boolean @default(false)
  isCreator             Boolean @default(false)
  proxyWallet           String? @unique
  baseAddress           String?
  profileImage          String?

  Comment      Comment[]
  UserPosition UserPosition[]
  UserTrade    UserTrade[]
}

model CommentCheckpoint {
  id      Int    @id @default(autoincrement())
  eventId String @unique

  // Pagination tracking
  lastOffset   Int @default(0)
  totalFetched Int @default(0)

  // Timestamps
  lastScrapedAt DateTime @default(now()) @updatedAt

  // Relations
  event Event @relation(fields: [eventId], references: [id])

  @@index([lastScrapedAt])
}

// ============================================================================
// PRICE HISTORY TABLES
// ============================================================================

model TokenPrice {
  id              Int @id @default(autoincrement())
  marketOutcomeId Int // Foreign key to MarketOutcome

  // Price data from Polymarket API
  timestamp DateTime // Unix timestamp converted to DateTime
  price     Float // Price at this timestamp

  marketOutcome MarketOutcome @relation(fields: [marketOutcomeId], references: [id])

  @@unique([marketOutcomeId, timestamp])
  @@index([marketOutcomeId])
  @@index([timestamp])
}

// ============================================================================
// USER POSITIONS AND TRADES TABLES
// ============================================================================

model UserPosition {
  id          Int    @id @default(autoincrement())
  proxyWallet String
  asset       String
  conditionId String

  // Position metrics
  size               Float
  avgPrice           Float
  initialValue       Float
  currentValue       Float
  cashPnl            Float
  percentPnl         Float
  totalBought        Float
  realizedPnl        Float
  percentRealizedPnl Float
  curPrice           Float

  // Status
  redeemable   Boolean
  mergeable    Boolean
  negativeRisk Boolean

  // Market info
  title           String
  slug            String
  icon            String?
  eventSlug       String
  outcome         String
  outcomeIndex    Int
  oppositeOutcome String
  oppositeAsset   String
  endDate         String

  // Scraper metadata
  scrapedAt   DateTime @default(now()) @updatedAt
  createdInDb DateTime @default(now())

  // Relations
  userProfile UserProfile @relation(fields: [proxyWallet], references: [proxyWallet])

  @@index([proxyWallet])
  @@index([conditionId])
  @@index([scrapedAt])
}

model UserTrade {
  id          Int    @id @default(autoincrement())
  proxyWallet String
  side        String // 'BUY' or 'SELL'
  asset       String
  conditionId String

  // Trade details
  size            Float
  price           Float
  timestamp       DateTime
  transactionHash String   @unique

  // Market info
  title        String
  slug         String
  icon         String?
  eventSlug    String
  outcome      String
  outcomeIndex Int

  // Scraper metadata
  scrapedAt   DateTime @default(now())
  createdInDb DateTime @default(now())

  // Relations
  userProfile UserProfile @relation(fields: [proxyWallet], references: [proxyWallet])

  @@index([proxyWallet])
  @@index([conditionId])
  @@index([timestamp])
  @@index([transactionHash])
}

// ============================================================================
// SCRAPER METADATA TABLES
// ============================================================================

model ScraperRun {
  id Int @id @default(autoincrement())

  // Run metadata
  runType String // "markets", "comments", "prices", "price-history", "user-positions", "user-trades", "all"
  status  String @default("running") // "running", "completed", "failed"

  // Statistics
  marketsScraped        Int @default(0)
  marketOutcomesScraped Int @default(0)
  commentsScraped       Int @default(0)
  priceSnapshotsTaken   Int @default(0)
  tokensProcessed       Int @default(0)
  priceDataPointsStored Int @default(0)
  userPositionsScraped  Int @default(0)
  userTradesScraped     Int @default(0)
  usersProcessed        Int @default(0)

  // Error tracking
  errors     String? @db.Text
  errorCount Int     @default(0)

  // Timing
  startTime  DateTime  @default(now())
  endTime    DateTime?
  durationMs Int? // Duration in milliseconds

  @@index([runType])
  @@index([status])
  @@index([startTime])
}
